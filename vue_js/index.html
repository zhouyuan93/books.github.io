<!-- saved from url=(0092)http://e-m.jd.com/static/read/dist/index.html?ebookId=30425769&name=Vue.js%E5%AE%9E%E6%88%98 -->
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">
    <meta content="no-cache,must-revalidate" http-equiv="Cache-Control">
    <meta content="no-cache" http-equiv="pragma">
    <meta content="0" http-equiv="expires">
    <meta content="telephone=no, address=no" name="format-detection">
    <meta name="”apple-mobile-web-app-capable”" content="”yes”">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="京东读书">
    <title></title>
    <link href="./index_files/cread_book.c77460a7.css" type="text/css" rel="stylesheet">
    <script type="text/javascript" src="./index_files/read.ad8faab2.js.下载"></script>
    <script></script>
    <script type="text/javascript" src="./index_files/sdk_release.js.下载"></script>
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/stylesheet30425769.css" rel="stylesheet" type="text/css">
    <link href="./index_files/page_styles30425769.css" rel="stylesheet" type="text/css">
</head>
<body style="background-color: rgb(234, 234, 234);">
<section class="JD_header" >
    <section><a href="javascript:history.go(-1);" class="back on">
        <svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="200" height="200">
            <defs>
                <style></style>
            </defs>
            <path d="M754.861 994.742a41.078 41.078 0 01-27.389-10.451l-495.31-441.53a41.389 41.389 0 010-61.847l495.31-441.53a41.14 41.14 0 0158.244 3.438 41.444 41.444 0 01-3.41 58.438L321.704 511.852l460.602 410.563a41.444 41.444 0 01-27.445 72.327z"></path>
        </svg>
    </a>
        <p class="book-name" id="book-name">Vue.js实战</p> <a class="JD_header_baidu"> 免费获得 </a> <a class="JD_header_tts">
            <img src="./index_files/tts@2x.17535456.png" alt=""> </a> <a class="JD_header_menu">
            <svg class="icon" viewBox="0 0 1447 1024" xmlns="http://www.w3.org/2000/svg" width="282.617" height="200">
                <path d="M203.081 564.697h953.38a52.965 52.965 0 000-105.93H203.08a52.965 52.965 0 000 105.93zm0-459.033h953.38a52.965 52.965 0 000-105.933H203.08a52.965 52.965 0 000 105.931zm0 918.068h953.38a52.965 52.965 0 000-105.93H203.08a52.965 52.965 0 000 105.93z"></path>
            </svg>
        </a></section>
</section>
<section id="JD_article" class="article" bookid="$!{bookId}" ondrag="return false;" style="height: 101%;">
    <div id="JD_content" ondrag="return false;" style="min-height: -webkit-fill-available;">
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; background-color: rgb(234, 234, 234); width: 1518px;"
             id="page0" page="0" data-chapter-index="13" data-chapter-url="24047087" alt="64157267">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第1章　初识Vue.js</h2>
                <p class="calibre4 pv pid3" id="p3">
                    本章主要介绍与Vue.js有关的一些概念与技术，并帮助你了解它们背后相关的工作原理。通过对本章的学习，即使从未接触过Vue.js，你也可以运用这些知识点快速构建出一个Vue.js应用。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_1 pv pid4" id="p4" name="sigil_toc_id_1">1.1　Vue.js是什么</h3>
                <p class="calibre4 pv pid5" id="p5">Vue.js的官方文档中是这样介绍它的。</p>
                <p class="calibre4 pv pid6" id="p6">简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。</p>
                <p class="calibre4 pv pid7" id="p7">
                    简单小巧是指Vue.js压缩后大小仅有17KB。所谓渐进式（Progressive），就是你可以一步一步、有阶段性地来使用Vue.js，不必一开始就使用所有的东西。随着本书的不断介绍，你会深刻感受到这一点，这也正是开发者热爱Vue.js的主要原因之一。</p>
                <p class="calibre4 pv pid8" id="p8">使用Vue.js可以让Web开发变得简单，同时也颠覆了传统前端开发模式。它提供了现代Web开发中常见的高级功能，比如：</p>
                <ul class="kindle-cn-ul-disc pv pid9" id="p9" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">解耦视图与数据。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">可复用的组件。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">前端路由。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">状态管理。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">虚拟DOM（Virtual DOM）。</span></li>
                </ul>
                <h4 class="kindle-cn-heading3 sigil_toc_id_2 pv pid9" id="p9" name="sigil_toc_id_2">1.1.1　MVVM模式</h4>
                <p class="calibre4 pv pid10" id="p10">与知名前端框架Angular、Ember等一样，Vue.js在设计上也使用MVVM（Model-View-View
                    Model）模式。</p>
                <p class="calibre4 pv pid11" id="p11">
                    MVVM模式是由经典的软件架构MVC衍生来的。当View（视图层）变化时，会自动更新到ViewModel（视图模型），反之亦然。View和ViewModel之间通过双向绑定（data-binding）建立联系，如图1-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid12" id="p12" style="margin: 0px;"><img alt="018"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/45705c02ae37c322.jpg"
                                                                                                         href="./image/00002.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图1-1　MVVM关系</p></div>
                <h4 class="kindle-cn-heading3 sigil_toc_id_3 pv pid12" id="p12" name="sigil_toc_id_3">
                    1.1.2　Vue.js有什么不同</h4>
                <p class="calibre4 pv pid13" id="p13">
                    如果你使用过jQuery，那你一定对操作DOM、绑定事件等这些原生JavaScript能力非常熟悉，比如我们在指定DOM中插入一个元素，并给它绑定一个点击事件：</p>
                <pre class="calibre7 pv pid14" id="p14">if (showBtn) {
    var btn = $('&lt;button&gt;Click me&lt;/button&gt;');
    btn.on('click', function () {
        console.log('Clicked!');
    });
    $('#app').append(btn);
}</pre>
                <p class="calibre4 pv pid15" id="p15">
                    这段代码不难理解，操作的内容也不复杂，不过这样让我们的视图代码和业务逻辑紧耦合在一起，随着功能不断增加，直接操作DOM会使得代码越来越难以维护。</p>
                <p class="calibre4 pv pid16" id="p16">
                    而Vue.js通过MVVM的模式拆分为视图与数据两部分，并将其分离。因此，你只需要关心你的数据即可，DOM的事情Vue会帮你自动搞定，比如上面的示例用Vue.js可以改写为：</p>
                <pre class="calibre7 pv pid17" id="p17">&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;button v-if="showBtn" v-on:click="handleClick"&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            showBtn: true
        },
        methods: {
            handleClick: function () {
                console.log('Clicked!');
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid18" id="p18">提示</p>
                <p class="kindle-cn-para-no-indent pv pid19" id="p19" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">暂时还不需要理解上述代码，这里只是快速展示Vue.js的写法，在后面的章节会详细介绍每个参数的用法。</span>
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_4 pv pid19" id="p19" name="sigil_toc_id_4">
                    1.2　如何使用Vue.js</h3>
                <p class="calibre4 pv pid20" id="p20">
                    每一个框架的产生都是为了解决某个具体的问题。在正式开始学习Vue.js前，我们先对传统前端开发模式和Vue.js的开发模式做一个对比，以此了解Vue.js产生的背景和核心思想。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_5 pv pid21" id="p21" name="sigil_toc_id_5">
                    1.2.1　传统的前端开发模式</h4>
                <p class="calibre4 pv pid22" id="p22">前端技术在近几年发展迅速，如今的前端开发已不再是10年前写个HTML和CSS那样简单了，新的概念层出不穷，比如ECMAScript
                    6、Node.js、NPM、前端工程化等。这些新东西在不断优化我们的开发模式，改变我们的编程思想。</p>
                <p class="calibre4 pv pid23" id="p23">随着这些技术的普及，一套可称为“万金油”的技术栈被许多商业项目用于生产环境：</p>
                <p class="calibre4 pv pid24" id="p24">jQuery + RequireJS（SeaJS）+ artTemplate（doT）+Gulp（Grunt）</p>
                <p class="calibre4 pv pid25" id="p25">
                    这套技术栈以jQuery为核心，能兼容绝大部分浏览器，这是很多企业比较关心的，因为他们的客户很可能还在用IE7及以下浏览器。使用RequireJS或SeaJS进行模块化开发可以解决代码依赖混乱的问题，同时便于维护及团队协作。使用轻量级的前端模板（如doT）可以将数据与HTML模板分离。最后，使用自动化构建工具（如Gulp）可以合并压缩代码，如果你喜欢写Less、Sass以及现在流行的ES
                    6，也可以帮你进行预编译。</p>
                <p class="calibre4 pv pid26" id="p26">
                    这样一套看似完美无瑕的前端解决方案就构成了我们所说的传统前端开发模式，由于它的简单、高效、实用，至今仍有不少开发者在使用。不过随着项目的扩大和时间的推移，出现了更复杂的业务场景，比如SPA（单页面富应用）、组件解耦等。为了提升开发效率，降低维护成本，传统的前端开发模式已不能完全满足我们的需求，这时就出现了如Angular、React以及我们要介绍的主角Vue.js。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_6 pv pid27" id="p27" name="sigil_toc_id_6">
                    1.2.2　Vue.js的开发模式</h4>
                <p class="calibre4 pv pid28" id="p28">
                    Vue.js是一个渐进式的JavaScript框架，根据项目需求，你可以选择从不同的维度来使用它。如果你只是想体验Vue.js带来的快感，或者开发几个简单的HTML
                    5页面或小应用，你可以直接通过script加载CDN文件，例如：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;!-- 自动识别最新稳定版本的Vue.js --&gt;
&lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
&lt;!--指定某个具体版本的Vue.js --&gt;
&lt;script src="https://unpkg.com/vue@2.1.6/dist/vue.min.js"&gt;&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">
                    两种版本都可以，如果你不太了解各版本的差别，建议直接使用最新的稳定版本。当然，你也可以将代码下载下来，通过自己的相对路径来引用。引入Vue.js框架后，在body底部使用new
                    Vue()的方式创建一个实例，这就是Vue.js最基本的开发模式。现在可以写入以下完整的代码来快速体验 Vue：</p>
                <pre class="calibre7 pv pid31" id="p31">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Vue 示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;ul&gt;
            &lt;li v-for="book in books"&gt;{{ book.name }}&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        new Vue({
            el: '#app',
            data: {
                books: [
                    { name: '《Vue.js实战》' },
                    { name: '《JavaScript语言精粹》' },
                    { name: '《JavaScript高级程序设计》' }
                ]
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid32" id="p32">在浏览器中访问它，会将图书列表循环显示出来，如图1-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid33" id="p33" style="margin: 0px;"><img alt="021"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/0edba088e99c2fe7.jpg"
                                                                                                         href="./image/00003.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图1-2　Vue.js示例在浏览器中访问的效果</p></div>
                <p class="calibre4 pv pid33" id="p33">
                    对于一些业务逻辑复杂，对前端工程有要求的项目，可以使用Vue单文件的形式配合webpack使用，必要时还会用到vuex来管理状态，vue-router来管理路由。这里提到了很多概念，目前还不必去过多了解，只是说明Vue.js框架的开发模式多样化，后续章节会详细介绍，到时就会对整个Vue生态有所了解了。</p>
                <p class="calibre4 pv pid34" id="p34">了解了Vue.js的开发模式后，相信你已经迫不及待地想开启Vue的大门了。下一章，我们就直接进入话题，创建第一个Vue应用。</p>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="14" data-chapter-url="24047088" alt="64157268">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第2章　数据绑定和第一个Vue应用</h2>
                <p class="calibre4 pv pid3" id="p3">学习任何一种框架，从一个Hello
                    World应用开始是最快了解该框架特性的途径，我们先从一段简单的HTML代码开始，感受Vue.js最核心的功能。</p>
                <pre class="calibre7 pv pid4" id="p4">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Vue 示例&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;input type="text" v-model="name" placeholder="你的名字"&gt;
        &lt;h1&gt;你好，{{ name }}&lt;/h1&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var app = new Vue({
            el: '#app',
            data: {
                name: ''
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid5" id="p5">这是一段简单到不能再简单的代码，但却展示出了Vue.js最核心的功能：数据的双向绑定。在输入框输入的内容会实时展示在页面的h1
                    标签内，如图2-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid6" id="p6" style="margin: 0px;"><img alt="023"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/bd458362aa3d71eb.jpg"
                                                                                                       href="./image/00004.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图2-1　展示内容</p></div>
                <p class="kindle-cn-para-left pv pid6" id="p6">提示</p>
                <p class="kindle-cn-para-no-indent pv pid7" id="p7" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">从本章开始，示例不再提供完整的代码，而是根据上下文，将HTML部分与JavaScript部分单独展示，省略了head、body等标签以及Vue.js的加载等，读者可根据上例结构来组织代码。</span>
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_7 pv pid7" id="p7" name="sigil_toc_id_7">2.1　Vue实例与数据绑定</h3>
                <h4 class="kindle-cn-heading3 sigil_toc_id_8 pv pid8" id="p8" name="sigil_toc_id_8">2.1.1　实例与数据</h4>
                <p class="calibre4 pv pid9" id="p9">Vue.js应用的创建很简单，通过构造函数Vue就可以创建一个Vue的根实例，并启动Vue应用：</p>
                <pre class="calibre7 pv pid10" id="p10">var app = new Vue({
    //选项
})</pre>
                <p class="calibre4 pv pid11" id="p11">变量app就代表了这个Vue实例。事实上，几乎所有的代码都是一个对象，写入Vue实例的选项内的。</p>
                <p class="calibre4 pv pid12" id="p12">首先，必不可少的一个选项就是el。el用于指定一个页面中已存在的DOM元素来挂载Vue实例，它可以是HTMLElement
                    ，也可以是CSS选择器，比如：</p>
                <pre class="calibre7 pv pid13" id="p13">&lt;div id="app"&gt;&lt;/div&gt;

var app = new Vue({
    el: document.getElementById('app')  //或者是'#app'
})</pre>
                <p class="calibre4 pv pid14" id="p14">
                    挂载成功后，我们可以通过app.$el来访问该元素。Vue提供了很多常用的实例属性与方法，都以$开头，比如$el，后续还会介绍更多有用的方法。</p>
                <p class="calibre4 pv pid15" id="p15">回顾章节开始的Hello
                    World代码，在input标签上，有一个v-model的指令，它的值对应于我们创建的Vue实例的data选项中的name字段，这就是Vue的数据绑定。</p>
                <p class="calibre4 pv pid16" id="p16">
                    通过Vue实例的data选项，可以声明应用内需要双向绑定的数据。建议所有会用到的数据都预先在data内声明，这样不至于将数据散落在业务逻辑中，难以维护。</p>
                <p class="calibre4 pv pid17" id="p17">Vue实例本身也代理了data对象里的所有属性，所以可以这样访问：</p>
                <pre class="calibre7 pv pid18" id="p18">var app = new Vue({
    el: '#app',
    data: {
        a: 2
    }
})

console.log(app.a);  // 2</pre>
                <p class="calibre4 pv pid19" id="p19">除了显式地声明数据外，也可以指向一个已有的变量，并且它们之间默认建立了双向绑定，当修改其中任意一个时，另一个也会一起变化：</p>
                <pre class="calibre7 pv pid20" id="p20">var myData = {
    a: 1
}
var app = new Vue({
    el: '#app',
    data: myData
})

console.log(app.a);  // 1
//修改属性，原数据也会随之修改
app.a = 2;
console.log(myData.a);  // 2

// 反之，修改原数据，Vue属性也会修改
myData.a = 3;
console.log(app.a);  // 3</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_9 pv pid21" id="p21" name="sigil_toc_id_9">2.1.2　生命周期</h4>
                <p class="calibre4 pv pid22" id="p22">
                    每个Vue实例创建时，都会经历一系列的初始化过程，同时也会调用相应的生命周期钩子，我们可以利用这些钩子，在合适的时机执行我们的业务逻辑。如果你使用过jQuery，一定知道它的ready()方法，比如以下示例：</p>
                <pre class="calibre7 pv pid23" id="p23">$(document).ready(function() {
    // DOM 加载完后，会执行这里的代码
});</pre>
                <p class="calibre4 pv pid24" id="p24">Vue的生命周期钩子与之类似，比较常用的有：</p>
                <ul class="kindle-cn-ul-disc pv pid25" id="p25" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">created　实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载，$el还不可用。需要初始化处理一些数据时会比较有用，后面章节将有介绍。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">mounted　el挂载到实例上后调用，一般我们的第一个业务逻辑会在这里开始。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">beforeDestroy　实例销毁之前调用。主要解绑一些使用addEventListener监听的事件等。</span>
                    </li>
                </ul>
                <p class="calibre4 pv pid25" id="p25">这些钩子与el和data类似，也是作为选项写入Vue实例内，并且钩子的this指向的是调用它的Vue实例：</p>
                <pre class="calibre7 pv pid26" id="p26">var app = new Vue({
    el: '#app',
    data: {
        a: 2
    },
    created: function () {
        console.log(this.a);  // 2
    },
    mounted: function () {
        console.log(this.$el);  // &lt;div id="app"&gt;&lt;/div&gt;
    }
})</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_10 pv pid27" id="p27" name="sigil_toc_id_10">
                    2.1.3　插值与表达式</h4>
                <p class="calibre4 pv pid28" id="p28">使用双大括号（Mustache语法）“{{ }}”是最基本的文本插值方法，它会自动将我们双向绑定的数据实时显示出来，例如：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div id="app"&gt;
    {{ book }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            book: '《Vue.js实战》'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">
                    大括号里的内容会被替换为《Vue.js实战》，通过任何方法修改数据book，大括号的内容都会被实时替换，比如下面的这个示例，实时显示当前的时间，每秒更新：</p>
                <pre class="calibre7 pv pid31" id="p31">&lt;div id="app"&gt;
    {{ date }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            date: new Date()
        },
        mounted: function () {
            var _this = this;  // 声明一个变量指向Vue实例this，保证作用域一致
            this.timer = setInterval(function() {
                _this.date = new Date();  //修改数据date
            }, 1000);
        },
        beforeDestroy: function () {
            if (this.timer) {
                clearInterval(this.timer);  //在Vue实例销毁前，清除我们的定时器
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid32" id="p32">提示</p>
                <p class="kindle-cn-para-no-indent pv pid33" id="p33" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">这里的{{ date }}输出的是浏览器默认的时间格式，比如2017-01-02T14:04:49.470Z，并非格式化的时间（2017-01-02 22:04:49），所以需要注意时区。有多种方法可以对时间格式化，比如赋值前先使用自定义的函数处理。Vue的过滤器（filter）或计算属性（computed）也可以实现，稍后会介绍到。</span>
                </p>
                <p class="calibre4 pv pid33" id="p33">如果有的时候就是想输出HTML，而不是将数据解释后的纯文本，可以使用v-html：</p>
                <pre class="calibre7 pv pid34" id="p34">&lt;div id="app"&gt;
    &lt;span v-html="link"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            link: '&lt;a href="#"&gt;这是一个连接&lt;/a&gt;'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid35" id="p35">
                    link的内容将会被渲染为一个具有点击功能的a标签，而不是纯文本。这里要注意，如果将用户产生的内容使用v-html输出后，有可能导致XSS攻击，所以要在服务端对用户提交的内容进行处理，一般可将尖括号“&lt;
                    &gt;”转义。</p>
                <p class="calibre4 pv pid36" id="p36">如果想显示{{ }}标签，而不进行替换，使用v-pre即可跳过这个元素和它的子元素的编译过程，例如：</p>
                <pre class="calibre7 pv pid37" id="p37">&lt;span v-pre&gt;{{ 这里的内容是不会被编译的}}&lt;/span&gt;</pre>
                <p class="calibre4 pv pid38" id="p38">在{{ }}中，除了简单的绑定属性值外，还可以使用JavaScript表达式进行简单的运算、三元运算等，例如：</p>
                <pre class="calibre7 pv pid39" id="p39">&lt;div id="app"&gt;
    {{ number / 10 }}
    {{ isOK ? '确定' : '取消' }}
    {{ text.split(',').reverse().join(',') }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            number: 100,
            isOK: false,
            text: '123,456'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid40" id="p40">显示结果依次为：10、取消、456,123。</p>
                <p class="calibre4 pv pid41" id="p41">
                    Vue.js只支持单个表达式，不支持语句和流控制。另外，在表达式中，不能使用用户自定义的全局变量，只能使用Vue白名单内的全局变量，例如Math和Date。以下是一些无效的示例：</p>
                <pre class="calibre7 pv pid42" id="p42">&lt;!-- 这是语句，不是表达式 --&gt;
{{ var book = 'Vue.js实战' }}
&lt;!--不能使用流控制，要使用三元运算 --&gt;
{{ if (ok) return msg }}</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_11 pv pid43" id="p43" name="sigil_toc_id_11">2.1.4　过滤器</h4>
                <p class="calibre4 pv pid44" id="p44">Vue.js支持在{{
                    }}插值的尾部添加一个管道符“（|）”对数据进行过滤，经常用于格式化文本，比如字母全部大写、货币千位使用逗号分隔等。过滤的规则是自定义的，通过给Vue实例添加选项filters来设置，例如在上一节中实时显示当前时间的示例，可以对时间进行格式化处理：</p>
                <pre class="calibre7 pv pid45" id="p45">&lt;div id="app"&gt;
    {{ date | formatDate }}
&lt;/div&gt;
&lt;script&gt;
    //在月份、日期、小时等小于10时前面补 0
    var padDate = function(value) {
        return value &lt; 10 ? '0' + value : value;
    };

    var app = new Vue({
        el: '#app',
        data: {
            date: new Date()
        },
        filters: {
            formatDate: function (value) {  // 这里的value就是需要过滤的数据
                var date = new Date(value);
                var year = date.getFullYear();
                var month = padDate(date.getMonth() + 1);
                var day = padDate(date.getDate());
                var hours = padDate(date.getHours());
                var minutes = padDate(date.getMinutes());
                var seconds = padDate(date.getSeconds());
                //将整理好的数据返回出去
                return year + '-' + month + '-' + day + ' ' + hours + ':' + minutes + ':' + seconds;
            }
        },
        mounted: function () {
            var _this = this;  // 声明一个变量指向 Vue实例this，保证作用域一致
            this.timer = setInterval(function() {
                _this.date = new Date();  //修改数据date
            }, 1000);
        },
        beforeDestroy: function () {
            if (this.timer) {
                clearInterval(this.timer);  //在Vue实例销毁前，清除我们的定时器
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid46" id="p46">过滤器也可以串联，而且可以接收参数，例如：</p>
                <pre class="calibre7 pv pid47" id="p47">&lt;!-- 串联 --&gt;
{{ message | filterA | filterB }}

&lt;!-- 接收参数--&gt;
{{ message | filterA('arg1', 'arg2') }}</pre>
                <p class="calibre4 pv pid48" id="p48">这里的字符串arg1和arg2将分别传给过滤器的第二个和第三个参数，因为第一个是数据本身。</p>
                <p class="kindle-cn-para-left pv pid49" id="p49">提示</p>
                <p class="kindle-cn-para-no-indent pv pid50" id="p50" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">过滤器应当用于处理简单的文本转换，如果要实现更为复杂的数据变换，应该使用计算属性，下一章中会详细介绍它的用法。</span>
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_12 pv pid50" id="p50" name="sigil_toc_id_12">2.2　指令与事件</h3>
                <p class="calibre4 pv pid51" id="p51">
                    指令（Directives）是Vue.js模板中最常用的一项功能，它带有前缀v-，在前文我们已经使用过不少指令了，比如v-if、v-html、v-pre等。指令的主要职责就是当其表达式的值改变时，相应地将某些行为应用到DOM上，以v-if为例：</p>
                <pre class="calibre7 pv pid52" id="p52">&lt;div id="app"&gt;
    &lt;p v-if="show"&gt;显示这段文本&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            show: true
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid53" id="p53">
                    当数据show的值为true时，p元素会被插入，为false时则会被移除。数据驱动DOM是Vue.js的核心理念，所以不到万不得已时不要主动操作DOM，你只需要维护好数据，DOM的事Vue会帮你优雅的处理。</p>
                <p class="calibre4 pv pid54" id="p54">
                    Vue.js内置了很多指令，帮助我们快速完成常见的DOM操作，比如循环渲染、显示与隐藏等。在第5章会详细地介绍这些内置指令，但在此之前，你需要先知道v-bind和v-on。</p>
                <p class="calibre4 pv pid55" id="p55">v-bind的基本用途是动态更新HTML元素上的属性，比如id、class等，例如下面几个示例：</p>
                <pre class="calibre7 pv pid56" id="p56">&lt;div id="app"&gt;
    &lt;a v-bind:href="url"&gt;链接&lt;/a&gt;
    &lt;img v-bind:src="imgUrl"&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            url: 'https://www.github.com',
            imgUrl: 'http://xxx.xxx.xx/img.png'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid57" id="p57">示例中的链接地址与图片的地址都与数据进行了绑定，当通过各种方式改变数据时，链接和图片都会自动更新。上述示例渲染后的结果为：</p>
                <pre class="calibre7 pv pid58" id="p58">&lt;a href="https://www.github.com"&gt;链接&lt;/a&gt;
&lt;img src="http://xxx.xxx.xx/img.png"&gt;</pre>
                <p class="calibre4 pv pid59" id="p59">以上是介绍v-bind最基本的用法，它在Vue.js组件中还有着重要的作用，将在第4章和第7章中详细介绍。</p>
                <p class="calibre4 pv pid60" id="p60">另一个非常重要的指令就是v-on，它用来绑定事件监听器，这样我们就可以做一些交互了，先来看下面的示例：</p>
                <pre class="calibre7 pv pid61" id="p61">&lt;div id="app"&gt;
    &lt;p v-if="show"&gt;这是一段文本&lt;/p&gt;
    &lt;button v-on:click="handleClose"&gt;点击隐藏&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            show: true
        },
        methods: {
            handleClose: function () {
                this.show = false;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid62" id="p62">
                    在button按钮上，使用v-on:click给该元素绑定了一个点击事件，在普通元素上，v-on可以监听原生的DOM事件，除了click外，还有dblclick、keyup、mousemove等。表达式可以是一个方法名，这些方法都写在Vue实例的methods属性内，并且是函数的形式，函数内的this指向的是当前Vue实例本身，因此可以直接使用this.xxx的形式来访问或修改数据，如示例中的this.show
                    = false;把数据show修改为了false，所以点击按钮时，文本p元素就被移除了。</p>
                <p class="calibre4 pv pid63" id="p63">表达式除了方法名，也可以直接是一个内联语句，上例也可以改写为：</p>
                <pre class="calibre7 pv pid64" id="p64">&lt;div id="app"&gt;
    &lt;p v-if="show"&gt;这是一段文本&lt;/p&gt;
    &lt;button v-on:click="show = false"&gt;点击隐藏&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            show: true
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid65" id="p65">如果绑定的事件要处理复杂的业务逻辑，建议还是在methods里声明一个方法，这样可读性更强也好维护。</p>
                <p class="calibre4 pv pid66" id="p66">Vue.js将methods里的方法也代理了，所以也可以像访问Vue数据那样来调用方法：</p>
                <pre class="calibre7 pv pid67" id="p67">&lt;div id="app"&gt;
    &lt;p v-if="show"&gt;这是一段文本&lt;/p&gt;
    &lt;button v-on:click="handleClose"&gt;点击隐藏&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            show: true
        },
        methods: {
            handleClose: function () {
                this.close();
            },
            close: function () {
                this.show = false;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid68" id="p68">
                    在handleClose方法内，直接通过this.close()调用了close()函数。在上面示例中是多此一举的，只是用于演示它的用法，在业务中会经常用到，例如以下几种用法都是正确的：</p>
                <pre class="calibre7 pv pid69" id="p69">&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            show: true
        },
        methods: {
            init: function (text) {
                console.log(text);
            }
        },
        mounted: function () {
            this.init('在初始化时调用');  //在初始化时调用
        }
    });

    app.init('通过外部调用');   //在Vue实例外部调用
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid70" id="p70">更多关于v-on事件的用法将会在第7章中详细介绍。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_13 pv pid71" id="p71" name="sigil_toc_id_13">2.3　语法糖</h3>
                <p class="calibre4 pv pid72" id="p72">语法糖是指在不影响功能的情况下，添加某种方法实现同样的效果，从而方便程序开发。</p>
                <p class="calibre4 pv pid73" id="p73">Vue.js的v-bind和v-on指令都提供了语法糖，也可以说是缩写，比如v-bind，可以省略v-bind，直接写一个冒号“:”
                    ：</p>
                <pre class="calibre7 pv pid74" id="p74">&lt;a v-bind:href="url"&gt;链接&lt;/a&gt;
&lt;img v-bind:src="imgUrl"&gt;
&lt;!-- 缩写为--&gt;
&lt;a :href="url"&gt;链接&lt;/a&gt;
&lt;img :src="imgUrl"&gt;</pre>
                <p class="calibre4 pv pid75" id="p75">v-on可以直接用“@”来缩写：</p>
                <pre class="calibre7 pv pid76" id="p76">&lt;button v-on:click="handleClose"&gt;点击隐藏&lt;/button&gt;
&lt;!-- 缩写为--&gt;
&lt;button @click="handleClose"&gt;点击隐藏&lt;/button&gt;</pre>
                <p class="calibre4 pv pid77" id="p77">使用语法糖可以简化代码的书写，从下一章开始，所有示例的v-bind和v-on指令将默认使用语法糖的写法。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="22" data-chapter-url="24047089" alt="64157276">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第3章　计算属性</h2>
                <p class="calibre4 pv pid3" id="p3">模板内的表达式常用于简单的运算，当其过长或逻辑复杂时，会难以维护，本章的计算属性就是用于解决该问题的。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_14 pv pid4" id="p4" name="sigil_toc_id_14">3.1　什么是计算属性</h3>
                <p class="calibre4 pv pid5" id="p5">
                    通过上一章的介绍，我们已经可以搭建出一个简单的Vue应用，在模板中双向绑定一些数据或表达式了。但是表达式如果过长，或逻辑更为复杂时，就会变得臃肿甚至难以阅读和维护，比如：</p>
                <pre class="calibre7 pv pid6" id="p6">&lt;div&gt;
    {{ text.split(',').reverse().join(',') }}
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid7" id="p7">这里的表达式包含3个操作，并不是很清晰，所以在遇到复杂的逻辑时应该使用计算属性。上例可以用计算属性进行改写：</p>
                <pre class="calibre7 pv pid8" id="p8">&lt;div id="app"&gt;
    {{ reversedText }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            text: '123,456'
        },
        computed: {
            reversedText: function () {
                // 这里的this指向的是当前的Vue实例
                return this.text.split(',').reverse().join(',');
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid9" id="p9">所有的计算属性都以函数的形式写在Vue实例内的computed选项内，最终返回计算后的结果。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_15 pv pid10" id="p10" name="sigil_toc_id_15">3.2　计算属性用法</h3>
                <p class="calibre4 pv pid11" id="p11">
                    在一个计算属性里可以完成各种复杂的逻辑，包括运算、函数调用等，只要最终返回一个结果就可以。除了上例简单的用法，计算属性还可以依赖多个Vue实例的数据，只要其中任一数据变化，计算属性就会重新执行，视图也会更新。例如，下面的示例展示的是在购物车内两个包裹的物品总价：</p>
                <pre class="calibre7 pv pid12" id="p12">&lt;div id="app"&gt;
    总价：{{ prices }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            package1: [
                {
                    name: 'iPhone 7',
                    price: 7199,
                    count: 2
                },
                {
                    name: 'iPad',
                    price: 2888,
                    count: 1
                }
            ],
            package2: [
                {
                    name: 'apple',
                    price: 3,
                    count: 5
                },
                {
                    name: 'banana',
                    price: 2,
                    count: 10
                }
            ]
        },
        computed: {
            prices: function () {
                var prices = 0;
                for (var i = 0; i &lt; this.package1.length; i++) {
                    prices += this.package1[i].price * this.package1[i].count;
                }
                for (var i = 0; i &lt; this.package2.length; i++) {
                    prices += this.package2[i].price * this.package2[i].count;
                }
                return prices;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid13" id="p13">
                    当package1或package2中的商品有任何变化，比如购买数量变化或增删商品时，计算属性prices就会自动更新，视图中的总价也会自动变化。</p>
                <p class="calibre4 pv pid14" id="p14">
                    每一个计算属性都包含一个getter和一个setter，我们上面的两个示例都是计算属性的默认用法，只是利用了getter来读取。在你需要时，也可以提供一个setter函数，当手动修改计算属性的值就像修改一个普通数据那样时，就会触发setter函数，执行一些自定义的操作，例如：</p>
                <pre class="calibre7 pv pid15" id="p15">&lt;div id="app"&gt;
    姓名：{{ fullName }}
&lt;/div&gt;
&lt;script&gt;
var app = new Vue({
    el: '#app',
    data: {
        firstName: 'Jack',
        lastName: 'Green'
    },
    computed: {
        fullName: {
            // getter，用于读取
            get: function () {
                return this.firstName + ' ' + this.lastName;
            },
            // setter，写入时触发
            set: function (newValue) {
                var names = newValue.split(' ');
                this.firstName = names[0];
                this.lastName = names[names.length - 1];
            }
        }
    }
});
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid16" id="p16">当执行app.fullName = 'John
                    Doe';时，setter就会被调用，数据firstName和lastName都会相对更新，视图同样也会更新。</p>
                <p class="calibre4 pv pid17" id="p17">
                    绝大多数情况下，我们只会用默认的getter方法来读取一个计算属性，在业务中很少用到setter，所以在声明一个计算属性时，可以直接使用默认的写法，不必将getter和setter都声明。</p>
                <p class="calibre4 pv pid18" id="p18">
                    计算属性除了上述简单的文本插值外，还经常用于动态地设置元素的样式名称class和内联样式style，在下章会介绍这方面的内容。当使用组件时，计算属性也经常用来动态传递props，这也会在第7章组件里详细介绍。</p>
                <p class="calibre4 pv pid19" id="p19">
                    计算属性还有两个很实用的小技巧容易被忽略：一是计算属性可以依赖其他计算属性；二是计算属性不仅可以依赖当前Vue实例的数据，还可以依赖其他实例的数据，例如：</p>
                <pre class="calibre7 pv pid20" id="p20">&lt;div id="app1"&gt;&lt;/div&gt;
&lt;div id="app2"&gt;
    {{ reversedText }}
&lt;/div&gt;
&lt;script&gt;
    var app1 = new Vue({
        el: '#app1',
        data: {
            text: '123,456'
        }
    });

    var app2 = new Vue({
        el: '#app2',
        computed: {
            reversedText: function () {
                // 这里依赖的是实例app1的数据text
                return app1.text.split(',').reverse().join(',');
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid21" id="p21">
                    这里我们创建了两个Vue实例app1和app2，在app2的计算属性reversedText中，依赖的是app1的数据text，所以当text变化时，实例app2的计算属性也会变化。这样的用法在后面章节介绍的组件和组件化里会用到，尤其是在多人协同开发时很常用，因为你写的一个组件所用得到的数据需要依赖他人的组件提供。随着后面对组件的深入会慢慢意识到这点，现在可以不用太过了解。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_16 pv pid22" id="p22" name="sigil_toc_id_16">3.3　计算属性缓存</h3>
                <p class="calibre4 pv pid23" id="p23">
                    在上一章介绍指令与事件时，你可能发现调用methods里的方法也可以与计算属性起到同样的作用，比如本章第一个示例可以用methods改写为：</p>
                <pre class="calibre7 pv pid24" id="p24">&lt;div id="app"&gt;
    &lt;!-- 注意，这里的reversedText是方法，所以要带()--&gt;
    {{ reversedText() }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            text: '123,456'
        },
        methods: {
            reversedText: function () {
                // 这里的this指向的是当前Vue实例
                return this.text.split(',').reverse().join(',');
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid25" id="p25">
                    没有使用计算属性，在methods里定义了一个方法实现了相同的效果，甚至该方法还可以接受参数，使用起来更灵活。既然使用methods就可以实现，那么为什么还需要计算属性呢？原因就是计算属性是基于它的依赖缓存的。一个计算属性所依赖的数据发生变化时，它才会重新取值，所以text只要不改变，计算属性也就不更新，例如：</p>
                <pre class="calibre7 pv pid26" id="p26">computed: {
    now: function () {
        return Date.now();
    }
}</pre>
                <p class="calibre4 pv pid27" id="p27">
                    这里的Date.now()不是响应式依赖，所以计算属性now不会更新。但是methods则不同，只要重新渲染，它就会被调用，因此函数也会被执行。</p>
                <p class="calibre4 pv pid28" id="p28">使用计算属性还是methods取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存。</p>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="26" data-chapter-url="24047090" alt="64157280">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">
                第4章　v-bind及class与style绑定</h2>
                <p class="calibre4 pv pid3" id="p3">
                    DOM元素经常会动态地绑定一些class类名或style样式，本章将介绍使用v-bind指令来绑定class和style的多种方法。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_17 pv pid4" id="p4" name="sigil_toc_id_17">
                    4.1　了解v-bind指令</h3>
                <p class="calibre4 pv pid5" id="p5">
                    在第2章时，我们已经介绍了指令v-bind的基本用法以及它的语法糖，它的主要用法是动态更新HTML元素上的属性，回顾一下下面的示例：</p>
                <pre class="calibre7 pv pid6" id="p6">&lt;div id="app"&gt;
    &lt;a v-bind:href="url"&gt;链接&lt;/a&gt;
    &lt;img v-bind:src="imgUrl"&gt;
    &lt;!-- 缩写为--&gt;
    &lt;a :href="url"&gt;链接&lt;/a&gt;
    &lt;img :src="imgUrl"&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            url: 'https://www.github.com',
            imgUrl: 'http://xxx.xxx.xx/img.png'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid7" id="p7">链接的href属性和图片的src属性都被动态设置了，当数据变化时，就会重新渲染。</p>
                <p class="calibre4 pv pid8" id="p8">
                    在数据绑定中，最常见的两个需求就是元素的样式名称class和内联样式style的动态绑定，它们也是HTML的属性，因此可以使用v-bind指令。我们只需要用v-bind计算出表达式最终的字符串就可以，不过有时候表达式的逻辑较复杂，使用字符串拼接方法较难阅读和维护，所以Vue.js增强了对class和style的绑定。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_18 pv pid9" id="p9" name="sigil_toc_id_18">
                    4.2　绑定class的几种方式</h3><h4 class="kindle-cn-heading3 sigil_toc_id_19 pv pid10" id="p10"
                                             name="sigil_toc_id_19">4.2.1　对象语法</h4>
                <p class="calibre4 pv pid11" id="p11">给v-bind:class设置一个对象，可以动态地切换class，例如：</p>
                <pre class="calibre7 pv pid12" id="p12">&lt;div id="app"&gt;
    &lt;div :class="{ 'active': isActive }"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true
        }
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid13" id="p13">提示</p>
                <p class="kindle-cn-para-no-indent pv pid14" id="p14" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">上面的:class等同于v-bind:class，是一个语法糖，如不特殊说明，后面都将使用语法糖写法，可以回顾第2.3节。</span>
                </p>
                <p class="calibre4 pv pid14" id="p14">
                    上面示例中，类名active依赖于数据isActive，当其为true时，div会拥有类名Active，为false时则没有，所以上例最终渲染完的结果是：</p>
                <pre class="calibre7 pv pid15" id="p15">&lt;div class="active"&gt;&lt;/div&gt;</pre>
                <p class="calibre4 pv pid16" id="p16">对象中也可以传入多个属性，来动态切换class。另外，:class可以与普通class共存，例如：</p>
                <pre class="calibre7 pv pid17" id="p17">&lt;div id="app"&gt;
    &lt;div class="static" :class="{ 'active': isActive, 'error': isError }"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true,
            isError: false
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid18" id="p18">:class内的表达式每项为真时，对应的类名就会加载，上面渲染后的结果为：</p>
                <pre class="calibre7 pv pid19" id="p19">&lt;div class="static active"&gt;&lt;/div&gt;</pre>
                <p class="calibre4 pv pid20" id="p20">
                    当数据isActive或isError变化时，对应的class类名也会更新。比如当isError为true时，渲染后的结果为：</p>
                <pre class="calibre7 pv pid21" id="p21">&lt;div class="static active error"&gt;&lt;/div&gt;</pre>
                <p class="calibre4 pv pid22" id="p22">
                    当:class的表达式过长或逻辑复杂时，还可以绑定一个计算属性，这是一种很友好和常见的用法，一般当条件多于两个时，都可以使用data或computed，例如使用计算属性：</p>
                <pre class="calibre7 pv pid23" id="p23">&lt;div id="app"&gt;
    &lt;div :class="classes"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true,
            error: null
        },
        computed: {
            classes: function () {
                return {
                    active: this.isActive &amp;&amp; !this.error,
                    'text-fail': this.error &amp;&amp; this.error.type === 'fail'
                }
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid24" id="p24">除了计算属性，你也可以直接绑定一个Object类型的数据，或者使用类似计算属性的methods。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_20 pv pid25" id="p25" name="sigil_toc_id_20">
                    4.2.2　数组语法</h4>
                <p class="calibre4 pv pid26" id="p26">当需要应用多个class时，可以使用数组语法，给:class绑定一个数组，应用一个class列表：</p>
                <pre class="calibre7 pv pid27" id="p27">&lt;div id="app"&gt;
    &lt;div :class="[activeCls, errorCls]"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            activeCls: 'active',
            errorCls: 'error'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid28" id="p28">渲染后的结果为：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div class="active error"&gt;&lt;/div&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">也可以使用三元表达式来根据条件切换class，例如下面的示例：</p>
                <pre class="calibre7 pv pid31" id="p31">&lt;div id="app"&gt;
    &lt;div :class="[isActive ? activeCls : '', errorCls]"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true,
            activeCls: 'active',
            errorCls: 'error'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid32" id="p32">
                    样式error会始终应用，当数据isActive为真时，样式active才会被应用。class有多个条件时，这样写较为烦琐，可以在数组语法中使用对象语法：</p>
                <pre class="calibre7 pv pid33" id="p33">&lt;div id="app"&gt;
    &lt;div :class="[{ 'active': isActive }, errorCls]"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true,
            errorCls: 'error'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid34" id="p34">当然，与对象语法一样，也可以使用data、computed和methods三种方法，以计算属性为例：</p>
                <pre class="calibre7 pv pid35" id="p35">&lt;div id="app"&gt;
    &lt;button :class="classes"&gt;&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            size: 'large',
            disabled: true
        },
        computed: {
            classes: function () {
                return [
                    'btn',
                    {
                        ['btn-' + this.size]: this.size !== '',
                        ['btn-disabled']: this.disabled
                    }
                ];
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid36" id="p36">
                    示例中的样式btn会始终应用，当数据size不为空时，会应用样式前缀btn-，后加size的值；当数据disabled为真时，会应用样式btn-disabled，所以该示例最终渲染的结果为：</p>
                <pre class="calibre7 pv pid37"
                     id="p37">&lt;button class="btn btn-large btn-disabled"&gt;&lt;/button&gt;</pre>
                <p class="calibre4 pv pid38" id="p38">
                    使用计算属性给元素动态设置类名，在业务中经常用到，尤其是在写复用的组件时，所以在开发过程中，如果表达式较长或逻辑复杂，应该尽可能地优先使用计算属性。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_21 pv pid39" id="p39" name="sigil_toc_id_21">
                    4.2.3　在组件上使用</h4>
                <p class="kindle-cn-para-left pv pid40" id="p40">提示</p>
                <p class="kindle-cn-para-no-indent pv pid41" id="p41" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本节内容依赖第7章组件相关的内容，如果你尚未了解过Vue.js的组件，可以先跳过这节，稍后再阅读。</span></p>
                <p class="calibre4 pv pid41" id="p41">如果直接在自定义组件上使用class或:class，样式规则会直接应用到这个组件的根元素上，例如声明一个简单的组件：</p>
                <pre class="calibre7 pv pid42" id="p42">Vue.component('my-component', {
    template: '&lt;p class="article"&gt;一些文本&lt;/p&gt;'
});</pre>
                <p class="calibre4 pv pid43" id="p43">然后在调用这个组件时，应用上面两节介绍的对象语法或数组语法给组件绑定class，以对象语法为例：</p>
                <pre class="calibre7 pv pid44" id="p44">&lt;div id="app"&gt;
    &lt;my-component :class="{ 'active': isActive }"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            isActive: true
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid45" id="p45">最终组件渲染后的结果为：</p>
                <pre class="calibre7 pv pid46" id="p46">&lt;p class="article active"&gt;一些文本&lt;/p&gt;</pre>
                <p class="calibre4 pv pid47" id="p47">
                    这种用法仅适用于自定义组件的最外层是一个根元素，否则会无效，当不满足这种条件或需要给具体的子元素设置类名时，应当使用组件的props来传递。这些用法同样适用于下一节中绑定内联样式
                    style的内容。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_22 pv pid48" id="p48" name="sigil_toc_id_22">4.3　绑定内联样式</h3>
                <p class="calibre4 pv pid49" id="p49">
                    使用v-bind:style（即:style）可以给元素绑定内联样式，方法与:class类似，也有对象语法和数组语法，看起来很像直接在元素上写CSS：</p>
                <pre class="calibre7 pv pid50" id="p50">&lt;div id="app"&gt;
    &lt;div :style="{ 'color': color, 'fontSize': fontSize + 'px' }"&gt;文本&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            color: 'red',
            fontSize: 14
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid51" id="p51">CSS属性名称使用驼峰命名（camelCase）或短横分隔命名（kebab-case），渲染后的结果为：</p>
                <pre class="calibre7 pv pid52"
                     id="p52">&lt;div style="color: red; font-size: 14px;"&gt;文本&lt;/div&gt;</pre>
                <p class="calibre4 pv pid53" id="p53">大多数情况下，直接写一长串的样式不便于阅读和维护，所以一般写在data或computed里，以data为例改写上面的示例：</p>
                <pre class="calibre7 pv pid54" id="p54">&lt;div id="app"&gt;
    &lt;div :style="styles"&gt;文本&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            styles: {
                color: 'red',
                fontSize: 14 + 'px'
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid55" id="p55">应用多个样式对象时，可以使用数组语法：</p>
                <pre class="calibre7 pv pid56" id="p56">&lt;div :style="[styleA, styleB]"&gt;文本&lt;/div&gt;</pre>
                <p class="calibre4 pv pid57" id="p57">在实际业务中，:style的数组语法并不常用，因为往往可以写在一个对象里面；而较为常用的应当是计算属性。</p>
                <p class="calibre4 pv pid58" id="p58">另外，使用:style时，Vue.js会自动给特殊的CSS属性名称增加前缀，比如transform。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="33" data-chapter-url="24047091" alt="64157287">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第5章　内置指令</h2>
                <p class="calibre4 pv pid3" id="p3">
                    回顾一下第2.2节，我们已经介绍过指令（Directive）的概念了，Vue.js的指令是带有特殊前缀“v-”的HTML特性，它绑定一个表达式，并将一些特性应用到DOM上。其实我们已经用到过很多Vue内置的指令，比如v-html、v-pre，还有上一章的v-bind。本章将继续介绍Vue.js中更多常用的内置指令。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_23 pv pid4" id="p4" name="sigil_toc_id_23">5.1　基本指令</h3><h4
                        class="kindle-cn-heading3 sigil_toc_id_24 pv pid5" id="p5" name="sigil_toc_id_24">
                    5.1.1　v-cloak</h4>
                <p class="calibre4 pv pid6" id="p6">v-cloak不需要表达式，它会在Vue实例结束编译时从绑定的HTML元素上移除，经常和CSS的display:
                    none;配合使用：</p>
                <pre class="calibre7 pv pid7" id="p7">&lt;div id="app" v-cloak&gt;
    {{ message }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: '这是一段文本'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid8" id="p8">这时虽然已经加了指令v-cloak，但其实并没有起到任何作用，当网速较慢、Vue.js文件还没加载完时，在页面上会显示{{
                    message }}的字样，直到Vue创建实例、编译模板时，DOM才会被替换，所以这个过程屏幕是有闪动的。只要加一句CSS就可以解决这个问题了：</p>
                <pre class="calibre7 pv pid9" id="p9">[v-cloak] {
    display: none;
}</pre>
                <p class="calibre4 pv pid10" id="p10">
                    在一般情况下，v-cloak是一个解决初始化慢导致页面闪动的最佳实践，对于简单的项目很实用，但是在具有工程化的项目里，比如后面进阶篇将介绍webpack和vue-router时，项目的HTML结构只有一个空的div元素，剩余的内容都是由路由去挂载不同组件完成的，所以不再需要v-cloak。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_25 pv pid11" id="p11" name="sigil_toc_id_25">
                    5.1.2　v-once</h4>
                <p class="calibre4 pv pid12" id="p12">
                    v-once也是一个不需要表达式的指令，作用是定义它的元素或组件只渲染一次，包括元素或组件的所有子节点。首次渲染后，不再随数据的变化重新渲染，将被视为静态内容，例如：</p>
                <pre class="calibre7 pv pid13" id="p13">&lt;div id="app"&gt;
    &lt;span v-once&gt;{{ message }}&lt;/div&gt;
    &lt;div v-once&gt;
        &lt;span&gt;{{ message }}&lt;/span&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: '这是一段文本'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid14" id="p14">v-once在业务中也很少使用，当你需要进一步优化性能时，可能会用到。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_26 pv pid15" id="p15" name="sigil_toc_id_26">5.2　条件渲染指令</h3>
                <h4 class="kindle-cn-heading3 sigil_toc_id_27 pv pid16" id="p16" name="sigil_toc_id_27">
                    5.2.1　v-if、v-else-if、v-else</h4>
                <p class="calibre4 pv pid17" id="p17">与JavaScript的条件语句if、else、else
                    if类似，Vue.js的条件指令可以根据表达式的值在DOM中渲染或销毁元素/组件，例如：</p>
                <pre class="calibre7 pv pid18" id="p18">&lt;div id="app"&gt;
    &lt;p v-if="status === 1"&gt;当status为1时显示该行&lt;/p&gt;
    &lt;p v-else-if="status === 2"&gt;当status为2时显示该行&lt;/p&gt;
    &lt;p v-else&gt;否则显示该行&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            status: 1
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid19" id="p19">
                    v-else-if要紧跟v-if，v-else要紧跟v-else-if或v-if，表达式的值为真时，当前元素/组件及所有子节点将被渲染，为假时被移除。如果一次判断的是多个元素，可以在Vue.js内置的&lt;template&gt;元素上使用条件指令，最终渲染的结果不会包含该元素，例如：</p>
                <pre class="calibre7 pv pid20" id="p20">&lt;div id="app"&gt;
    &lt;template v-if="status === 1"&gt;
        &lt;p&gt;这是一段文本&lt;/p&gt;
        &lt;p&gt;这是一段文本&lt;/p&gt;
        &lt;p&gt;这是一段文本&lt;/p&gt;
    &lt;/template&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            status: 1
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid21" id="p21">Vue在渲染元素时，出于效率考虑，会尽可能地复用已有的元素而非重新渲染，比如下面的示例：</p>
                <pre class="calibre7 pv pid22" id="p22">&lt;div id="app"&gt;
    &lt;template v-if="type === 'name'"&gt;
        &lt;label&gt;用户名：&lt;/label&gt;
        &lt;input placeholder="输入用户名"&gt;
    &lt;/template&gt;
    &lt;template v-else&gt;
        &lt;label&gt;邮箱：&lt;/label&gt;
        &lt;input placeholder="输入邮箱"&gt;
    &lt;/template&gt;
    &lt;button @click="handleToggleClick"&gt;切换输入类型&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            type: 'name'
        },
        methods: {
            handleToggleClick: function() {
                this.type = this.type === 'name' ? 'mail' : 'name';
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid23" id="p23">
                    如图5-1和图5-2所示，键入内容后，点击切换按钮，虽然DOM变了，但是之前在输入框键入的内容并没有改变，只是替换了placeholder的内容，说明&lt;input&gt;元素被复用了。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid24" id="p24" style="margin: 0px;"><img alt="049"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/fca3fdfb4d42ea8a.jpg"
                                                                                                         href="./image/00005.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-1　切换前的状态</p></div>
                <div class="kindle-cn-bodycontent-div-alone pv pid24" id="p24" style="margin: 0px;"><img alt="049-2"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/3cde755a928b1e7d.jpg"
                                                                                                         href="./image/00006.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-2　切换后的状态</p></div>
                <p class="calibre4 pv pid24" id="p24">如果你不希望这样做，可以使用Vue.js提供的key属性，它可以让你自己决定是否要复用元素，key的值必须是唯一的，例如：</p>
                <pre class="calibre7 pv pid25" id="p25">&lt;div id="app"&gt;
    &lt;template v-if="type === 'name'"&gt;
        &lt;label&gt;用户名：&lt;/label&gt;
        &lt;input placeholder="输入用户名" key="name-input"&gt;
    &lt;/template&gt;
    &lt;template v-else&gt;
        &lt;label&gt;邮箱：&lt;/label&gt;
        &lt;input placeholder="输入邮箱" key="mail-input"&gt;
    &lt;/template&gt;
    &lt;button @click="handleToggleClick"&gt;切换输入类型&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            type: 'name'
        },
        methods: {
            handleToggleClick: function() {
                this.type = this.type === 'name' ? 'mail' : 'name';
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid26" id="p26">给两个&lt;input&gt;元素都增加key后，就不会复用了，切换类型时键入的内容也会被删除，不过&lt;label&gt;元素仍然是被复用的，因为没有添加key属性。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_28 pv pid27" id="p27" name="sigil_toc_id_28">
                    5.2.2　v-show</h4>
                <p class="calibre4 pv pid28" id="p28">
                    v-show的用法与v-if基本一致，只不过v-show是改变元素的CSS属性display。当v-show表达式的值为false时，元素会隐藏，查看DOM结构会看到元素上加载了内联样式
                    display: none;，例如：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div id="app"&gt;
    &lt;p v-show="status === 1"&gt;当status为1时显示该行&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            status: 2
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">渲染后的结果为：</p>
                <pre class="calibre7 pv pid31" id="p31">&lt;p style="display: none;"&gt;当status为1时显示该行&lt;/p&gt;</pre>
                <p class="kindle-cn-para-left pv pid32" id="p32">提示</p>
                <p class="kindle-cn-para-no-indent pv pid33" id="p33" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">v-show不能在&lt;template&gt;上使用。</span></p><h4
                        class="kindle-cn-heading3 sigil_toc_id_29 pv pid33" id="p33" name="sigil_toc_id_29">
                    5.2.3　v-if与v-show的选择</h4>
                <p class="calibre4 pv pid34" id="p34">
                    v-if和v-show具有类似的功能，不过v-if才是真正的条件渲染，它会根据表达式适当地销毁或重建元素及绑定的事件或子组件。若表达式初始值为false，则一开始元素/组件并不会渲染，只有当条件第一次变为真时才开始编译。</p>
                <p class="calibre4 pv pid35" id="p35">
                    而v-show只是简单的CSS属性切换，无论条件真与否，都会被编译。相比之下，v-if更适合条件不经常改变的场景，因为它切换开销相对较大，而v-show适用于频繁切换条件。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_30 pv pid36" id="p36" name="sigil_toc_id_30">
                    5.3　列表渲染指令v-for</h3><h4 class="kindle-cn-heading3 sigil_toc_id_31 pv pid37" id="p37"
                                            name="sigil_toc_id_31">5.3.1　基本用法</h4>
                <p class="calibre4 pv pid38" id="p38">当需要将一个数组遍历或枚举一个对象循环显示时，就会用到列表渲染指令v-for。它的表达式需结合in来使用，类似item in
                    items的形式，看下面的示例：</p>
                <pre class="calibre7 pv pid39" id="p39">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;li v-for="book in books"&gt;{{ book.name }}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            books: [
                { name: '《Vue.js实战》' },
                { name: '《JavaScript语言精粹》' },
                { name: '《JavaScript高级程序设计》' }
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid40" id="p40">我们定义一个数组类型的数据books，用v-for将&lt;li&gt;标签循环渲染，效果如图5-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid41" id="p41" style="margin: 0px;"><img alt="051"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/8e68bdaf68832129.jpg"
                                                                                                         href="./image/00007.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-3　列表循环结果</p></div>
                <p class="calibre4 pv pid41" id="p41">在表达式中，books是数据，book是当前数组元素的别名，循环出的每个&lt;li&gt;内的元素都可以访问到对应的当前数据book。列表渲染也支持用of来代替in作为分隔符，它更接近JavaScript迭代器的语法：</p>
                <pre class="calibre7 pv pid42" id="p42">&lt;li v-for="book of books"&gt;{{ book.name }}&lt;/li&gt;</pre>
                <p class="calibre4 pv pid43" id="p43">v-for的表达式支持一个可选参数作为当前项的索引，例如：</p>
                <pre class="calibre7 pv pid44" id="p44">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;li v-for="(book, index) in books"&gt;{{ index }} - {{ book.name }}&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            books: [
                { name: '《Vue.js实战》' },
                { name: '《JavaScript语言精粹》' },
                { name: '《JavaScript高级程序设计》' }
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid45" id="p45">分隔符in前的语句使用括号，第二项就是books当前项的索引，渲染后的结果如图5-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid46" id="p46" style="margin: 0px;"><img alt="052"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/f0e74545613d731e.jpg"
                                                                                                         href="./image/00008.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-4　含有index选项的列表渲染结果</p></div>
                <p class="kindle-cn-para-left pv pid46" id="p46">提示</p>
                <p class="kindle-cn-para-no-indent pv pid47" id="p47" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果你使用过Vue.js 1.x的版本，这里的index也可以由内置的$index代替，不过在2.x里取消了该用法。</span>
                </p>
                <p class="calibre4 pv pid47" id="p47">与v-if一样，v-for也可以用在内置标签&lt;template&gt;上，将多个元素进行渲染：</p>
                <pre class="calibre7 pv pid48" id="p48">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;template v-for="book in books"&gt;
            &lt;li&gt;书名：{{ book.name }}&lt;/li&gt;
            &lt;li&gt;作者：{{ book.author }}&lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            books: [
                {
                    name: '《Vue.js实战》',
                    author: '梁灏'
                },
                {
                    name: '《JavaScript语言精粹》',
                    author: 'Douglas Crockford'
                },
                {
                    name: '《JavaScript高级程序设计》',
                    author: 'Nicholas C.Zakas'
                }
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid49" id="p49">除了数组外，对象的属性也是可以遍历的，例如：</p>
                <pre class="calibre7 pv pid50" id="p50">&lt;div id="app"&gt;
    &lt;span v-for="value in user"&gt;{{ value }} &lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            user: {
                name: 'Aresn',
                gender: '男',
                age: 26
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid51" id="p51">渲染后的结果为：</p>
                <pre class="calibre7 pv pid52" id="p52">&lt;span&gt;Aresn &lt;/span&gt;&lt;span&gt;男 &lt;/span&gt;&lt;span&gt;26 &lt;/span&gt;</pre>
                <p class="calibre4 pv pid53" id="p53">遍历对象属性时，有两个可选参数，分别是键名和索引：</p>
                <pre class="calibre7 pv pid54" id="p54">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;li v-for="(value, key, index) in user"&gt;
            {{ index }} - {{ key }}: {{ value }}
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            user: {
                name: 'Aresn',
                gender: '男',
                age: 26
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid55" id="p55">渲染后的结果如图5-5所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid56" id="p56" style="margin: 0px;"><img alt="054"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/80370a2a57cc338a.jpg"
                                                                                                         href="./image/00009.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-5　遍历对象的渲染结果</p></div>
                <p class="calibre4 pv pid56" id="p56">v-for还可以迭代整数：</p>
                <pre class="calibre7 pv pid57" id="p57">&lt;div id="app"&gt;
    &lt;span v-for="n in 10"&gt;{{ n }} &lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid58" id="p58">渲染后的结果为：</p>
                <pre class="calibre7 pv pid59" id="p59">1 2 3 4 5 6 7 8 9 10</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_32 pv pid60" id="p60" name="sigil_toc_id_32">5.3.2　数组更新</h4>
                <p class="calibre4 pv pid61" id="p61">
                    Vue的核心是数据与视图的双向绑定，当我们修改数组时，Vue会检测到数据变化，所以用v-for渲染的视图也会立即更新。Vue包含了一组观察数组变异的方法，使用它们改变数组也会触发视图更新：</p>
                <ul class="kindle-cn-ul-disc pv pid62" id="p62" style="margin: 0px;">
                    <li class="calibre6">push()</li>
                    <li class="calibre6">pop()</li>
                    <li class="calibre6">shift()</li>
                    <li class="calibre6">unshift()</li>
                    <li class="calibre6">splice()</li>
                    <li class="calibre6">sort()</li>
                    <li class="calibre6">reverse()</li>
                </ul>
                <p class="calibre4 pv pid62" id="p62">例如，我们将之前一个示例的数据books添加一项：</p>
                <pre class="calibre7 pv pid63" id="p63">app.books.push({
    name: '《CSS揭秘》',
    author: '[希] Lea Verou'
});</pre>
                <p class="calibre4 pv pid64" id="p64">可以尝试编写完整示例来查看效果。</p>
                <p class="calibre4 pv pid65" id="p65">使用以上方法会改变被这些方法调用的原始数组，有些方法不会改变原数组，例如：</p>
                <ul class="kindle-cn-ul-disc pv pid66" id="p66" style="margin: 0px;">
                    <li class="calibre6">filter()</li>
                    <li class="calibre6">concat()</li>
                    <li class="calibre6">slice()</li>
                </ul>
                <p class="calibre4 pv pid66" id="p66">
                    它们返回的是一个新数组，在使用这些非变异方法时，可以用新数组来替换原数组，还是之前展示书目的示例，我们找出含有JavaScript关键词的书目，例如：</p>
                <pre class="calibre7 pv pid67" id="p67">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;template v-for="book in books"&gt;
            &lt;li&gt;书名：{{ book.name }}&lt;/li&gt;
            &lt;li&gt;作者：{{ book.author }}&lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            books: [
                {
                    name: '《Vue.js实战》',
                    author: '梁灏'
                },
                {
                    name: '《JavaScript语言精粹》',
                    author: 'Douglas Crockford'
                },
                {
                    name: '《JavaScript高级程序设计》',
                    author: 'Nicholas C.Zakas'
                }
            ]
        }
    });

    app.books = app.books.filter(function (item) {
        return item.name.match(/JavaScript/);
    });
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid68" id="p68">渲染的结果中，第一项《Vue.js实战》被过滤掉了，只显示了书名中含有JavaScript的选项。</p>
                <p class="calibre4 pv pid69" id="p69">
                    Vue在检测到数组变化时，并不是直接重新渲染整个列表，而是最大化地复用DOM元素。替换的数组中，含有相同元素的项不会被重新渲染，因此可以大胆地用新数组来替换旧数组，不用担心性能问题。</p>
                <p class="calibre4 pv pid70" id="p70">需要注意的是，以下变动的数组中，Vue是不能检测到的，也不会触发视图更新：</p>
                <ul class="kindle-cn-ul-disc pv pid71" id="p71" style="margin: 0px;">
                    <li class="calibre6"><span
                            class="kindle-cn-specialtext-kaiti">通过索引直接设置项，比如app.books[3] = {…}。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">修改数组长度，比如app.books.length = 1。</span>
                    </li>
                </ul>
                <p class="calibre4 pv pid71" id="p71">解决第一个问题可以用两种方法实现同样的效果，第一种是使用Vue内置的set方法：</p>
                <pre class="calibre7 pv pid72" id="p72">Vue.set(app.books, 3, {
    name: '《CSS揭秘》',
    author: '[希] Lea Verou'
});</pre>
                <p class="calibre4 pv pid73" id="p73">如果是在webpack中使用组件化的方式（进阶篇中将介绍），默认是没有导入Vue的，这时可以使用$set，例如：</p>
                <pre class="calibre7 pv pid74" id="p74">this.$set(app.books, 3, {
    name: '《CSS揭秘》',
    author: '[希] Lea Verou'
})
// 这里的this指向的就是当前组件实例，即app。在非webpack模式下也可以用$set方法，例如app.$set(…)</pre>
                <p class="calibre4 pv pid75" id="p75">另一种方法：</p>
                <pre class="calibre7 pv pid76" id="p76">app.books.splice(3, 1, {
    name: '《CSS揭秘》',
    author: '[希] Lea Verou'
})</pre>
                <p class="calibre4 pv pid77" id="p77">第二个问题也可以直接用splice来解决：</p>
                <pre class="calibre7 pv pid78" id="p78">app.books.splice(1);</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_33 pv pid79" id="p79" name="sigil_toc_id_33">5.3.3　过滤与排序</h4>
                <p class="calibre4 pv pid80" id="p80">当你不想改变原数组，想通过一个数组的副本来做过滤或排序的显示时，可以使用计算属性来返回过滤或排序后的数组，例如：</p>
                <pre class="calibre7 pv pid81" id="p81">&lt;div id="app"&gt;
    &lt;ul&gt;
        &lt;template v-for="book in filterBooks"&gt;
            &lt;li&gt;书名：{{ book.name }}&lt;/li&gt;
            &lt;li&gt;作者：{{ book.author }}&lt;/li&gt;
        &lt;/template&gt;
    &lt;/ul&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            books: [
                {
                    name: '《Vue.js实战》',
                    author: '梁灏'
                },
                {
                    name: '《JavaScript语言精粹》',
                    author: 'Douglas Crockford'
                },
                {
                    name: '《JavaScript高级程序设计》',
                    author: 'Nicholas C.Zakas'
                }
            ]
        },
        computed: {
            filterBooks: function () {
                return this.books.filter(function (book) {
                    return book.name.match(/JavaScript/);
                });
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid82" id="p82">
                    上例是把书名中包含JavaScript关键词的数据过滤出来，计算属性filterBooks依赖books，但是不会修改books。实现排序也是类似的，比如在此基础上新加一个计算属性sortedBooks，按照书名的长度由长到短进行排序：</p>
                <pre class="calibre7 pv pid83" id="p83">computed: {
    sortedBooks: function () {
        return this.books.sort(function (a, b) {
            return a.name.length &lt; b.name.length;
        });
    }
}</pre>
                <p class="kindle-cn-para-left pv pid84" id="p84">提示</p>
                <p class="kindle-cn-para-no-indent pv pid85" id="p85" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">在Vue.js 2.x中废弃了1.x中内置的limitBy、filterBy和orderBy 过滤器，统一改用计算属性来实现。</span>
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_34 pv pid85" id="p85" name="sigil_toc_id_34">5.4　方法与事件</h3>
                <h4 class="kindle-cn-heading3 sigil_toc_id_35 pv pid86" id="p86" name="sigil_toc_id_35">5.4.1　基本用法</h4>
                <p class="calibre4 pv pid87" id="p87">
                    在第2.2节，我们已经引入了Vue事件处理的概念v-on，在事件绑定上，类似原生JavaScript的onclick等写法，也是在HTML上进行监听的。例如，我们监听一个按钮的点击事件，设置一个计数器，每次点击都加1：</p>
                <pre class="calibre7 pv pid88" id="p88">&lt;div id="app"&gt;
    点击次数：{{ counter }}
    &lt;button @click="counter++"&gt;+ 1&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data: {
            counter: 0
        }
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid89" id="p89">提示</p>
                <p class="kindle-cn-para-no-indent pv pid90" id="p90" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">上面的@click等同于v-on:click，是一个语法糖，如不特殊说明，后面都将使用语法糖写法，可以回顾第2.3节。</span>
                </p>
                <p class="calibre4 pv pid90" id="p90">
                    @click的表达式可以直接使用JavaScript语句，也可以是一个在Vue实例中methods选项内的函数名，比如对上例进行扩展，再增加一个按钮，点击一次，计数器加10：</p>
                <pre class="calibre7 pv pid91" id="p91">&lt;div id="app"&gt;
    点击次数：{{ counter }}
    &lt;button @click="handleAdd()"&gt;+ 1&lt;/button&gt;
    &lt;button @click="handleAdd(10)"&gt;+ 10&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            counter: 0
        },
        methods: {
            handleAdd: function (count) {
                count = count || 1;
                // this指向当前 Vue实例app
                this.counter += count;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid92" id="p92">
                    在methods中定义了我们需要的方法供@click调用，需要注意的是，@click调用的方法名后可以不跟括号“()”。此时，如果该方法有参数，默认会将原生事件对象event传入，可以尝试修改为@click="handleAdd"，然后在handleAdd内打印出count参数看看。在大部分业务场景中，如果方法不需要传入参数，为了简便可以不写括号。</p>
                <p class="calibre4 pv pid93" id="p93">
                    这种在HTML元素上监听事件的设计看似将DOM与JavaScript紧耦合，违背分离的原理，实则刚好相反。因为通过HTML就可以知道调用的是哪个方法，将逻辑与DOM解耦，便于维护。最重要的是，当ViewModel销毁时，所有的事件处理器都会自动删除，无须自己清理。</p>
                <p class="calibre4 pv pid94" id="p94">Vue提供了一个特殊变量$event，用于访问原生DOM事件，例如下面的实例可以阻止链接打开：</p>
                <pre class="calibre7 pv pid95" id="p95">&lt;div id="app"&gt;
    &lt;a href="http://www.apple.com" @click="handleClick('禁止打开', $event)"&gt;打开链接&lt;/a&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        methods: {
            handleClick: function (message, event) {
                event.preventDefault();
                window.alert(message);
            }
        }
    })
&lt;/script&gt;</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_36 pv pid96" id="p96" name="sigil_toc_id_36">5.4.2　修饰符</h4>
                <p class="calibre4 pv pid97" id="p97">
                    在上例使用的event.preventDefault()也可以用Vue事件的修饰符来实现，在@绑定的事件后加小圆点“.”，再跟一个后缀来使用修饰符。Vue支持以下修饰符：</p>
                <ul class="kindle-cn-ul-disc pv pid98" id="p98" style="margin: 0px;">
                    <li class="calibre6">.stop</li>
                    <li class="calibre6">.prevent</li>
                    <li class="calibre6">.capture</li>
                    <li class="calibre6">.self</li>
                    <li class="calibre6">.once</li>
                </ul>
                <p class="calibre4 pv pid98" id="p98">具体用法如下：</p>
                <pre class="calibre7 pv pid99" id="p99">&lt;!-- 阻止单击事件冒泡 --&gt;
&lt;a @click.stop="handle"&gt;&lt;/a&gt;
&lt;!-- 提交事件不再重载页面 --&gt;
&lt;form @submit.prevent="handle"&gt;&lt;/form&gt;
&lt;!--修饰符可以串联  --&gt;
&lt;a @click.stop.prevent="handle"&gt;&lt;/a&gt;
&lt;!-- 只有修饰符 --&gt;
&lt;form @submit.prevent&gt;&lt;/form&gt;
&lt;!--添加事件侦听器时使用事件捕获模式 --&gt;
&lt;div @click.capture="handle"&gt;...&lt;/div&gt;
&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;
&lt;div @click.self="handle"&gt;...&lt;/div&gt;
&lt;!-- 只触发一次，组件同样适用--&gt;
&lt;div @click.once="handle"&gt;...&lt;/div&gt;</pre>
                <p class="calibre4 pv pid100" id="p100">在表单元素上监听键盘事件时，还可以使用按键修饰符，比如按下具体某个键时才调用方法：</p>
                <pre class="calibre7 pv pid101" id="p101">&lt;!-- 只有在keyCode是13时调用vm.submit() --&gt;
&lt;input @keyup.13=“submit”&gt;</pre>
                <p class="calibre4 pv pid102" id="p102">也可以自己配置具体按键：</p>
                <pre class="calibre7 pv pid103" id="p103">Vue.config.keyCodes.f1 = 112;
// 全局定义后，就可以使用@keyup.f1</pre>
                <p class="calibre4 pv pid104" id="p104">除了具体的某个keyCode外，Vue还提供了一些快捷名称，以下是全部的别名：</p>
                <ul class="kindle-cn-ul-disc pv pid105" id="p105" style="margin: 0px;">
                    <li class="calibre6">.enter</li>
                    <li class="calibre6">.tab</li>
                    <li class="calibre6">.delete<span class="kindle-cn-specialtext-kaiti">（捕获“删除”和“退格”键）</span></li>
                    <li class="calibre6">.esc</li>
                    <li class="calibre6">.space</li>
                    <li class="calibre6">.up</li>
                    <li class="calibre6">.down</li>
                    <li class="calibre6">.left</li>
                    <li class="calibre6">.right</li>
                </ul>
                <p class="calibre4 pv pid105" id="p105">这些按键修饰符也可以组合使用，或和鼠标一起配合使用：</p>
                <ul class="kindle-cn-ul-disc pv pid106" id="p106" style="margin: 0px;">
                    <li class="calibre6">.ctrl</li>
                    <li class="calibre6">.alt</li>
                    <li class="calibre6">.shift</li>
                    <li class="calibre6">.meta<span
                            class="kindle-cn-specialtext-kaiti">（Mac下是Command键，Windows下是窗口键）</span></li>
                </ul>
                <p class="calibre4 pv pid106" id="p106">例如：</p>
                <pre class="calibre7 pv pid107" id="p107">&lt;!-- Shift + S --&gt;
&lt;input @keyup.shift.83="handleSave"&gt;
&lt;!-- Ctrl + Click --&gt;
&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt;</pre>
                <p class="calibre4 pv pid108" id="p108">以上就是事件指令v-on的基本内容，在第7章的组件中，我们还将介绍用v-on来绑定自定义事件。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_37 pv pid109" id="p109" name="sigil_toc_id_37">
                    5.5　实战：利用计算属性、指令等知识开发购物车</h3>
                <p class="calibre4 pv pid110" id="p110">
                    前5章内容基本涵盖了Vue.js最核心和常用的知识点，掌握这些内容已经可以上手开发一些小功能了。本节则以Vue.js的计算属性、内置指令、方法等内容为基础，完成一个在业务中具有代表性的小功能：购物车。</p>
                <p class="calibre4 pv pid111" id="p111">在开始写代码前，要对需求进行分析，这样有助于我们理清业务逻辑，尽可能还原设计与产品交互。</p>
                <p class="calibre4 pv pid112" id="p112">
                    购物车需要展示一个已加入购物车的商品列表，包含商品名称、商品单价、购买数量和操作等信息，还需要实时显示购买的总价。其中购买数量可以增加或减少，每类商品还可以从购物车中移除。最终实现的效果如图5-6所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid113" id="p113" style="margin: 0px;"><img alt="062"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/1b0cb72df0a1845c.jpg"
                                                                                                           href="./image/00010.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图5-6　购物车效果图</p></div>
                <p class="calibre4 pv pid113" id="p113">
                    在明确需求后，我们就可以开始编程了，因为业务代码较多，这次我们将HTML、CSS、JavaScript分离为3个文件，便于阅读和维护：</p>
                <ul class="kindle-cn-ul-disc pv pid114" id="p114" style="margin: 0px;">
                    <li class="calibre6">index.html<span class="kindle-cn-specialtext-kaiti">（引入资源及模板）</span></li>
                    <li class="calibre6">index.js<span class="kindle-cn-specialtext-kaiti">（Vue实例及业务代码）</span></li>
                    <li class="calibre6">style.css<span class="kindle-cn-specialtext-kaiti">（样式）</span></li>
                </ul>
                <p class="calibre4 pv pid114" id="p114">先在index.html中引入Vue.js和相关资源，创建一个根元素来挂载 Vue实例：</p>
                <pre class="calibre7 pv pid115" id="p115">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;购物车示例&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;

    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid116" id="p116">注意，这里将vue.min.js和index.js文件写在&lt;body&gt;的最底部，如果写在&lt;head&gt;里，Vue实例将无法创建，因为此时DOM还没有被解析完成，除非通过异步或在事件DOMContentLoaded（IE是onreadystatechange）触发时再创建Vue实例，这有点像jQuery的$(document).ready()方法。</p>
                <p class="calibre4 pv pid117" id="p117">本例需要用到Vue.js的computed、methods等选项，在index.js中先初始化实例：</p>
                <pre class="calibre7 pv pid118" id="p118">var app = new Vue({
    el: '#app',
    data: {

    },
    computed: {

    },
    methods: {

    }
});</pre>
                <p class="calibre4 pv pid119" id="p119">
                    我们需要的数据比较简单，只有一个列表，里面包含了商品名称、单价、购买数量。在实际业务中，这个列表应该是通过Ajax从服务端动态获取的，这里只做示例，所以直接写入在data选项内，另外每个商品还应该有一个全局唯一的id。我们在data内写入列表list：</p>
                <pre class="calibre7 pv pid120" id="p120">data: {
    list: [
        {
            id: 1,
            name: 'iPhone 7',
            price: 6188,
            count: 1
        },
        {
            id: 2,
            name: 'iPad Pro',
            price: 5888,
            count: 1
        },
        {
            id: 3,
            name: 'MacBook Pro',
            price: 21488,
            count: 1
        }
    ]
}</pre>
                <p class="calibre4 pv pid121" id="p121">
                    数据构建好后，可以在index.html中展示列表了，毫无疑问，肯定会用到v-for，不过在此之前，我们先做一些小的优化。因为每个商品都是可以从购物车移除的，所以当列表为空时，在页面中显示一个“购物车为空”的提示更为友好，我们可以通过判断数组list的长度来实现该功能：</p>
                <pre class="calibre7 pv pid122" id="p122">&lt;div id="app" v-cloak&gt;
    &lt;template v-if="list.length"&gt;

    &lt;/template&gt;
    &lt;div v-else&gt;购物车为空&lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid123" id="p123">&lt;template&gt;里的代码分两部分，一部分是商品列表信息，我们用表格table来展现；另一部分就是带有千位分隔符的商品总价（每隔三位数加进一个逗号）。这部分代码如下：</p>
                <pre class="calibre7 pv pid124" id="p124">&lt;template v-if="list.length"&gt;
    &lt;table&gt;
        &lt;thead&gt;
            &lt;tr&gt;
                &lt;th&gt;&lt;/th&gt;
                &lt;th&gt;商品名称&lt;/th&gt;
                &lt;th&gt;商品单价&lt;/th&gt;
                &lt;th&gt;购买数量&lt;/th&gt;
                &lt;th&gt;操作&lt;/th&gt;
            &lt;/tr&gt;
        &lt;/thead&gt;
        &lt;tbody&gt;

        &lt;/tbody&gt;
    &lt;/table&gt;
    &lt;div&gt;总价：￥ {{ totalPrice }}&lt;/div&gt;
&lt;/template&gt;</pre>
                <p class="calibre4 pv pid125" id="p125">
                    总价totalPrice是依赖于商品列表而动态变化的，所以我们用计算属性来实现，顺便将结果转换为带有“千位分隔符”的数字，在index.js的computed选项内写入：</p>
                <pre class="calibre7 pv pid126" id="p126">computed: {
    totalPrice: function () {
        var total = 0;
        for (var i = 0; i &lt; this.list.length; i++) {
            var item = this.list[i];
            total += item.price * item.count;
        }

        return total.toString().replace(/\B(?=(\d{3})+$)/g,',');
    }
}</pre>
                <p class="calibre4 pv pid127" id="p127">这段代码难点在于千位分隔符的转换，读者可以查阅正则匹配的相关内容后尝试了解replace()的正则含义。</p>
                <p class="calibre4 pv pid128" id="p128">最后就剩下商品列表的渲染和相关的几个操作了。先在&lt;tbody&gt;内把数组list用v-for指令循环出来：</p>
                <pre class="calibre7 pv pid129" id="p129">&lt;tbody&gt;
    &lt;tr v-for="(item, index) in list"&gt;
        &lt;td&gt;{{ index + 1 }}&lt;/td&gt;
        &lt;td&gt;{{ item.name }}&lt;/td&gt;
        &lt;td&gt;{{ item.price }}&lt;/td&gt;
        &lt;td&gt;
            &lt;button
                @click="handleReduce(index)"
                :disabled="item.count === 1"&gt;-&lt;/button&gt;
            {{ item.count }}
            &lt;button @click="handleAdd(index)"&gt;+&lt;/button&gt;
        &lt;/td&gt;
        &lt;td&gt;
            &lt;button @click="handleRemove(index)"&gt;移除&lt;/button&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/tbody&gt;</pre>
                <p class="calibre4 pv pid130" id="p130">商品序号、名称、单价、数量都是直接使用插值来完成的，在第4列的两个按钮&lt;button&gt;用于增/减购买数量，分别绑定了两个方法handleReduce和handleAdd，参数都是当前商品在数组list中的索引。很多时候，一个元素上会同时使用多个特性（尤其是在组件中使用props传递数据时），写在一行代码较长，不便阅读，所以建议特性过多时，将每个特性都单独写为一行，比如第一个&lt;button
                    &gt;中使用了v-bind和v-on两个指令（这里都用的语法糖写法）。每件商品购买数量最少是1件，所以当count为1时，不允许再继续减少，所以这里给&lt;button&gt;动态绑定了disabled特性来禁用按钮。</p>
                <p class="calibre4 pv pid131" id="p131">在index.js中继续完成剩余的3个方法：</p>
                <pre class="calibre7 pv pid132" id="p132">methods: {
    handleReduce: function (index) {
        if (this.list[index].count === 1) return;
        this.list[index].count--;
    },
    handleAdd: function (index) {
        this.list[index].count++;
    },
    handleRemove: function (index) {
        this.list.splice(index, 1);
    }
}</pre>
                <p class="calibre4 pv pid133" id="p133">
                    这3个方法都是直接对数组list的操作，没有太复杂的逻辑。需要说明的是，虽然在button上已经绑定了disabled特性，但是在handleReduce方法内又判断了一遍，这是因为在某些时候，可能不一定会用button元素，也可能是div、span等，给它们增加disabled是没有任何作用的，所以安全起见，在业务逻辑中再判断一次，避免因修改HTML模板后出现bug。</p>
                <p class="calibre4 pv pid134" id="p134">以下是购物车示例的完整代码：</p>
                <p class="calibre4 pv pid135" id="p135" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid135" id="p135">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;购物车示例&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;
        &lt;template v-if="list.length"&gt;
            &lt;table&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;&lt;/th&gt;
                        &lt;th&gt;商品名称&lt;/th&gt;
                        &lt;th&gt;商品单价&lt;/th&gt;
                        &lt;th&gt;购买数量&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    &lt;tr v-for="(item, index) in list"&gt;
                        &lt;td&gt;{{ index + 1 }}&lt;/td&gt;
                        &lt;td&gt;{{ item.name }}&lt;/td&gt;
                        &lt;td&gt;{{ item.price }}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;button
                                @click="handleReduce(index)"
                                :disabled="item.count === 1"&gt;-&lt;/button&gt;
                            {{ item.count }}
                            &lt;button @click="handleAdd(index)"&gt;+&lt;/button&gt;
                        &lt;/td&gt;
                        &lt;td&gt;
                            &lt;button @click="handleRemove(index)"&gt;移除&lt;/button&gt;
                        &lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
            &lt;div&gt;总价：￥ {{ totalPrice }}&lt;/div&gt;
        &lt;/template&gt;
        &lt;div v-else&gt;购物车为空&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid136" id="p136" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid136" id="p136">var app = new Vue({
    el: '#app',
    data: {
        list: [
            {
                id: 1,
                name: 'iPhone 7',
                price: 6188,
                count: 1
            },
            {
                id: 2,
                name: 'iPad Pro',
                price: 5888,
                count: 1
            },
            {
                id: 3,
                name: 'MacBook Pro',
                price: 21488,
                count: 1
            }
        ]
    },
    computed: {
        totalPrice: function () {
            var total = 0;
            for (var i = 0; i &lt; this.list.length; i++) {
                var item = this.list[i];
                total += item.price * item.count;
            }

            return total.toString().replace(/\B(?=(\d{3})+$)/g,',');
        }
    },
    methods: {
        handleReduce: function (index) {
            if (this.list[index].count === 1) return;
            this.list[index].count--;
        },
        handleAdd: function (index) {
            this.list[index].count++;
        },
        handleRemove: function (index) {
            this.list.splice(index, 1);
        }
    }
});</pre>
                <p class="calibre4 pv pid137" id="p137" style="margin: 0px;"><span
                        class="kindle-cn-bold">style.css：</span></p>
                <pre class="calibre7 pv pid137" id="p137">[v-cloak] {
    display: none;
}
table{
    border: 1px solid #e9e9e9;
    border-collapse: collapse;
    border-spacing: 0;
    empty-cells: show;
}
th, td{
    padding: 8px 16px;
    border: 1px solid #e9e9e9;
    text-align: left;
}
th{
    background: #f7f7f7;
    color: #5c6b77;
    font-weight: 600;
    white-space: nowrap;
}</pre>
                <p class="calibre4 pv pid138" id="p138" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>在当前示例基础上扩展商品列表，新增一项是否选中该商品的功能，总价变为只计算选中商品的总价，同时提供一个全选的按钮。
                </p>
                <p class="calibre4 pv pid138" id="p138" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>将商品列表list改为一个二维数组来实现商品的分类，比如可分为“电子产品”“生活用品”和“果蔬”，同类商品聚合在一起。提示，你可能会用到两次v-for。
                </p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="49" data-chapter-url="24047092" alt="64157303">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第6章　表单与v-model</h2>
                <p class="calibre4 pv pid3" id="p3">表单类控件承载了一个网页数据的录入与交互，本章将介绍如何使用指令v-model完成表单的数据双向绑定。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_38 pv pid4" id="p4" name="sigil_toc_id_38">6.1　基本用法</h3>
                <p class="calibre4 pv pid5" id="p5">
                    表单控件在实际业务较为常见，比如单选、多选、下拉选择、输入框等，用它们可以完成数据的录入、校验、提交等。Vue.js提供了v-model指令，用于在表单类元素上双向绑定数据，例如在输入框上使用时，输入的内容会实时映射到绑定的数据上。例如下面的例子：</p>
                <pre class="calibre7 pv pid6" id="p6">&lt;div id="app"&gt;
    &lt;input type="text" v-model="message" placeholder="输入..."&gt;
    &lt;p&gt;输入的内容是：{{ message }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid7" id="p7">在输入框输入的同时，{{ message }} 也会实时将内容渲染在视图中，如图6-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid8" id="p8" style="margin: 0px;"><img alt="070"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/2f07eb364f60fecc.jpg"
                                                                                                       href="./image/00011.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图6-1　v-model指令对数据的双向绑定</p></div>
                <p class="calibre4 pv pid8" id="p8">对于文本域 textarea 也是同样的用法：</p>
                <pre class="calibre7 pv pid9" id="p9">&lt;div id="app"&gt;
    &lt;textarea v-model="text" placeholder="输入..."&gt;&lt;/textarea&gt;
    &lt;p&gt;输入的内容是：&lt;/p&gt;
    &lt;p style="white-space: pre"&gt;{{ text }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            text: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid10" id="p10">提示</p>
                <p class="kindle-cn-para-no-indent pv pid11" id="p11" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">使用v-model后，表单控件显示的值只依赖所绑定的数据，不再关心初始化时的value属性，对于在&lt;textarea&gt;&lt;/textarea&gt; 之间插入的值，也不会生效。</span>
                </p>
                <p class="kindle-cn-para-no-indent pv pid11" id="p11" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">使用v-model时，如果是用中文输入法输入中文，一般在没有选定词组前，也就是在拼音阶段，Vue是不会更新数据的，当敲下汉字时才会触发更新。如果希望总是实时更新，可以用@input来替代v-model。事实上，v-model也是一个特殊的语法糖，只不过它会在不同的表单上智能处理。例如下面的示例：</span>
                </p>
                <pre class="calibre7 pv pid11" id="p11">&lt;div id="app"&gt;
    &lt;input type="text" @input="handleInput" placeholder="输入..."&gt;
    &lt;p&gt;输入的内容是：{{ message }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        },
        methods: {
            handleInput: function (e) {
                this.message = e.target.value;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid12" id="p12">来看看更多的表单控件。</p>
                <p class="calibre4 pv pid13" id="p13" style="margin: 0px;"><span class="kindle-cn-bold">单选按钮：</span></p>
                <p class="calibre4 pv pid13" id="p13">单选按钮在单独使用时，不需要v-model，直接使用v-bind绑定一个布尔类型的值，为真时选中，为否时不选，例如：</p>
                <pre class="calibre7 pv pid14" id="p14">&lt;div id="app"&gt;
    &lt;input type="radio" :checked="picked"&gt;
    &lt;label&gt;单选按钮&lt;/label&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            picked: true
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid15" id="p15">如果是组合使用来实现互斥选择的效果，就需要v-model配合value来使用：</p>
                <pre class="calibre7 pv pid16" id="p16">&lt;div id="app"&gt;
    &lt;input type="radio" v-model="picked" value="html" id="html"&gt;
    &lt;label for="html"&gt;HTML&lt;/label&gt;
    &lt;br&gt;
    &lt;input type="radio" v-model="picked" value="js" id="js"&gt;
    &lt;label for="js"&gt;JavaScript&lt;/label&gt;
    &lt;br&gt;
    &lt;input type="radio" v-model="picked" value="css" id="css"&gt;
    &lt;label for="css"&gt;CSS&lt;/label&gt;
    &lt;br&gt;
    &lt;p&gt;选择的项是：{{ picked }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            picked: 'js'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid17" id="p17">
                    数据picked的值与单选按钮的value值一致时，就会选中该项，所以当前状态下选中的是第二项JavaScript，如图6-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid18" id="p18" style="margin: 0px;"><img alt="072"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/c90aca368c1c7685.jpg"
                                                                                                         href="./image/00012.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图6-2　单选按钮示例结果</p></div>
                <p class="calibre4 pv pid18" id="p18" style="margin: 0px;"><span class="kindle-cn-bold">复选框：</span></p>
                <p class="calibre4 pv pid18" id="p18">复选框也分单独使用和组合使用，不过用法稍与单选不同。复选框单独使用时，也是用v-model来绑定一个布尔值，例如：</p>
                <pre class="calibre7 pv pid19" id="p19">&lt;div id="app"&gt;
    &lt;input type="checkbox" v-model="checked" id="checked"&gt;
    &lt;label for="checked"&gt;选择状态：{{ checked }}&lt;/label&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            checked: false
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid20" id="p20">在勾选时，数据checked的值变为了true，label中渲染的内容也会更新。</p>
                <p class="calibre4 pv pid21" id="p21">
                    组合使用时，也是v-model与value一起，多个勾选框都绑定到同一个数组类型的数据，value的值在数组当中，就会选中这一项。这一过程也是双向的，在勾选时，value的值也会自动push到这个数组中，示例代码如下：</p>
                <pre class="calibre7 pv pid22" id="p22">&lt;div id="app"&gt;
    &lt;input type="checkbox" v-model="checked" value="html" id="html"&gt;
    &lt;label for="html"&gt;HTML&lt;/label&gt;
    &lt;br&gt;
    &lt;input type="checkbox" v-model="checked" value="js" id="js"&gt;
    &lt;label for="js"&gt;JavaScript&lt;/label&gt;
    &lt;br&gt;
    &lt;input type="checkbox" v-model="checked" value="css" id="css"&gt;
    &lt;label for="css"&gt;CSS&lt;/label&gt;
    &lt;br&gt;
    &lt;p&gt;选择的项是：{{ checked }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            checked: ['html', 'css']
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid23" id="p23">当前状态下的结果如图6-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid24" id="p24" style="margin: 0px;"><img alt="073"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/dbe48bf06a04650b.jpg"
                                                                                                         href="./image/00013.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图6-3　多选框组合使用的结果</p></div>
                <p class="calibre4 pv pid24" id="p24" style="margin: 0px;"><span class="kindle-cn-bold">选择列表：</span></p>
                <p class="calibre4 pv pid24" id="p24">选择列表就是下拉选择器，也是常见的表单控件，同样也分为单选和多选两种方式。先看一下单选的示例代码：</p>
                <pre class="calibre7 pv pid25" id="p25">&lt;div id="app"&gt;
    &lt;select v-model="selected"&gt;
        &lt;option&gt;html&lt;/option&gt;
        &lt;option value="js"&gt;JavaScript&lt;/option&gt;
        &lt;option&gt;css&lt;/option&gt;
    &lt;/select&gt;
    &lt;p&gt;选择的项是：{{ selected }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            selected: 'html'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid26" id="p26">&lt;option&gt;是备选项，如果含有value属性，v-model就会优先匹配value的值；如果没有，就会直接匹配
                    &lt;option&gt;的text，比如选中第二项时，selected的值是js，而不是JavaScript。</p>
                <p class="calibre4 pv pid27" id="p27">给&lt;select&gt;添加属性multiple就可以多选了，此时v-model绑定的是一个数组，与复选框用法类似，示例代码如下：</p>
                <pre class="calibre7 pv pid28" id="p28">&lt;div id="app"&gt;
    &lt;select v-model="selected" multiple&gt;
        &lt;option&gt;html&lt;/option&gt;
        &lt;option value="js"&gt;JavaScript&lt;/option&gt;
        &lt;option&gt;css&lt;/option&gt;
    &lt;/select&gt;
    &lt;p&gt;选择的项是：{{ selected }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            selected: ['html', 'js']
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid29" id="p29">在业务中，&lt;option&gt;经常用v-for动态输出，value和text也是用v-bind来动态输出的，例如：</p>
                <pre class="calibre7 pv pid30" id="p30">&lt;div id="app"&gt;
    &lt;select v-model="selected"&gt;
        &lt;option
            v-for="option in options"
            :value="option.value"&gt;{{ option.text }}&lt;/option&gt;
    &lt;/select&gt;
    &lt;p&gt;选择的项是：{{ selected }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            selected: 'html',
            options: [
                {
                    text: 'HTML',
                    value: 'html'
                },
                {
                    text: 'JavaScript',
                    value: 'js'
                },
                {
                    text: 'CSS',
                    value: 'css'
                }
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid31" id="p31">虽然用选择列表&lt;select&gt;控件可以很简单地完成下拉选择的需求，但是在实际业务中反而不常用，因为它的样式依赖平台和浏览器，无法统一，也不太美观，功能也受限，比如不支持搜索，所以常见的解决方案是用div模拟一个类似的控件。当阅读完第7章组件的内容后，可以尝试编写一个下拉选择器的通用组件。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_39 pv pid32" id="p32" name="sigil_toc_id_39">6.2　绑定值</h3>
                <p class="calibre4 pv pid33" id="p33">
                    上一节介绍的单选按钮、复选框和选择列表在单独使用或单选的模式下，v-model绑定的值是一个静态字符串或布尔值，但在业务中，有时需要绑定一个动态的数据，这时可以用v-bind来实现。</p>
                <p class="calibre4 pv pid34" id="p34" style="margin: 0px;"><span class="kindle-cn-bold">单选按钮：</span></p>
                <pre class="calibre7 pv pid34" id="p34">&lt;div id="app"&gt;
    &lt;input type="radio" v-model="picked" :value="value"&gt;
    &lt;label&gt;单选按钮&lt;/label&gt;
    &lt;p&gt;{{ picked }}&lt;/p&gt;
    &lt;p&gt;{{ value }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            picked: false,
            value: 123
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid35" id="p35">在选中时，app.picked === app.value，值都是123。</p>
                <p class="calibre4 pv pid36" id="p36" style="margin: 0px;"><span class="kindle-cn-bold">复选框：</span></p>
                <pre class="calibre7 pv pid36" id="p36">&lt;div id="app"&gt;
    &lt;input
        type="checkbox"
        v-model="toggle"
        :true-value="value1"
        :false-value="value2"&gt;
    &lt;label&gt;复选框&lt;/label&gt;
    &lt;p&gt;{{ toggle }}&lt;/p&gt;
    &lt;p&gt;{{ value1 }}&lt;/p&gt;
    &lt;p&gt;{{ value2 }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            toggle: false,
            value1: 'a',
            value2: 'b'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid37" id="p37">勾选时，app.toggle === app.value1；未勾选时，app.toggle === app.value2。</p>
                <p class="calibre4 pv pid38" id="p38" style="margin: 0px;"><span class="kindle-cn-bold">选择列表：</span></p>
                <pre class="calibre7 pv pid38" id="p38">&lt;div id="app"&gt;
    &lt;select v-model="selected"&gt;
        &lt;option :value="{ number: 123 }"&gt;123&lt;/option&gt;
    &lt;/select&gt;
    {{ selected.number }}
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            selected: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid39" id="p39">当选中时，app.selected是一个Object，所以app.selected.number === 123。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_40 pv pid40" id="p40" name="sigil_toc_id_40">6.3　修饰符</h3>
                <p class="calibre4 pv pid41" id="p41">与事件的修饰符类似，v-model 也有修饰符，用于控制数据同步的时机。</p>
                <p class="calibre4 pv pid42" id="p42" style="margin: 0px;"><span class="kindle-cn-bold">.lazy：</span>
                </p>
                <p class="calibre4 pv pid42" id="p42">在输入框中，v-model默认是在input事件中同步输入框的数据（除了提示中介绍的中文输入法情况外），使用修饰符
                    .lazy会转变为在change事件中同步，示例代码如下：</p>
                <pre class="calibre7 pv pid43" id="p43">&lt;div id="app"&gt;
    &lt;input type="text" v-model.lazy="message"&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid44" id="p44">这时，message 并不是实时改变的，而是在失焦或按回车时才更新。</p>
                <p class="calibre4 pv pid45" id="p45" style="margin: 0px;"><span class="kindle-cn-bold">.number：</span>
                </p>
                <p class="calibre4 pv pid45" id="p45">
                    使用修饰符.number可以将输入转换为Number类型，否则虽然你输入的是数字，但它的类型其实是String，比如在数字输入框时会比较有用，示例代码如下：</p>
                <pre class="calibre7 pv pid46" id="p46">&lt;div id="app"&gt;
    &lt;input type="number" v-model.number="message"&gt;
    &lt;p&gt;{{ typeof message }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: 123
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid47" id="p47" style="margin: 0px;"><span class="kindle-cn-bold">.trim：</span>
                </p>
                <p class="calibre4 pv pid47" id="p47">修饰符 .trim可以自动过滤输入的首尾空格，示例代码如下：</p>
                <pre class="calibre7 pv pid48" id="p48">&lt;div id="app"&gt;
    &lt;input type="text" v-model.trim="message"&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid49" id="p49">从Vue.js 2.x开始，v-model还可以用于自定义组件，满足定制化的需求，在第7章会详细介绍。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="53" data-chapter-url="24047093" alt="64157307">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第7章　组件详解</h2>
                <p class="calibre4 pv pid3" id="p3">
                    组件（Component）是Vue.js最核心的功能，也是整个框架设计最精彩的地方，当然也是最难掌握的。本章将带领你由浅入深地学习组件的全部内容，并通过几个实战项目熟练使用Vue组件。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_41 pv pid4" id="p4" name="sigil_toc_id_41">7.1　组件与复用</h3><h4
                        class="kindle-cn-heading3 sigil_toc_id_42 pv pid5" id="p5" name="sigil_toc_id_42">
                    7.1.1　为什么使用组件</h4>
                <p class="calibre4 pv pid6" id="p6">在正式介绍组件前，我们先来看一个简单的场景，如图7-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid7" id="p7" style="margin: 0px;"><img alt="079"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/56d04bdfe67e0ce2.jpg"
                                                                                                       href="./image/00014.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-1　常见的聊天界面</p></div>
                <p class="calibre4 pv pid7" id="p7">
                    图7-1中是一个很常见的聊天界面，有一些标准的控件，比如右上角的关闭按钮、输入框、发送按钮等。你可能要问了，这有什么难的，不就是几个div、input吗？好，那现在需求升级了，这几个控件还有别的地方要用到。没问题，复制粘贴呗。那如果输入框要带数据验证，按钮的图标支持自定义呢？这样用JavaScript封装后一起复制吧。那等到项目快完结时，产品经理说，所有使用输入框的地方，都要改成支持回车键提交。好吧，给我一天的时间，我一个一个加上去。</p>
                <p class="calibre4 pv pid8" id="p8">
                    上面的需求虽然有点变态，但却是业务中很常见的，那就是一些控件、JavaScript能力的复用。没错，Vue.js的组件就是提高重用性的，让代码可复用，当学习完组件后，上面的问题就可以分分钟搞定了，再也不用害怕产品经理的奇葩需求。</p>
                <p class="calibre4 pv pid9" id="p9">我们先看一下图7-1中的示例用组件来编写是怎样的，示例代码如下：</p>
                <pre class="calibre7 pv pid10" id="p10">&lt;Card style="width: 350px;"&gt;
    &lt;p slot="title"&gt;与xxx 聊天中&lt;/p&gt;
    &lt;a href="#" slot="extra"&gt;
        &lt;Icon type="android-close" size="18"&gt;&lt;/Icon&gt;
    &lt;/a&gt;
    &lt;div style="height: 100px;"&gt;

    &lt;/div&gt;
    &lt;div&gt;
        &lt;Row :gutter="16"&gt;
            &lt;i-col span="17"&gt;
                &lt;i-input
                    v-model="value"
                    placeholder="请输入..."&gt;&lt;/i-input&gt;
            &lt;/i-col&gt;
            &lt;i-col span="4"&gt;
                &lt;i-button
                    type="primary"
                    icon="paper-airplane"&gt;发送&lt;/i-button&gt;
            &lt;/i-col&gt;
        &lt;/Row&gt;
    &lt;/div&gt;
&lt;/Card&gt;</pre>
                <p class="calibre4 pv pid11" id="p11">是不是很奇怪，有很多我们从来都没有见过的标签，比如&lt;Card&gt;、&lt;Row&gt;、&lt;i-col&gt;、&lt;i-input&gt;和&lt;i-button&gt;等，而且整段代码除了内联的几个样式外，一句
                    CSS 代码也没有，但最终实现的UI就是图7-1的效果。</p>
                <p class="calibre4 pv pid12" id="p12">
                    这些没见过的自定义标签就是组件，每个标签代表一个组件，在任何使用Vue的地方都可以直接使用。接下来，我们就来看看组件的具体用法。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_43 pv pid13" id="p13" name="sigil_toc_id_43">
                    7.1.2　组件用法</h4>
                <p class="calibre4 pv pid14" id="p14">回顾一下我们创建Vue实例的方法：</p>
                <pre class="calibre7 pv pid15" id="p15">var app = new Vue({
    el: '#app'
})</pre>
                <p class="calibre4 pv pid16" id="p16">
                    组件与之类似，需要注册后才可以使用。注册有全局注册和局部注册两种方式。全局注册后，任何Vue实例都可以使用。全局注册示例代码如下：</p>
                <pre class="calibre7 pv pid17" id="p17">Vue.component('my-component', {
    //选项
})</pre>
                <p class="calibre4 pv pid18" id="p18">my-component就是注册的组件自定义标签名称，推荐使用小写加减号分割的形式命名。</p>
                <p class="calibre4 pv pid19" id="p19">要在父实例中使用这个组件，必须要在实例创建前注册，之后就可以用&lt;my-component&gt; &lt;/my-component&gt;的形式来使用组件了，示例代码如下：</p>
                <pre class="calibre7 pv pid20" id="p20">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        //选项
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid21" id="p21">此时打开页面还是空白的，因为我们注册的组件没有任何内容，在组件选项中添加template就可以显示组件内容了，示例代码如下：</p>
                <pre class="calibre7 pv pid22" id="p22">Vue.component('my-component', {
    template: '&lt;div&gt;这里是组件的内容&lt;/div&gt;'
});</pre>
                <p class="calibre4 pv pid23" id="p23">渲染后的结果是：</p>
                <pre class="calibre7 pv pid24" id="p24">&lt;div id="app"&gt;
    &lt;div&gt;这里是组件的内容&lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid25" id="p25">template的DOM结构必须被一个元素包含，如果直接写成“这里是组件的内容”，不带“&lt;div&gt;&lt;/div&gt;”是无法渲染的。</p>
                <p class="calibre4 pv pid26" id="p26">
                    在Vue实例中，使用components选项可以局部注册组件，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件，使组件可以嵌套。示例代码如下：</p>
                <pre class="calibre7 pv pid27" id="p27">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    var Child = {
        template: '&lt;div&gt;局部注册组件的内容&lt;/div&gt;'
    }

    var app = new Vue({
        el: '#app',
        components: {
            'my-component': Child
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid28" id="p28">Vue组件的模板在某些情况下会受到HTML的限制，比如&lt;table&gt;内规定只允许是&lt;tr&gt;、&lt;td&gt;、&lt;th&gt;等这些表格元素，所以在&lt;table&gt;内直接使用组件是无效的。这种情况下，可以使用特殊的is属性来挂载组件，示例代码如下：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div id="app"&gt;
    &lt;table&gt;
        &lt;tbody is="my-component"&gt;&lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;div&gt;这里是组件的内容&lt;/div&gt;'
    });
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">tbody在渲染时，会被替换为组件的内容。常见的限制元素还有&lt;ul&gt;、&lt;ol&gt;、&lt;select&gt;
                    。</p>
                <p class="kindle-cn-para-left pv pid31" id="p31">提示</p>
                <p class="kindle-cn-para-no-indent pv pid32" id="p32" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果使用的是字符串模板，是不受限制的，比如后面章节介绍的.vue单文件用法等。</span></p>
                <p class="calibre4 pv pid32" id="p32">
                    除了template选项外，组件中还可以像Vue实例那样使用其他的选项，比如data、computed、methods等。但是在使用data时，和实例稍有区别，data必须是函数，然后将数据return出去，例如：</p>
                <pre class="calibre7 pv pid33" id="p33">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;',
        data: function () {
            return {
                message: '组件内容'
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid34" id="p34">
                    JavaScript对象是引用关系，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方修改都会同步。比如下面的示例：</p>
                <pre class="calibre7 pv pid35" id="p35">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    var data = {
        counter: 0
    };

    Vue.component('my-component', {
        template: '&lt;button @click="counter++"&gt;{{ counter }}&lt;/button&gt;',
        data: function () {
            return data;
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid36" id="p36">组件使用了3次，但是点击任意一个&lt;button&gt;，3个的数字都会加1，那是因为组件的data引用的是外部的对象，这肯定不是我们期望的效果，所以给组件返回一个新的data对象来独立，示例代码如下：</p>
                <pre class="calibre7 pv pid37" id="p37">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;button @click="counter++"&gt;{{ counter }}&lt;/button&gt;',
        data: function () {
            return {
                counter: 0
            };
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid38" id="p38">这样，点击3个按钮就互不影响了，完全达到复用的目的。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_44 pv pid39" id="p39" name="sigil_toc_id_44">
                    7.2　使用props传递数据</h3><h4 class="kindle-cn-heading3 sigil_toc_id_45 pv pid40" id="p40"
                                            name="sigil_toc_id_45">7.2.1　基本用法</h4>
                <p class="calibre4 pv pid41" id="p41">
                    组件不仅仅是要把模板的内容进行复用，更重要的是组件间要进行通信。通常父组件的模板中包含子组件，父组件要正向地向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。这个正向传递数据的过程就是通过props来实现的。</p>
                <p class="calibre4 pv pid42" id="p42">
                    在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是两种，一种是字符串数组，一种是对象，本小节先介绍数组的用法。比如我们构造一个数组，接收一个来自父级的数据message，并把它在组件模板中渲染，示例代码如下：</p>
                <pre class="calibre7 pv pid43" id="p43">&lt;div id="app"&gt;
    &lt;my-component message="来自父组件的数据"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['message'],
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid44" id="p44">渲染后的结果为：</p>
                <pre class="calibre7 pv pid45" id="p45">&lt;div id="app"&gt;
    &lt;div&gt;来自父组件的数据&lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid46" id="p46">
                    props中声明的数据与组件data函数return的数据主要区别就是props的来自父级，而data中的是组件自己的数据，作用域是组件本身，这两种数据都可以在模板template及计算属性computed和方法methods中使用。上例的数据message就是通过props从父级传递过来的，在组件的自定义标签上直接写该props的名称，如果要传递多个数据，在props数组中添加项即可。</p>
                <p class="calibre4 pv pid47" id="p47">
                    由于HTML特性不区分大小写，当使用DOM模板时，驼峰命名（camelCase）的props名称要转为短横分隔命名（kebab-case），例如：</p>
                <pre class="calibre7 pv pid48" id="p48">&lt;div id="app"&gt;
    &lt;my-component warning-text="提示信息"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['warningText'],
        template: '&lt;div&gt;{{ warningText }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid49" id="p49">提示</p>
                <p class="kindle-cn-para-no-indent pv pid50" id="p50" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果使用的是字符串模板，仍然可以忽略这些限制。</span></p>
                <p class="calibre4 pv pid50" id="p50">
                    有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这时可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。示例代码如下：</p>
                <pre class="calibre7 pv pid51" id="p51">&lt;div id="app"&gt;
    &lt;input type="text" v-model="parentMessage"&gt;
    &lt;my-component :message="parentMessage"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['message'],
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app',
        data: {
            parentMessage: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid52" id="p52">这里用v-model绑定了父级的数据parentMessage，当通过输入框任意输入时，子组件接收到的props
                    “message”也会实时响应，并更新组件模板。</p>
                <p class="kindle-cn-para-left pv pid53" id="p53">提示</p>
                <p class="kindle-cn-para-no-indent pv pid54" id="p54" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">注意，如果你要直接传递数字、布尔值、数组、对象，而且不使用v-bind，传递的仅仅是字符串，尝试下面的示例来对比：</span>
                </p>
                <pre class="calibre7 pv pid54" id="p54">&lt;div id="app"&gt;
    &lt;my-component message="[1,2,3]"&gt;&lt;/my-component&gt;
    &lt;my-component :message="[1,2,3]"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['message'],
        template: '&lt;div&gt;{{ message.length }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-no-indent pv pid55" id="p55" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">同一个组件使用了两次，区别仅仅是第二个使用的是v-bind。渲染后的结果，第一个是7，第二个才是数组的长度3。</span>
                </p><h4 class="kindle-cn-heading3 sigil_toc_id_46 pv pid55" id="p55" name="sigil_toc_id_46">
                    7.2.2　单向数据流</h4>
                <p class="calibre4 pv pid56" id="p56">Vue 2.x与Vue 1.x比较大的一个改变就是，Vue
                    2.x通过props传递数据是单向的了，也就是父组件数据变化时会传递给子组件，但是反过来不行。而在Vue
                    1.x里提供了.sync修饰符来支持双向绑定。之所以这样设计，是尽可能将父子组件解耦，避免子组件无意中修改了父组件的状态。</p>
                <p class="calibre4 pv pid57" id="p57">
                    业务中会经常遇到两种需要改变prop的情况，一种是父组件传递初始值进来，子组件将它作为初始值保存起来，在自己的作用域下可以随意使用和修改。这种情况可以在组件data内再声明一个数据，引用父组件的prop，示例代码如下：</p>
                <pre class="calibre7 pv pid58" id="p58">&lt;div id="app"&gt;
    &lt;my-component :init-count="1"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['initCount'],
        template: '&lt;div&gt;{{ count }}&lt;/div&gt;',
        data: function () {
            return {
                count: this.initCount
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid59" id="p59">
                    组件中声明了数据count，它在组件初始化时会获取来自父组件的initCount，之后就与之无关了，只用维护count，这样就可以避免直接操作initCount。</p>
                <p class="calibre4 pv pid60" id="p60">另一种情况就是prop作为需要被转变的原始值传入。这种情况用计算属性就可以了，示例代码如下：</p>
                <pre class="calibre7 pv pid61" id="p61">&lt;div id="app"&gt;
    &lt;my-component :width="100"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['width'],
        template: '&lt;div :style="style"&gt;组件内容&lt;/div&gt;',
        computed: {
            style: function () {
                return {
                    width: this.width + 'px'
                }
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid62" id="p62">
                    因为用CSS传递宽度要带单位（px），但是每次都写太麻烦，而且数值计算一般是不带单位的，所以统一在组件内使用计算属性就可以了。</p>
                <p class="kindle-cn-para-left pv pid63" id="p63">提示</p>
                <p class="kindle-cn-para-no-indent pv pid64" id="p64" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">注意，在JavaScript中对象和数组是引用类型，指向同一个内存空间，所以props是对象和数组时，在子组件内改变是会影响父组件的。</span>
                </p><h4 class="kindle-cn-heading3 sigil_toc_id_47 pv pid64" id="p64" name="sigil_toc_id_47">
                    7.2.3　数据验证</h4>
                <p class="calibre4 pv pid65" id="p65">
                    我们上面所介绍的props选项的值都是一个数组，一开始也介绍过，除了数组外，还可以是对象，当prop需要验证时，就需要对象写法。</p>
                <p class="calibre4 pv pid66" id="p66">一般当你的组件需要提供给别人使用时，推荐都进行数据验证，比如某个数据必须是数字类型，如果传入字符串，就会在控制台弹出警告。</p>
                <p class="calibre4 pv pid67" id="p67">以下是几个prop的示例：</p>
                <pre class="calibre7 pv pid68" id="p68">Vue.component('my-component', {
    props: {
        //必须是数字类型
        propA: Number,
        //必须是字符串或数字类型
        propB: [String, Number],
        // 布尔值，如果没有定义，默认值就是true
        propC: {
            type: Boolean,
            default: true
        },
        //数字，而且是必传
        propD: {
            type: Number,
            required: true
        },
        // 如果是数组或对象，默认值必须是一个函数来返回
        propE: {
            type: Array,
            default: function () {
                return [];
            }
        },
        // 自定义一个验证函数
        propF: {
            validator: function (value) {
                return value &gt; 10;
            }
        }
    }
});</pre>
                <p class="calibre4 pv pid69" id="p69">验证的type类型可以是：</p>
                <ul class="kindle-cn-ul-disc pv pid70" id="p70" style="margin: 0px;">
                    <li class="calibre6">String</li>
                    <li class="calibre6">Number</li>
                    <li class="calibre6">Boolean</li>
                    <li class="calibre6">Object</li>
                    <li class="calibre6">Array</li>
                    <li class="calibre6">Function</li>
                </ul>
                <p class="calibre4 pv pid70" id="p70">type也可以是一个自定义构造器，使用instanceof 检测。</p>
                <p class="calibre4 pv pid71" id="p71">当prop验证失败时，在开发版本下会在控制台抛出一条警告。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_48 pv pid72" id="p72" name="sigil_toc_id_48">7.3　组件通信</h3>
                <p class="calibre4 pv pid73" id="p73">
                    我们已经知道，从父组件向子组件通信，通过props传递数据就可以了，但Vue组件通信的场景不止有这一种，归纳起来，组件之间通信可以用图7-2表示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid74" id="p74" style="margin: 0px;"><img alt="089"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/3506b958df97512c.jpg"
                                                                                                         href="./image/00015.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-2　组件通信示例</p></div>
                <p class="calibre4 pv pid74" id="p74">组件关系可分为父子组件通信、兄弟组件通信、跨级组件通信。本节将介绍各种组件之间通信的方法。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_49 pv pid75" id="p75" name="sigil_toc_id_49">
                    7.3.1　自定义事件</h4>
                <p class="calibre4 pv pid76" id="p76">
                    当子组件需要向父组件传递数据时，就要用到自定义事件。我们在介绍指令v-on时有提到，v-on除了监听DOM事件外，还可以用于组件之间的自定义事件。</p>
                <p class="calibre4 pv pid77" id="p77">
                    如果你了解过JavaScript的设计模式——观察者模式，一定知道dispatchEvent和addEventListener这两个方法。Vue组件也有与之类似的一套模式，子组件用$emit()来触发事件，父组件用$on()来监听子组件的事件。</p>
                <p class="calibre4 pv pid78" id="p78">父组件也可以直接在子组件的自定义标签上使用v-on来监听子组件触发的自定义事件，示例代码如下：</p>
                <pre class="calibre7 pv pid79" id="p79">&lt;div id="app"&gt;
    &lt;p&gt;总数：{{ total }}&lt;/p&gt;
    &lt;my-component
        @increase="handleGetTotal"
        @reduce="handleGetTotal"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '\
        &lt;div&gt;\
            &lt;button @click="handleIncrease"&gt;+1&lt;/button&gt;\
            &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;\
        &lt;/div&gt;',
        data: function () {
            return {
                counter: 0
            }
        },
        methods: {
            handleIncrease: function () {
                this.counter++;
                this.$emit('increase', this.counter);
            },
            handleReduce: function () {
                this.counter--;
                this.$emit('reduce', this.counter);
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            total: 0
        },
        methods: {
            handleGetTotal: function (total) {
                this.total = total;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid80" id="p80">
                    上面示例中，子组件有两个按钮，分别实现加1和减1的效果，在改变组件的data“counter”后，通过$emit()再把它传递给父组件，父组件用v-on:increase和v-on:reduce（示例使用的是语法糖）。$emit()方法的第一个参数是自定义事件的名称，例如示例的increase和reduce后面的参数都是要传递的数据，可以不填或填写多个。</p>
                <p class="calibre4 pv pid81" id="p81">
                    除了用v-on在组件上监听自定义事件外，也可以监听DOM事件，这时可以用.native修饰符表示监听的是一个原生事件，监听的是该组件的根元素，示例代码如下：</p>
                <pre class="calibre7 pv pid82" id="p82">&lt;my-component v-on:click.native="handleClick"&gt;&lt;/my-component&gt;</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_50 pv pid83" id="p83" name="sigil_toc_id_50">
                    7.3.2　使用v-model</h4>
                <p class="calibre4 pv pid84" id="p84">Vue 2.x可以在自定义组件上使用v-model指令，我们先来看一个示例：</p>
                <pre class="calibre7 pv pid85" id="p85">&lt;div id="app"&gt;
    &lt;p&gt;总数：{{ total }}&lt;/p&gt;
    &lt;my-component v-model="total"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;button @click="handleClick"&gt;+1&lt;/button&gt;',
        data: function () {
            return {
                counter: 0
            }
        },
        methods: {
            handleClick: function () {
                this.counter++;
                this.$emit('input', this.counter);
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            total: 0
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid86" id="p86">仍然是点击按钮加1的效果，不过这次组件$emit()的事件名是特殊的input，在使用组件的父级，并没有在&lt;my-component&gt;上使用@input=“handler"，而是直接用了v-model绑定的一个数据total。这也可以称作是一个语法糖，因为上面的示例可以间接地用自定义事件来实现：</p>
                <pre class="calibre7 pv pid87" id="p87">&lt;div id="app"&gt;
    &lt;p&gt;总数：{{ total }}&lt;/p&gt;
    &lt;my-component @input="handleGetTotal"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
         // ...省略组件代码
    var app = new Vue({
        el: '#app',
        data: {
            total: 0
        },
        methods: {
            handleGetTotal: function (total) {
                this.total = total;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid88" id="p88">v-model 还可以用来创建自定义的表单输入组件，进行数据双向绑定，例如：</p>
                <pre class="calibre7 pv pid89" id="p89">&lt;div id="app"&gt;
    &lt;p&gt;总数：{{ total }}&lt;/p&gt;
    &lt;my-component v-model="total"&gt;&lt;/my-component&gt;
    &lt;button @click="handleReduce"&gt;-1&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['value'],
        template: '&lt;input :value="value" @input="updateValue"&gt;',
        methods: {
            updateValue: function (event) {
                this.$emit('input', event.target.value);
            }
        }
    });
    var app = new Vue({
        el: '#app',
        data: {
            total: 0
        },
        methods: {
            handleReduce: function () {
                this.total--;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid90" id="p90">实现这样一个具有双向绑定的v-model组件要满足下面两个要求：</p>
                <ul class="kindle-cn-ul-disc pv pid91" id="p91" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">接收一个value属性。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">在有新的value时触发input事件。</span></li>
                </ul>
                <h4 class="kindle-cn-heading3 sigil_toc_id_51 pv pid91" id="p91" name="sigil_toc_id_51">
                    7.3.3　非父子组件通信</h4>
                <p class="calibre4 pv pid92" id="p92">
                    在实际业务中，除了父子组件通信外，还有很多非父子组件通信的场景，非父子组件一般有两种，兄弟组件和跨多级组件。为了更加彻底地了解Vue.js 2.x中的通信方法，我们先来看一下在Vue.js
                    1.x中是如何实现的，这样便于我们了解 Vue.js的设计思想。</p>
                <p class="calibre4 pv pid93" id="p93">在Vue.js 1.x中，除了$emit()方法外，还提供了$dispatch()和$broadcast()
                    这两个方法。$dispatch() 用于向上级派发事件，只要是它的父级（一级或多级以上），都可以在Vue实例的events选项内接收，示例代码如下：</p>
                <pre class="calibre7 pv pid94" id="p94">&lt;!-- 注意：该示例需使用Vue.js 1.x的版本--&gt;
&lt;div id="app"&gt;
    {{ message }}
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;button @click="handleDispatch"&gt;派发事件&lt;/button&gt;',
        methods: {
            handleDispatch: function () {
                this.$dispatch('on-message', '来自内部组件的数据');
            }
        }
    });
    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        },
        events: {
            'on-message': function (msg) {
                this.message = msg;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid95" id="p95">同理，$broadcast()是由上级向下级广播事件的，用法完全一致，只是方向相反。</p>
                <p class="calibre4 pv pid96" id="p96">这两种方法一旦发出事件后，任何组件都是可以接收到的，就近原则，而且会在第一次接收到后停止冒泡，除非返回true。</p>
                <p class="calibre4 pv pid97" id="p97">这两个方法虽然看起来很好用，但是在Vue.js
                    2.x中都废弃了，因为基于组件树结构的事件流方式让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱，并且不能解决兄弟组件通信的问题。</p>
                <p class="calibre4 pv pid98" id="p98">在Vue.js
                    2.x中，推荐使用一个空的Vue实例作为中央事件总线（bus），也就是一个中介。为了更形象地了解它，我们举一个生活中的例子。</p>
                <p class="calibre4 pv pid99" id="p99">
                    比如你需要租房子，你可能会找房产中介来登记你的需求，然后中介把你的信息发给满足要求的出租者，出租者再把报价和看房时间告诉中介，由中介再转达给你，整个过程中，买家和卖家并没有任何交流，都是通过中间人来传话的。</p>
                <p class="calibre4 pv pid100" id="p100">
                    或者你最近可能要换房了，你会找房产中介登记你的信息，订阅与你找房需求相关的资讯，一旦有符合你的房子出现时，中介会通知你，并传达你房子的具体信息。</p>
                <p class="calibre4 pv pid101" id="p101">这两个例子中，你和出租者担任的就是两个跨级的组件，而房产中介就是这个中央事件总线（bus）。比如下面的示例代码：</p>
                <pre class="calibre7 pv pid102" id="p102">&lt;div id="app"&gt;
    {{ message }}
    &lt;component-a&gt;&lt;/component-a&gt;
&lt;/div&gt;
&lt;script&gt;
    var bus = new Vue();

    Vue.component('component-a', {
        template: '&lt;button @click="handleEvent"&gt;传递事件&lt;/button&gt;',
        methods: {
            handleEvent: function () {
                bus.$emit('on-message', '来自组件component-a的内容');
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        },
        mounted: function () {
            var _this = this;
            //在实例初始化时，监听来自bus实例的事件
            bus.$on('on-message', function (msg) {
                _this.message = msg;
            });
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid103" id="p103">
                    首先创建了一个名为bus的空Vue实例，里面没有任何内容；然后全局定义了组件component-a；最后创建Vue实例app，在app初始化时，也就是在生命周期mounted钩子函数里监听了来自bus的事件on-message，而在组件component-a中，点击按钮会通过bus把事件on-message发出去，此时app就会接收到来自bus的事件，进而在回调里完成自己的业务逻辑。</p>
                <p class="calibre4 pv pid104" id="p104">这种方法巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级，而且Vue 1.x和Vue
                    2.x都适用。如果深入使用，可以扩展bus实例，给它添加data、methods、computed等选项，这些都是可以公用的，在业务中，尤其是协同开发时非常有用，因为经常需要共享一些通用的信息，比如用户登录的昵称、性别、邮箱等，还有用户的授权token等。只需在初始化时让bus获取一次，任何时间、任何组件就可以从中直接使用了，在单页面富应用（SPA）中会很实用，我们会在进阶篇里逐步介绍这些内容。</p>
                <p class="calibre4 pv pid105" id="p105">当你的项目比较大，有更多的小伙伴参与开发时，也可以选择更好的状态管理解决方案
                    vuex，在进阶篇里会详细介绍关于它的用法。</p>
                <p class="calibre4 pv pid106" id="p106">除了中央事件总线 bus外，还有两种方法可以实现组件间通信：父链和子组件索引。</p>
                <p class="calibre4 pv pid107" id="p107" style="margin: 0px;"><span class="kindle-cn-bold">父链</span></p>
                <p class="calibre4 pv pid107" id="p107">
                    在子组件中，使用this.$parent可以直接访问该组件的父实例或组件，父组件也可以通过this.$children访问它所有的子组件，而且可以递归向上或向下无限访问，直到根实例或最内层的组件。示例代码如下：</p>
                <pre class="calibre7 pv pid108" id="p108">&lt;div id="app"&gt;
    {{ message }}
    &lt;component-a&gt;&lt;/component-a&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('component-a', {
        template: '&lt;button @click="handleEvent"&gt;通过父链直接修改数据&lt;/button&gt;',
        methods: {
            handleEvent: function () {
                // 访问到父链后，可以做任何操作，比如直接修改数据
                this.$parent.message = '来自组件component-a的内容';
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            message: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid109" id="p109">
                    尽管Vue允许这样操作，但在业务中，子组件应该尽可能地避免依赖父组件的数据，更不应该去主动修改它的数据，因为这样使得父子组件紧耦合，只看父组件，很难理解父组件的状态，因为它可能被任意组件修改，理想情况下，只有组件自己能修改它的状态。父子组件最好还是通过props和$emit来通信。</p>
                <p class="calibre4 pv pid110" id="p110" style="margin: 0px;"><span class="kindle-cn-bold">子组件索引</span>
                </p>
                <p class="calibre4 pv pid110" id="p110">
                    当子组件较多时，通过this.$children来一一遍历出我们需要的一个组件实例是比较困难的，尤其是组件动态渲染时，它们的序列是不固定的。Vue提供了子组件索引的方法，用特殊的属性ref来为子组件指定一个索引名称，示例代码如下：</p>
                <pre class="calibre7 pv pid111" id="p111">&lt;div id="app"&gt;
    &lt;button @click="handleRef"&gt;通过ref获取子组件实例&lt;/button&gt;
    &lt;component-a ref="comA"&gt;&lt;/component-a&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('component-a', {
        template: '&lt;div&gt;子组件&lt;/div&gt;',
        data: function () {
            return {
                message: '子组件内容'
            }
        }
    });

    var app = new Vue({
        el: '#app',
        methods: {
            handleRef: function () {
                // 通过$refs来访问指定的实例
                var msg = this.$refs.comA.message;
                console.log(msg);
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid112" id="p112">在父组件模板中，子组件标签上使用ref指定一个名称，并在父组件内通过this.$refs来访问指定名称的子组件。</p>
                <p class="kindle-cn-para-left pv pid113" id="p113">提示</p>
                <p class="kindle-cn-para-no-indent pv pid114" id="p114" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">$refs只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案，应当避免在模板或计算属性中使用$refs。</span>
                </p>
                <p class="calibre4 pv pid114" id="p114">与Vue 1.x不同的是，Vue
                    2.x将v-el和v-ref合并为了ref，Vue会自动去判断是普通标签还是组件。可以尝试补全下面的代码，分别打印出两个ref看看都是什么：</p>
                <pre class="calibre7 pv pid115" id="p115">&lt;div id="app"&gt;
    &lt;p ref="p"&gt;内容&lt;/p&gt;
    &lt;child-component ref="child"&gt;&lt;/child-component&gt;
&lt;/div&gt;</pre>
                <h3 class="kindle-cn-heading2 sigil_toc_id_52 pv pid116" id="p116" name="sigil_toc_id_52">
                    7.4　使用slot分发内容</h3><h4 class="kindle-cn-heading3 sigil_toc_id_53 pv pid117" id="p117"
                                           name="sigil_toc_id_53">7.4.1　什么是slot</h4>
                <p class="calibre4 pv pid118" id="p118">我们先看一个比较常规的网站布局，如图7-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid119" id="p119" style="margin: 0px;"><img alt="097"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/d77c6e4176ab5993.jpg"
                                                                                                           href="./image/00016.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-3　网站布局</p></div>
                <p class="calibre4 pv pid119" id="p119">这个网站由一级导航、二级导航、左侧列表、正文以及底部版权信息5个模块组成，如果要将它们都组件化，这个结构可能会是：</p>
                <pre class="calibre7 pv pid120" id="p120">&lt;app&gt;
    &lt;menu-main&gt;&lt;/menu-main&gt;
    &lt;menu-sub&gt;&lt;/menu-sub&gt;
    &lt;div class="container"&gt;
        &lt;menu-left&gt;&lt;/menu-left&gt;
        &lt;container&gt;&lt;/container&gt;
    &lt;/div&gt;
    &lt;app-footer&gt;&lt;/app-footer&gt;
&lt;/app&gt;</pre>
                <p class="calibre4 pv pid121" id="p121">当需要让组件组合使用，混合父组件的内容与子组件的模板时，就会用到slot，这个过程叫作内容分发（transclusion）。以&lt;app&gt;为例，它有两个特点：</p>
                <ul class="kindle-cn-ul-disc pv pid122" id="p122" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">&lt;app&gt;组件不知道它的挂载点会有什么内容。挂载点的内容是由&lt;app&gt;的父组件决定的。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">&lt;app&gt;组件很可能有它自己的模板。</span></li>
                </ul>
                <p class="calibre4 pv pid122" id="p122">
                    props传递数据、events触发事件和slot内容分发就构成了Vue组件的3个API来源，再复杂的组件也是由这3部分构成的。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_54 pv pid123" id="p123" name="sigil_toc_id_54">
                    7.4.2　作用域</h4>
                <p class="calibre4 pv pid124" id="p124">正式介绍slot前，需要先知道一个概念：编译的作用域。比如父组件中有如下模板：</p>
                <pre class="calibre7 pv pid125" id="p125">&lt;child-component&gt;
    {{ message }}
&lt;/child-component&gt;</pre>
                <p class="calibre4 pv pid126" id="p126">这里的message就是一个slot，但是它绑定的是父组件的数据，而不是组件&lt;child-component&gt;的数据。</p>
                <p class="calibre4 pv pid127" id="p127">父组件模板的内容是在父组件作用域内编译，子组件模板的内容是在子组件作用域内编译。例如下面的代码示例：</p>
                <pre class="calibre7 pv pid128" id="p128">&lt;div id="app"&gt;
    &lt;child-component v-show="showChild"&gt;&lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '&lt;div&gt;子组件&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app',
        data: {
            showChild: true
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid129" id="p129">这里的状态showChild绑定的是父组件的数据，如果想在子组件上绑定，那应该是：</p>
                <pre class="calibre7 pv pid130" id="p130">&lt;div id="app"&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '&lt;div v-show="showChild"&gt;子组件&lt;/div&gt;',
        data: function () {
            return {
                showChild: true
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid131" id="p131">因此，slot分发的内容，作用域是在父组件上的。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_55 pv pid132" id="p132" name="sigil_toc_id_55">
                    7.4.3　slot用法</h4>
                <p class="calibre4 pv pid133" id="p133" style="margin: 0px;"><span class="kindle-cn-bold">单个Slot</span>
                </p>
                <p class="calibre4 pv pid133" id="p133">在子组件内使用特殊的&lt;slot&gt;元素就可以为这个子组件开启一个slot（插槽），在父组件模板里，插入在子组件标签内的所有内容将替代子组件的&lt;slot&gt;
                    标签及它的内容。示例代码如下：</p>
                <pre class="calibre7 pv pid134" id="p134">&lt;div id="app"&gt;
    &lt;child-component&gt;
        &lt;p&gt;分发的内容&lt;/p&gt;
        &lt;p&gt;更多分发的内容&lt;/p&gt;
    &lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '\
        &lt;div&gt;\
            &lt;slot&gt;\
                &lt;p&gt;如果父组件没有插入内容，我将作为默认出现&lt;/p&gt;\
            &lt;/slot&gt;\
        &lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid135" id="p135">子组件child-component的模板内定义了一个&lt;slot&gt;元素，并且用一个&lt;p&gt;作为默认的内容，在父组件没有使用slot时，会渲染这段默认的文本；如果写入了slot，那就会替换整个&lt;slot&gt;。所以上例渲染后的结果为：</p>
                <pre class="calibre7 pv pid136" id="p136">&lt;div id="app"&gt;
    &lt;div&gt;
        &lt;p&gt;分发的内容&lt;/p&gt;
        &lt;p&gt;更多分发的内容&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="kindle-cn-para-left pv pid137" id="p137">提示</p>
                <p class="kindle-cn-para-no-indent pv pid138" id="p138" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">注意，子组件&lt;slot&gt;内的备用内容，它的作用域是子组件本身。</span></p>
                <p class="calibre4 pv pid138" id="p138" style="margin: 0px;"><span class="kindle-cn-bold">具名Slot</span>
                </p>
                <p class="calibre4 pv pid138" id="p138">给&lt;slot&gt;元素指定一个name后可以分发多个内容，具名Slot可以与单个Slot共存，例如下面的示例：</p>
                <pre class="calibre7 pv pid139" id="p139">&lt;div id="app"&gt;
    &lt;child-component&gt;
        &lt;h2 slot="header"&gt;标题&lt;/h2&gt;
        &lt;p&gt;正文内容&lt;/p&gt;
        &lt;p&gt;更多的正文内容&lt;/p&gt;
        &lt;div slot="footer"&gt;底部信息&lt;/div&gt;
    &lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '\
        &lt;div class="container"&gt;\
            &lt;div class="header"&gt;\
                &lt;slot name="header"&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
            &lt;div class="main"&gt;\
                &lt;slot&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
            &lt;div class="footer"&gt;\
                &lt;slot name="footer"&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
        &lt;/div&gt;'
    });
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid140" id="p140">子组件内声明了3个&lt;slot&gt;元素，其中在&lt;div class="main"&gt;内的&lt;slot&gt;
                    没有使用name特性，它将作为默认slot出现，父组件没有使用slot特性的元素与内容都将出现在这里。</p>
                <p class="calibre4 pv pid141" id="p141">如果没有指定默认的匿名slot，父组件内多余的内容片段都将被抛弃。</p>
                <p class="calibre4 pv pid142" id="p142">上例最终渲染后的结果为：</p>
                <pre class="calibre7 pv pid143" id="p143">&lt;div id="app"&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h2&gt;标题&lt;/h2&gt;
        &lt;/div&gt;
        &lt;div class="main"&gt;
            &lt;p&gt;正文内容&lt;/p&gt;
            &lt;p&gt;更多的正文内容&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="footer"&gt;
            &lt;div&gt;底部信息&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid144" id="p144">在组合使用组件时，内容分发API至关重要。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_56 pv pid145" id="p145" name="sigil_toc_id_56">
                    7.4.4　作用域插槽</h4>
                <p class="calibre4 pv pid146" id="p146">
                    作用域插槽是一种特殊的slot，使用一个可以复用的模板替换已渲染元素。概念比较难理解，我们先看一个简单的示例来了解它的基本用法。示例代码如下：</p>
                <pre class="calibre7 pv pid147" id="p147">&lt;div id="app"&gt;
    &lt;child-component&gt;
        &lt;template scope="props"&gt;
            &lt;p&gt;来自父组件的内容&lt;/p&gt;
            &lt;p&gt;{{ props.msg }}&lt;/p&gt;
        &lt;/template&gt;
    &lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '\
        &lt;div class="container"&gt;\
            &lt;slot msg="来自子组件的内容"&gt;&lt;/slot&gt;\
        &lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid148" id="p148">观察子组件的模板，在&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg="xxx"，将数据传到了插槽。父组件中使用了&lt;template&gt;元素，而且拥有一个scope="props"的特性，这里的props
                    只是一个临时变量，就像v-for="item in items"里面的item一样。template内可以通过临时变量 props 访问来自子组件插槽的数据msg。</p>
                <p class="calibre4 pv pid149" id="p149">将上面的示例渲染后的最终结果为：</p>
                <pre class="calibre7 pv pid150" id="p150">&lt;div id="app"&gt;
    &lt;div class="container"&gt;
        &lt;p&gt;来组父组件的内容&lt;/p&gt;
        &lt;p&gt;来自子组件的内容&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid151" id="p151">作用域插槽更具代表性的用例是列表组件，允许组件自定义应该如何渲染列表每一项。示例代码如下：</p>
                <pre class="calibre7 pv pid152" id="p152">&lt;div id="app"&gt;
    &lt;my-list :books="books"&gt;
        &lt;!-- 作用域插槽也可以是具名的Slot --&gt;
        &lt;template slot="book" scope="props"&gt;
            &lt;li&gt;{{ props.bookName }}&lt;/li&gt;
        &lt;/template&gt;
    &lt;/my-list&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-list', {
        props: {
            books: {
                type: Array,
                default: function () {
                    return [];
                }
            }
        },
        template: '\
        &lt;ul&gt;\
            &lt;slot name="book"\
                v-for="book in books"\
                :book-name="book.name"&gt;\
                &lt;!-- 这里也可以写默认 slot内容 --&gt;\
            &lt;/slot&gt;\
        &lt;/ul&gt;'
    });

    var app = new Vue({
        el: '#app',
        data: {
            books: [
                { name: '《Vue.js实战》' },
                { name: '《JavaScript语言精粹》' },
                { name: '《JavaScript高级程序设计》' }
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid153" id="p153">
                    子组件my-list接收一个来自父级的prop数组books，并且将它在name为book的slot上使用v-for指令循环，同时暴露一个变量bookName。</p>
                <p class="calibre4 pv pid154" id="p154">
                    如果你仔细揣摩上面的用法，你可能会产生这样的疑问：我直接在父组件用v-for不就好了吗，为什么还要绕一步，在子组件里面循环呢？的确，如果只是针对上面的示例，这样写是多此一举的。此例的用意主要是介绍作用域插槽的用法，并没有加入使用场景，而作用域插槽的使用场景就是既可以复用子组件的slot，又可以使
                    slot内容不一致。如果上例还在其他组件内使用，&lt;li&gt;的内容渲染权是由使用者掌握的，而数据却可以通过临时变量（比如props）从子组件内获取。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_57 pv pid155" id="p155" name="sigil_toc_id_57">
                    7.4.5　访问slot</h4>
                <p class="calibre4 pv pid156" id="p156">在Vue.js 1.x中，想要获取某个slot是比较麻烦的，需要用v-el间接获取。而Vue.js
                    2.x提供了用来访问被slot分发的内容的方法 $slots，请看下面的示例：</p>
                <pre class="calibre7 pv pid157" id="p157">&lt;div id="app"&gt;
    &lt;child-component&gt;
        &lt;h2 slot="header"&gt;标题&lt;/h2&gt;
        &lt;p&gt;正文内容&lt;/p&gt;
        &lt;p&gt;更多的正文内容&lt;/p&gt;
        &lt;div slot="footer"&gt;底部信息&lt;/div&gt;
    &lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        template: '\
        &lt;div class="container"&gt;\
            &lt;div class="header"&gt;\
                &lt;slot name="header"&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
            &lt;div class="main"&gt;\
                &lt;slot&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
            &lt;div class="footer"&gt;\
                &lt;slot name="footer"&gt;&lt;/slot&gt;\
            &lt;/div&gt;\
        &lt;/div&gt;',
        mounted: function () {
            var header = this.$slots.header;
            var main = this.$slots.default;
            var footer = this.$slots.footer;
            console.log(footer);
            console.log(footer[0].elm.innerHTML);
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid158" id="p158">
                    通过$slots可以访问某个具名slot，this.$slots.default包括了所有没有被包含在具名slot中的节点。尝试编写代码，查看两个console 打印的内容。</p>
                <pre class="calibre7 pv pid159"
                     id="p159">$slots在业务中几乎用不到，在用render函数（进阶篇中将介绍）创建组件时会比较有用，但主要还是用于独立组件开发中。</pre>
                <h3 class="kindle-cn-heading2 sigil_toc_id_58 pv pid160" id="p160" name="sigil_toc_id_58">
                    7.5　组件高级用法</h3>
                <p class="calibre4 pv pid161" id="p161">
                    本节会介绍组件的一些高级用法，这些用法在实际业务中不是很常用，但在独立组件开发时可能会用到。如果你感觉以上内容已经足够完成你的业务开发了，可以跳过本节；如果你想继续探索
                    Vue组件的奥秘，读完本节会对你有很大的启发。</p><h4 class="kindle-cn-heading3 sigil_toc_id_59 pv pid162" id="p162"
                                                   name="sigil_toc_id_59">7.5.1　递归组件</h4>
                <p class="calibre4 pv pid163" id="p163">组件在它的模板内可以递归地调用自己，只要给组件设置name的选项就可以了。示例代码如下：</p>
                <pre class="calibre7 pv pid164" id="p164">&lt;div id="app"&gt;
    &lt;child-component :count="1"&gt;&lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        name: 'child-component',
        props: {
            count: {
                type: Number,
                default: 1
            }
        },
        template: '\
        &lt;div class="child"&gt;\
            &lt;child-component\
                :count="count + 1"\
                v-if="count &lt; 3"&gt;&lt;/child-component&gt;\
        &lt;/div&gt;',
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid165" id="p165">设置name后，在组件模板内就可以递归使用了，不过需要注意的是，必须给一个条件来限制递归数量，否则会抛出错误：max stack
                    size exceeded。</p>
                <p class="calibre4 pv pid166" id="p166">组件递归使用可以用来开发一些具有未知层级关系的独立组件，比如级联选择器和树形控件等，如图7-4和图7-5所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid167" id="p167" style="margin: 0px;"><img alt="105"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/6b0373267c9c7aa7.jpg"
                                                                                                           href="./image/00017.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-4　级联选择器</p></div>
                <div class="kindle-cn-bodycontent-div-alone pv pid167" id="p167" style="margin: 0px;"><img alt="106"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/43c2b673da304ac3.jpg"
                                                                                                           href="./image/00018.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-5　树形控件</p></div>
                <p class="calibre4 pv pid167" id="p167">在实战篇里，我们会详细介绍级联选择器的实现。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_60 pv pid168" id="p168" name="sigil_toc_id_60">
                    7.5.2　内联模板</h4>
                <p class="calibre4 pv pid169" id="p169">
                    组件的模板一般都是在template选项内定义的，Vue提供了一个内联模板的功能，在使用组件时，给组件标签使用inline-template特性，组件就会把它的内容当作模板，而不是把它当内容分发，这让模板更灵活。示例代码如下：</p>
                <pre class="calibre7 pv pid170" id="p170">&lt;div id="app"&gt;
    &lt;child-component inline-template&gt;
        &lt;div&gt;
            &lt;h2&gt;在父组件中定义子组件的模板&lt;/h2&gt;
            &lt;p&gt;{{ message }}&lt;/p&gt;
            &lt;p&gt;{{ msg }}&lt;/p&gt;
        &lt;/div&gt;
    &lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', {
        data: function () {
            return {
                msg: '在子组件声明的数据'
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            message: '在父组件声明的数据'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid171" id="p171">渲染后的结果为：</p>
                <pre class="calibre7 pv pid172" id="p172">&lt;div id="app"&gt;
    &lt;div&gt;
        &lt;h2&gt;在父组件中定义子组件的模板&lt;/h2&gt;
        &lt;p&gt;在父组件声明的数据&lt;/p&gt;
        &lt;p&gt;在子组件声明的数据&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid173" id="p173">
                    在父组件中声明的数据message和子组件中声明的数据msg，两个都可以渲染（如果同名，优先使用子组件的数据）。这反而是内联模板的缺点，就是作用域比较难理解，如果不是非常特殊的场景，建议不要轻易使用内联模板。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_61 pv pid174" id="p174" name="sigil_toc_id_61">
                    7.5.3　动态组件</h4>
                <p class="calibre4 pv pid175" id="p175">Vue.js提供了一个特殊的元素&lt;component&gt;用来动态地挂载不同的组件，使用is特性来选择要挂载的组件。示例代码如下：</p>
                <pre class="calibre7 pv pid176" id="p176">&lt;div id="app"&gt;
    &lt;component :is="currentView"&gt;&lt;/component&gt;
    &lt;button @click="handleChangeView('A')"&gt;切换到A&lt;/button&gt;
    &lt;button @click="handleChangeView('B')"&gt;切换到B&lt;/button&gt;
    &lt;button @click="handleChangeView('C')"&gt;切换到C&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        components: {
            comA: {
                template: '&lt;div&gt;组件A&lt;/div&gt;'
            },
            comB: {
                template: '&lt;div&gt;组件B&lt;/div&gt;'
            },
            comC: {
                template: '&lt;div&gt;组件C&lt;/div&gt;'
            }
        },
        data: {
            currentView: 'comA'
        },
        methods: {
            handleChangeView: function (component) {
                this.currentView = 'com' + component;
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid177" id="p177">动态地改变currentView的值就可以动态挂载组件了。也可以直接绑定在组件对象上：</p>
                <pre class="calibre7 pv pid178" id="p178">&lt;div id="app"&gt;
    &lt;component :is="currentView"&gt;&lt;/component&gt;
&lt;/div&gt;
&lt;script&gt;
    var Home = {
        template: '&lt;p&gt;Welcome home!&lt;/p&gt;'
    };
    var app = new Vue({
        el: '#app',
        data: {
            currentView: Home
        }
    })
&lt;/script&gt;</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_62 pv pid179" id="p179" name="sigil_toc_id_62">
                    7.5.4　异步组件</h4>
                <p class="calibre4 pv pid180" id="p180">
                    当你的工程足够大，使用的组件足够多时，是时候考虑下性能问题了，因为一开始把所有的组件都加载是没必要的一笔开销。好在Vue.js允许将组件定义为一个工厂函数，动态地解析组件。Vue.js只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如下面的示例：</p>
                <pre class="calibre7 pv pid181" id="p181">&lt;div id="app"&gt;
    &lt;child-component&gt;&lt;/child-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('child-component', function (resolve, reject) {
        window.setTimeout(function () {
            resolve({
                template: '&lt;div&gt;我是异步渲染的&lt;/div&gt;'
            });
        }, 2000);
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid182" id="p182">
                    工厂函数接收一个resolve回调，在收到从服务器下载的组件定义时调用。也可以调用reject(reason)指示加载失败。这里setTimeout只是为了演示异步，具体的下载逻辑可以自己决定，比如把组件配置写成一个对象配置，通过Ajax来请求，然后调用resolve传入配置选项。</p>
                <p class="calibre4 pv pid183" id="p183">在进阶篇里，我们还会介绍主流的打包编译工具webpack和.vue单文件的用法，更优雅地实现异步组件（路由）。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_63 pv pid184" id="p184" name="sigil_toc_id_63">7.6　其他</h3><h4
                        class="kindle-cn-heading3 sigil_toc_id_64 pv pid185" id="p185" name="sigil_toc_id_64">
                    7.6.1　$nextTick</h4>
                <p class="calibre4 pv pid186" id="p186">
                    我们先来看这样一个场景：有一个div，默认用v-if将它隐藏，点击一个按钮后，改变v-if的值，让它显示出来，同时拿到这个div的文本内容。如果v-if的值是false，直接去获取div的内容是获取不到的，因为此时
                    div还没有被创建出来，那么应该在点击按钮后，改变v-if的值为true，div才会被创建，此时再去获取，示例代码如下：</p>
                <pre class="calibre7 pv pid187" id="p187">&lt;div id="app"&gt;
    &lt;div id="div" v-if="showDiv"&gt;这是一段文本&lt;/div&gt;
    &lt;button @click="getText"&gt;获取 div内容&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            showDiv: false
        },
        methods: {
            getText: function () {
                this.showDiv = true;
                var text = document.getElementById('div').innerHTML;
                console.log(text);
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid188" id="p188">这段代码并不难理解，但是运行后在控制台会抛出一个错误：Cannot read property 'innerHTML' of
                    null，意思就是获取不到div元素。这里就涉及Vue一个重要的概念：异步更新队列。</p>
                <p class="calibre4 pv pid189" id="p189">
                    Vue在观察到数据变化时并不是直接更新DOM，而是开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。在缓冲时会去除重复数据，从而避免不必要的计算和DOM操作。然后，在下一个事件循环tick中，Vue刷新队列并执行实际（已去重的）工作。所以如果你用一个for循环来动态改变数据100次，其实它只会应用最后一次改变，如果没有这种机制，DOM就要重绘100次，这固然是一个很大的开销。</p>
                <p class="calibre4 pv pid190" id="p190">
                    Vue会根据当前浏览器环境优先使用原生的Promise.then和MutationObserver，如果都不支持，就会采用setTimeout 代替。</p>
                <p class="calibre4 pv pid191" id="p191">知道了Vue异步更新DOM的原理，上面示例的报错也就不难理解了。事实上，在执行this.showDiv =
                    true;时，div仍然还是没有被创建出来，直到下一个Vue事件循环时，才开始创建。$nextTick就是用来知道什么时候DOM更新完成的，所以上面的示例代码需要修改为：</p>
                <pre class="calibre7 pv pid192" id="p192">&lt;div id="app"&gt;
    &lt;div id="div" v-if="showDiv"&gt;这是一段文本&lt;/div&gt;
    &lt;button @click="getText"&gt;获取 div内容&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    var app = new Vue({
        el: '#app',
        data: {
            showDiv: false
        },
        methods: {
            getText: function () {
                this.showDiv = true;
                this.$nextTick(function () {
                    var text = document.getElementById('div').innerHTML;
                    console.log(text);
                });
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid193" id="p193">这时再点击按钮，控制台就打印出div的内容“这是一段文本”了。</p>
                <p class="calibre4 pv pid194" id="p194">
                    理论上，我们应该不用去主动操作DOM，因为Vue的核心思想就是数据驱动DOM，但在很多业务里，我们避免不了会使用一些第三方库，比如popper.js（https://popper.js.org/）、swiper（http://idangero.us/swiper/）等，这些基于原生JavaScript的库都有创建和更新及销毁的完整生命周期，与Vue
                    配合使用时，就要利用好$nextTick 。</p><h4 class="kindle-cn-heading3 sigil_toc_id_65 pv pid195" id="p195"
                                                  name="sigil_toc_id_65">7.6.2　X-Templates</h4>
                <p class="calibre4 pv pid196" id="p196">
                    如果你没有使用webpack、gulp等工具，试想一下你的组件template的内容很冗长、复杂，如果都在JavaScript里拼接字符串，效率是很低的，因为不能像写HTML
                    那样舒服。Vue提供了另一种定义模板的方式，在&lt;script&gt; 标签里使用text/x-template类型，并且指定一个id，将这个id赋给template。示例代码如下：</p>
                <pre class="calibre7 pv pid197" id="p197">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;script type="text/x-template" id="my-component"&gt;
        &lt;div&gt;这是组件的内容&lt;/div&gt;
    &lt;/script&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '#my-component'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid198" id="p198">在&lt;script&gt; 标签里，你可以愉快地写HTML代码，不用考虑换行等问题。</p>
                <p class="calibre4 pv pid199" id="p199">
                    很多刚接触Vue开发的新手会非常喜欢这个功能，因为用它，再加上组件知识，就可以很轻松地完成交互相对复杂的页面和应用了。如果再配合一些构建工具（gulp）组织好代码结构，开发一些中小型产品是没有问题的。不过，Vue的初衷并不是滥用它，因为它将模板和组件的其他定义隔离了。在进阶篇里，我们会介绍如何使用webpack来编译
                    .vue的单文件，从而优雅地解决 HTML 书写的问题。</p><h4 class="kindle-cn-heading3 sigil_toc_id_66 pv pid200" id="p200"
                                                        name="sigil_toc_id_66">7.6.3　手动挂载实例</h4>
                <p class="calibre4 pv pid201" id="p201">我们现在所创建的实例都是通过new
                    Vue()的形式创建出来的。在一些非常特殊的情况下，我们需要动态地去创建Vue实例，Vue提供了Vue.extend和$mount 两个方法来手动挂载一个实例。</p>
                <p class="calibre4 pv pid202" id="p202">Vue.extend是基础Vue构造器，创建一个“子类”，参数是一个包含组件选项的对象。</p>
                <p class="calibre4 pv pid203" id="p203">
                    如果Vue实例在实例化时没有收到el选项，它就处于“未挂载”状态，没有关联的DOM元素。可以使用$mount()手动地挂载一个未挂载的实例。这个方法返回实例自身，因而可以链式调用其他实例方法。示例代码如下：</p>
                <pre class="calibre7 pv pid204" id="p204">&lt;div id="mount-div"&gt;

&lt;/div&gt;
&lt;script&gt;
    var MyComponent = Vue.extend({
        template: '&lt;div&gt;Hello: {{ name }}&lt;/div&gt;',
        data: function () {
            return {
                name: 'Aresn'
            }
        }
    });

    new MyComponent().$mount('#mount-div');
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid205" id="p205">运行后，id为mount-div的div元素会被替换为组件MyComponent的template的内容：</p>
                <pre class="calibre7 pv pid206" id="p206">&lt;div&gt;Hello: Aresn&lt;/div&gt;</pre>
                <p class="calibre4 pv pid207" id="p207">除了这种写法外，以下两种写法也是可以的：</p>
                <pre class="calibre7 pv pid208" id="p208">new MyComponent().$mount('#mount-div');
// 同上
new MyComponent({
    el: '#mount-div'
});
//或者，在文档之外渲染并且随后挂载
var component = new MyComponent().$mount();
document.getElementById(‘mount-div').appendChild(component.$el);</pre>
                <p class="calibre4 pv pid209" id="p209">
                    手动挂载实例（组件）是一种比较极端的高级用法，在业务中几乎用不到，只在开发一些复杂的独立组件时可能会使用，所以只做了解就好。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_67 pv pid210" id="p210" name="sigil_toc_id_67">
                    7.7　实战：两个常用组件的开发</h3>
                <p class="calibre4 pv pid211" id="p211">本节以组件知识为基础，整合指令、事件等前面章节的内容，开发两个业务中常用的组件，即数字输入框和标签页。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_68 pv pid212" id="p212" name="sigil_toc_id_68">
                    7.7.1　开发一个数字输入框组件</h4>
                <p class="calibre4 pv pid213" id="p213">数字输入框是对普通输入框的扩展，用来快捷输入一个标准的数字，如图7-6所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid214" id="p214" style="margin: 0px;"><img alt="112"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/26daf6bed812cdfc.jpg"
                                                                                                           href="./image/00019.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-6　数字输入框</p></div>
                <p class="calibre4 pv pid214" id="p214">数字输入框只能输入数字，而且有两个快捷按钮，可以直接减
                    1或加1。除此之外，还可以设置初始值、最大值、最小值，在数值改变时，触发一个自定义事件来通知父组件。</p>
                <p class="calibre4 pv pid215" id="p215">了解了基本需求后，我们先定义目录文件：</p>
                <ul class="kindle-cn-ul-disc pv pid216" id="p216" style="margin: 0px;">
                    <li class="calibre6">index.html　<span class="kindle-cn-specialtext-kaiti">入口页</span></li>
                    <li class="calibre6">input-number.js　<span class="kindle-cn-specialtext-kaiti">数字输入框组件</span></li>
                    <li class="calibre6">index.js　<span class="kindle-cn-specialtext-kaiti">根实例</span></li>
                </ul>
                <p class="calibre4 pv pid216" id="p216">因为该示例是以交互功能为主，所以就不写CSS美化样式了。</p>
                <p class="calibre4 pv pid217" id="p217">首先写入基本的结构代码，初始化项目。</p>
                <p class="calibre4 pv pid218" id="p218" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid218" id="p218">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;数字输入框组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;

    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="input-number.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid219" id="p219" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid219" id="p219">var app = new Vue({
    el: '#app'
});</pre>
                <p class="calibre4 pv pid220" id="p220" style="margin: 0px;"><span class="kindle-cn-bold">input-number.js：</span>
                </p>
                <pre class="calibre7 pv pid220" id="p220">Vue.component('input-number', {
    template: '\
        &lt;div class="input-number"&gt; \
            \
        &lt;/div&gt;',
    props: {
        max: {
            type: Number,
            default: Infinity
        },
        min: {
            type: Number,
            default: -Infinity
        },
        value: {
            type: Number,
            default: 0
        }
    }
});</pre>
                <p class="calibre4 pv pid221" id="p221">
                    该示例的主角是input-number.js，所有的组件配置都在这里面定义。先在template里定义了组件的根节点，因为是独立组件，所以应该对每个prop进行校验。这里根据需求有最大值、最小值、默认值（也就是绑定值）3个prop，max和min都是数字类型，默认值是正无限大和负无限大；value也是数字类型，默认值是0。</p>
                <p class="calibre4 pv pid222" id="p222">接下来，我们先在父组件引入input-number组件，并给它一个默认值5，最大值10，最小值0。</p>
                <p class="calibre4 pv pid223" id="p223" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid223" id="p223">var app = new Vue({
    el: '#app',
    data: {
        value: 5
    }
});</pre>
                <p class="calibre4 pv pid224" id="p224" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid224" id="p224">&lt;div id="app"&gt;
    &lt;input-number v-model="value" :max="10" :min="0"&gt;&lt;/input-number&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid225" id="p225">
                    value是一个关键的绑定值，所以用了v-model，这样既优雅地实现了双向绑定，也让API看起来很合理。大多数的表单类组件都应该有一个v-model，比如输入框、单选框、多选框、下拉选择器等。</p>
                <p class="calibre4 pv pid226" id="p226">剩余的代码量就都聚焦到了input-number.js上。</p>
                <p class="calibre4 pv pid227" id="p227">我们之前介绍过，Vue组件是单向数据流，所以无法从组件内部直接修改prop
                    value的值。解决办法也介绍过，就是给组件声明一个data，默认引用value的值，然后在组件内部维护这个data：</p>
                <pre class="calibre7 pv pid228" id="p228">Vue.component('input-number', {
    // ...
    data: function () {
        return {
            currentValue: this.value
        }
    }
})</pre>
                <p class="calibre4 pv pid229" id="p229">
                    这样只解决了初始化时引用父组件value的问题，但是如果从父组件修改了value，input-number组件的currentValue也要一起更新。为了实现这个功能，我们需要用到一个新的概念：监听（watch）。watch选项用来监听某个prop或data的改变，当它们发生变化时，就会触发watch配置的函数，从而完成我们的业务逻辑。在本例中，我们要监听两个量：value和currentValue。监听value是要知晓从父组件修改了value，监听currentValue是为了当currentValue
                    改变时，更新value。相关代码如下：</p>
                <pre class="calibre7 pv pid230" id="p230">Vue.component('input-number', {
    // ...
    data: function () {
        return {
            currentValue: this.value
        }
    },
    watch: {
        currentValue: function (val) {
            this.$emit('input', val);
            this.$emit('on-change', val);
        },
        value: function (val) {
            this.updateValue(val);
        }
    },
    methods: {
        updateValue: function (val) {
            if (val &gt; this.max) val = this.max;
            if (val &lt; this.min) val = this.min;
            this.currentValue = val;
        }
    },
    mounted: function () {
        this.updateValue(this.value);
    }
})</pre>
                <p class="calibre4 pv pid231" id="p231">
                    从父组件传递过来的value有可能是不符合当前条件的（大于max，或小于min），所以在选项methods里写了一个方法updateValue，用来过滤出一个正确的currentValue。</p>
                <p class="calibre4 pv pid232" id="p232">
                    watch监听的数据的回调函数有2个参数可用，第一个是新的值，第二个是旧的值，这里没有太复杂的逻辑，就只用了第一个参数。在回调函数里，this是指向当前组件实例的，所以可以直接调用this.updateValue()
                    ，因为Vue 代理了props、data 、computed及methods。</p>
                <p class="calibre4 pv pid233" id="p233">监听currentValue的回调里，this.$emit('input',
                    val)是在使用v-model时改变value的；this.$emit('on-change',
                    val)是触发自定义事件on-change，用于告知父组件数字输入框的值有所改变（示例中没有使用该事件）。</p>
                <p class="calibre4 pv pid234" id="p234">在生命周期mounted钩子里也调用了updateValue()方法，是因为第一次初始化时，也对value
                    进行了过滤。这里也有另一种写法，在data选项返回对象前进行过滤：</p>
                <pre class="calibre7 pv pid235" id="p235">Vue.component('input-number', {
    // ...
    data: function () {
        var val = this.value;
        if (val &gt; this.max) val = this.max;
        if (val &lt; this.min) val = this.min;

        return {
            currentValue: val
        }
    }
});</pre>
                <p class="calibre4 pv pid236" id="p236">实现的效果是一样的。</p>
                <p class="calibre4 pv pid237" id="p237">最后剩余的就是补全模板template，内容是一个输入框和两个按钮，相关代码如下：</p>
                <pre class="calibre7 pv pid238" id="p238">function isValueNumber (value) {
    return (/(^-?[0-9]+\.{1}\d+$)|(^-?[1-9][0-9]*$)|(^-?0{1}$)/).test(value + '');
}

Vue.component('input-number', {
    // ...
    template: '\
        &lt;div class="input-number"&gt; \
            &lt;input \
                type="text" \
                :value="currentValue" \
                @change="handleChange"&gt; \
            &lt;button \
                @click="handleDown" \
                :disabled="currentValue &lt;= min"&gt;-&lt;/button&gt; \
            &lt;button \
                @click="handleUp" \
                :disabled="currentValue &gt;= max"&gt;+&lt;/button&gt; \
        &lt;/div&gt;',
    methods: {
        handleDown: function () {
            if (this.currentValue &lt;= this.min) return;
            this.currentValue -= 1;
        },
        handleUp: function () {
            if (this.currentValue &gt;= this.max) return;
            this.currentValue += 1;
        },
        handleChange: function (event) {
            var val = event.target.value.trim();

            var max = this.max;
            var min = this.min;

            if (isValueNumber(val)) {
                val = Number(val);
                this.currentValue = val;

                if (val &gt; max) {
                    this.currentValue = max;
                } else if (val &lt; min) {
                    this.currentValue = min;
                }
            } else {
                event.target.value = this.currentValue;
            }
        }
    }
});</pre>
                <p class="calibre4 pv pid239" id="p239">
                    input绑定了数据currentValue和原生的change事件，在句柄handleChange函数中，判断了当前输入的是否是数字。注意，这里绑定的currentValue也是单向数据流，并没有用v-model，所以在输入时，currentValue的值并没有实时改变。如果输入的不是数字（比如英文和汉字等），就将输入的内容重置为之前的currentValue。如果输入的是符合要求的数字，就把输入的值赋给currentValue。</p>
                <p class="calibre4 pv pid240" id="p240">
                    数字输入框组件的核心逻辑就是这些。回顾一下我们设计一个通用组件的思路，首先，在写代码前一定要明确需求，然后规划好API。一个Vue组件的API只来自props、events和slots，确定好这3部分的命名、规则，剩下的逻辑即使第一版没有做好，后续也可以迭代完善。但是API如果没有设计好，后续再改对使用者成本就很大了。</p>
                <p class="calibre4 pv pid241" id="p241">完整的示例代码如下：</p>
                <p class="calibre4 pv pid242" id="p242" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html</span></p>
                <pre class="calibre7 pv pid242" id="p242">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;数字输入框组件&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;input-number v-model="value" :max="10" :min="0"&gt;&lt;/input-number&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="input-number.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid243" id="p243" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js</span></p>
                <pre class="calibre7 pv pid243" id="p243">var app = new Vue({
    el: '#app',
    data: {
        value: 5
    }
});</pre>
                <p class="calibre4 pv pid244" id="p244" style="margin: 0px;"><span class="kindle-cn-bold">input-number.js</span>
                </p>
                <pre class="calibre7 pv pid244" id="p244">function isValueNumber (value) {
    return (/(^-?[0-9]+\.{1}\d+$)|(^-?[1-9][0-9]*$)|(^-?0{1}$)/).test(value + '');
}

Vue.component('input-number', {
    template: '\
        &lt;div class="input-number"&gt; \
            &lt;input \
                type="text" \
                :value="currentValue" \
                @change="handleChange"&gt; \
            &lt;button \
                @click="handleDown" \
                :disabled="currentValue &lt;= min"&gt;-&lt;/button&gt; \
            &lt;button \
                @click="handleUp" \
                :disabled="currentValue &gt;= max"&gt;+&lt;/button&gt; \
        &lt;/div&gt;',
    props: {
        max: {
            type: Number,
            default: Infinity
        },
        min: {
            type: Number,
            default: -Infinity
        },
        value: {
            type: Number,
            default: 0
        }
    },
    data: function () {
        return {
            currentValue: this.value
        }
    },
    watch: {
        currentValue: function (val) {
            this.$emit('input', val);
            this.$emit('on-change', val);
        },
        value: function (val) {
            this.updateValue(val);
        }
    },
    methods: {
        handleDown: function () {
            if (this.currentValue &lt;= this.min) return;
            this.currentValue -= 1;
        },
        handleUp: function () {
            if (this.currentValue &gt;= this.max) return;
            this.currentValue += 1;
        },
        updateValue: function (val) {
            if (val &gt; this.max) val = this.max;
            if (val &lt; this.min) val = this.min;
            this.currentValue = val;
        },
        handleChange: function (event) {
            var val = event.target.value.trim();

            var max = this.max;
            var min = this.min;

            if (isValueNumber(val)) {
                val = Number(val);
                this.currentValue = val;

                if (val &gt; max) {
                    this.currentValue = max;
                } else if (val &lt; min) {
                    this.currentValue = min;
                }
            } else {
                event.target.value = this.currentValue;
            }
        }
    },
    mounted: function () {
        this.updateValue(this.value);
    }
});</pre>
                <p class="calibre4 pv pid245" id="p245" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>在输入框聚焦时，增加对键盘上下按键的支持，相当于加1和减1。
                </p>
                <p class="calibre4 pv pid245" id="p245" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>增加一个控制步伐的prop
                    — step，比如设置为10，点击加号按钮，一次增加10。</p><h4 class="kindle-cn-heading3 sigil_toc_id_69 pv pid245" id="p245"
                                                         name="sigil_toc_id_69">7.7.2　开发一个标签页组件</h4>
                <p class="calibre4 pv pid246" id="p246">
                    本小节将开发一个比较有挑战的组件：标签页组件。标签页（即选项卡切换组件）是网页布局中经常用到的元素，常用于平级区域大块内容的收纳和展现，如图7-7所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid247" id="p247" style="margin: 0px;"><img alt="120"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/feada67912f53289.jpg"
                                                                                                           href="./image/00020.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-7　标签页</p></div>
                <p class="calibre4 pv pid247" id="p247">根据上个示例的经验，我们先分析业务需求，制定出 API，这样不至于一上来就无从下手。</p>
                <p class="calibre4 pv pid248" id="p248">
                    每个标签页的主体内容肯定是由使用组件的父级控制的，所以这部分是一个slot，而且slot的数量决定了标签切换按钮的数量。假设我们有3个标签页，点击每个标签按钮时，另外的两个标签对应的slot应该被隐藏掉。一般这个时候，比较容易想到的解决办法是，在slot里写3个div，在接收到切换通知时，显示和隐藏相关的div。这样设计没有问题，只不过体现不出组件的价值来，因为我们还是写了一些与业务无关的交互逻辑，而这部分逻辑最好组件本身帮忙处理了，我们只用聚焦在slot内容本身，这才是与我们业务最相关的。这种情况下，我们再定义一个子组件pane，嵌套在标签页组件tabs里，我们的业务代码都放在pane的slot内，而3个pane组件作为整体成为tabs的slot。</p>
                <p class="calibre4 pv pid249" id="p249">
                    由于tabs和pane两个组件是分离的，但是tabs组件上的标题应该由pane组件来定义，因为slot是写在pane里，因此在组件初始化（及标签标题动态改变）时，tabs要从pane里获取标题，并保存起来，自己使用。</p>
                <p class="calibre4 pv pid250" id="p250">确定好了结构，我们先创建所需的文件：</p>
                <ul class="kindle-cn-ul-disc pv pid251" id="p251" style="margin: 0px;">
                    <li class="calibre6">index.html　<span class="kindle-cn-specialtext-kaiti">入口页</span></li>
                    <li class="calibre6">style.css　<span class="kindle-cn-specialtext-kaiti">样式表</span></li>
                    <li class="calibre6">tabs.js　<span class="kindle-cn-specialtext-kaiti">标签页外层的组件tabs</span></li>
                    <li class="calibre6">pane.js　<span class="kindle-cn-specialtext-kaiti">标签页嵌套的组件pane</span></li>
                </ul>
                <p class="calibre4 pv pid251" id="p251">先初始化各个文件。</p>
                <p class="calibre4 pv pid252" id="p252" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid252" id="p252">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;标签页组件&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;

    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="pane.js"&gt;&lt;/script&gt;
    &lt;script src="tabs.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        var app = new Vue({
            el: '#app'
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid253" id="p253" style="margin: 0px;"><span
                        class="kindle-cn-bold">tabs.js：</span></p>
                <pre class="calibre7 pv pid253" id="p253">Vue.component('tabs', {
    template: '\
        &lt;div class="tabs"&gt; \
            &lt;div class="tabs-bar"&gt; \
                &lt;!-- 标签页标题，这里要用v-for --&gt; \
            &lt;/div&gt; \
            &lt;div class="tabs-content"&gt; \
                &lt;!-- 这里的slot就是嵌套的pane --&gt; \
                &lt;slot&gt;&lt;/slot&gt; \
            &lt;/div&gt; \
        &lt;/div&gt;'
})</pre>
                <p class="calibre4 pv pid254" id="p254" style="margin: 0px;"><span
                        class="kindle-cn-bold">pane.js：</span></p>
                <pre class="calibre7 pv pid254" id="p254">Vue.component('pane', {
    name: 'pane',
    template: '\
        &lt;div class="pane"&gt; \
            &lt;slot&gt;&lt;/slot&gt; \
        &lt;/div&gt;'
})</pre>
                <p class="calibre4 pv pid255" id="p255">pane需要控制标签页内容的显示与隐藏，设置一个data：show，并且用v-show指令来控制元素：</p>
                <pre class="calibre7 pv pid256" id="p256">template: '\
    &lt;div class="pane" v-show="show"&gt; \
        &lt;slot&gt;&lt;/slot&gt; \
    &lt;/div&gt;',
data: function () {
    return {
        show: true
    }
}</pre>
                <p class="calibre4 pv pid257" id="p257">
                    当点击到这个pane对应的标签页标题按钮时，此pane的show值设置为true，否则应该是false，这步操作是在tabs组件完成的，我们稍后再介绍。</p>
                <p class="calibre4 pv pid258" id="p258">
                    既然要点击对应的标签页标题按钮，那应该有一个唯一的值来标识这个pane，我们可以设置一个prop：name让用户来设置，但它不是必需的，如果使用者不设置，可以默认从0开始自动设置，这步操作仍然是tabs
                    执行的，因为pane本身并不知道自己是第几个。除了name，还需要标签页标题的prop：label，tabs组件需要将它显示在标签页标题里。这部分代码如下：</p>
                <pre class="calibre7 pv pid259" id="p259">props: {
    name: {
        type: String
    },
    label: {
        type: String,
        default: ''
    }
}</pre>
                <p class="calibre4 pv pid260" id="p260">
                    上面的prop：label用户是可以动态调整的，所以在pane初始化及label更新时，都要通知父组件也更新，因为是独立组件，所以不能依赖像bus.js或vuex这样的状态管理办法，我们可以直接通过this.$parent访问tabs组件的实例来调用它的方法更新标题，该方法名暂定为updateNav。注意，在业务中尽可能不要使用$parent来操作父链，这种方法适合于标签页这样的独立组件。这部分代码如下：</p>
                <pre class="calibre7 pv pid261" id="p261">methods: {
    updateNav () {
        this.$parent.updateNav();
    }
},
watch: {
    label () {
        this.updateNav();
    }
},
mounted () {
    this.updateNav();
}</pre>
                <p class="calibre4 pv pid262" id="p262">
                    在生命周期mounted，也就是pane初始化时，调用一遍tabs的updateNav方法，同时监听了prop：label，在label更新时，同样调用。</p>
                <p class="calibre4 pv pid263" id="p263">剩余任务就是完成tabs.js组件。</p>
                <p class="calibre4 pv pid264" id="p264">
                    首先需要把pane组件设置的标题动态渲染出来，也就是当pane触发tabs的updateNav方法时，更新标题内容。我们先看一下这部分的代码：</p>
                <pre class="calibre7 pv pid265" id="p265">Vue.component('tabs', {
    // ...
    data: function () {
        return {
            // 用于渲染 tabs的标题
            navList: []
        }
    },
    methods: {
        getTabs () {
            // 通过遍历子组件，得到所有的pane组件
            return this.$children.filter(function (item) {
                return item.$options.name === 'pane';
            });
        },
        updateNav () {
            this.navList = [];
            // 设置对this的引用，在function 回调里，this指向的并不是Vue实例
            var _this = this;

            this.getTabs().forEach(function (pane, index) {
                _this.navList.push({
                    label: pane.label,
                    name: pane.name || index
                });
                // 如果没有给pane 设置 name，默认设置它的索引
                if (!pane.name) pane.name = index;
                // 设置当前选中的tab的索引，在后面介绍
                if (index === 0) {
                    if (!_this.currentValue) {
                        _this.currentValue = pane.name || index;
                    }
                }
            });

            this.updateStatus();
        },
        updateStatus () {
            var tabs = this.getTabs();
            var _this = this;
            // 显示当前选中的tab对应的pane组件，隐藏没有选中的
            tabs.forEach(function (tab) {
                return tab.show = tab.name === _this.currentValue;
            })
        }
    }
})</pre>
                <p class="calibre4 pv pid266" id="p266">getTabs是一个公用的方法，使用this.$children来拿到所有的pane组件实例。</p>
                <p class="calibre4 pv pid267" id="p267">
                    需要注意的是，在methods里使用了有function回调的方法时（例如遍历数组的方法forEach），在回调内的this不再执行当前的Vue实例，也就是tabs组件本身，所以要在外层设置一个_this
                    = this的局部变量来间接使用this。如果你熟悉 ES2015，也可以直接使用箭头函数=&gt;，我们会在实战篇里介绍相关的用法。</p>
                <p class="calibre4 pv pid268" id="p268">
                    遍历了每一个pane组件后，把它的label和name提取出来，构成一个Object并添加到数据navList数组里，后面我们会在template里用到它。</p>
                <p class="calibre4 pv pid269" id="p269">
                    设置完navList数组后，我们调用了updateStatus方法，又将pane组件遍历了一遍，不过这时是为了将当前选中的tab对应的pane组件内容显示出来，把没有选中的隐藏掉。因为在上一步操作里，我们有可能需要设置currentValue来标识当前选中项的name（在用户没有设置value时，才会自动设置），所以必须要遍历2次才可以。</p>
                <p class="calibre4 pv pid270" id="p270">拿到navList后，就需要对它用v-for指令把tab的标题渲染出来，并且判断每个tab当前的状态。这部分代码如下：</p>
                <pre class="calibre7 pv pid271" id="p271">Vue.component('tabs', {
    template: '\
        &lt;div class="tabs"&gt; \
            &lt;div class="tabs-bar"&gt; \
                &lt;div \
                    :class="tabCls(item)" \
                    v-for="(item, index) in navList" \
                    @click="handleChange(index)"&gt; \
                    {{ item.label }} \
                &lt;/div&gt; \
            &lt;/div&gt; \
            &lt;div class="tabs-content"&gt; \
                &lt;slot&gt;&lt;/slot&gt; \
            &lt;/div&gt; \
        &lt;/div&gt;',
    props: {
        // 这里的value是为了可以使用v-model
        value: {
            type: [String, Number]
        }
    },
    data: function () {
        return {
            // 因为不能修改 value，所以复制一份自己维护
            currentValue: this.value,
            navList: []
        }
    },
    methods: {
        tabCls: function (item) {
            return [
                'tabs-tab',
                {
                    //给当前选中的tab 加一个class
                    'tabs-tab-active': item.name === this.currentValue
                }
            ]
        },
        // 点击 tab 标题时触发
        handleChange: function (index) {
            var nav = this.navList[index];
            var name = nav.name;
            // 改变当前选中的tab ，并触发下面的watch
            this.currentValue = name;
            // 更新value
            this.$emit('input', name);
            // 触发一个自定义事件，供父级使用
            this.$emit('on-click', name);
        }
    },
    watch: {
        value: function (val) {
            this.currentValue = val;
        },
        currentValue: function () {
            //在当前选中的tab 发生变化时，更新pane的显示状态
            this.updateStatus();
        }
    }
})</pre>
                <p class="calibre4 pv pid272" id="p272">
                    在使用v-for指令循环显示tab标题时，使用v-bind:class指向了一个名为tabCls的methods来动态设置class名称。因为计算属性不能接收参数，无法知道当前tab是否是选中的，所以这里我们才用到methods，不过要知道，methods是不缓存的，可以回顾关于计算属性的章节。</p>
                <p class="calibre4 pv pid273" id="p273">
                    点击每个tab标题时，会触发handleChange方法来改变当前选中tab的索引，也就是pane组件的name。在watch选项里，我们监听了currentValue，当其发生变化时，触发updateStatus方法来更新pane组件的显示状态。</p>
                <p class="calibre4 pv pid274" id="p274">
                    以上就是标签页组件的核心代码分解。总结一下该示例的技术难点：使用了组件嵌套的方式，将一系列pane组件作为tabs组件的slot；tabs组件和pane组件通信上，使用了$parent和$children的方法访问父链和子链；定义了prop：value和data：currentValue，使用$emit('input')来实现v-model的用法。</p>
                <p class="calibre4 pv pid275" id="p275">以下是标签页组件的完整代码。</p>
                <p class="calibre4 pv pid276" id="p276" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid276" id="p276">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;标签页组件&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;
        &lt;tabs v-model="activeKey"&gt;
            &lt;pane label="标签一" name="1"&gt;
                标签一的内容
            &lt;/pane&gt;
            &lt;pane label="标签二" name="2"&gt;
                标签二的内容
            &lt;/pane&gt;
            &lt;pane label="标签三" name="3"&gt;
                标签三的内容
            &lt;/pane&gt;
        &lt;/tabs&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="pane.js"&gt;&lt;/script&gt;
    &lt;script src="tabs.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript"&gt;
        var app = new Vue({
            el: '#app',
            data: {
                activeKey: '1'
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid277" id="p277" style="margin: 0px;"><span
                        class="kindle-cn-bold">pane.js：</span></p>
                <pre class="calibre7 pv pid277" id="p277">Vue.component('pane', {
    name: 'pane',
    template: '\
        &lt;div class="pane" v-show="show"&gt; \
            &lt;slot&gt;&lt;/slot&gt; \
        &lt;/div&gt;',
    props: {
        name: {
            type: String
        },
        label: {
            type: String,
            default: ''
        }
    },
    data: function () {
        return {
            show: true
        }
    },
    methods: {
        updateNav () {
            this.$parent.updateNav();
        }
    },
    watch: {
        label () {
            this.updateNav();
        }
    },
    mounted () {
        this.updateNav();
    }
})</pre>
                <p class="calibre4 pv pid278" id="p278" style="margin: 0px;"><span
                        class="kindle-cn-bold">tabs.js：</span></p>
                <pre class="calibre7 pv pid278" id="p278">Vue.component('tabs', {
    template: '\
        &lt;div class="tabs"&gt; \
            &lt;div class="tabs-bar"&gt; \
                &lt;div \
                    :class="tabCls(item)" \
                    v-for="(item, index) in navList" \
                    @click="handleChange(index)"&gt; \
                    {{ item.label }} \
                &lt;/div&gt; \
            &lt;/div&gt; \
            &lt;div class="tabs-content"&gt; \
                &lt;slot&gt;&lt;/slot&gt; \
            &lt;/div&gt; \
        &lt;/div&gt;',
    props: {
        value: {
            type: [String, Number]
        }
    },
    data: function () {
        return {
            currentValue: this.value,
            navList: []
        }
    },
    methods: {
        tabCls: function (item) {
            return [
                'tabs-tab',
                {
                    'tabs-tab-active': item.name === this.currentValue
                }
            ]
        },
        getTabs () {
            return this.$children.filter(function (item) {
                return item.$options.name === 'pane';
            });
        },
        updateNav () {
            this.navList = [];
            var _this = this;

            this.getTabs().forEach(function (pane, index) {
                _this.navList.push({
                    label: pane.label,
                    name: pane.name || index
                });
                if (!pane.name) pane.name = index;
                if (index === 0) {
                    if (!_this.currentValue) {
                        _this.currentValue = pane.name || index;
                    }
                }
            });

            this.updateStatus();
        },
        updateStatus () {
            var tabs = this.getTabs();
            var _this = this;

            tabs.forEach(function (tab) {
                return tab.show = tab.name === _this.currentValue;
            })
        },
        handleChange: function (index) {
            var nav = this.navList[index];
            var name = nav.name;

            this.currentValue = name;
            this.$emit('input', name);
            this.$emit('on-click', name);
        }
    },
    watch: {
        value: function (val) {
            this.currentValue = val;
        },
        currentValue: function () {
            this.updateStatus();
        }
    }
})</pre>
                <p class="calibre4 pv pid279" id="p279" style="margin: 0px;"><span
                        class="kindle-cn-bold">style.css：</span></p>
                <pre class="calibre7 pv pid279" id="p279">[v-cloak] {
    display: none;
}
.tabs{
    font-size: 14px;
    color: #657180;
}
.tabs-bar:after{
    content: '';
    display: block;
    width: 100%;
    height: 1px;
    background: #d7dde4;
    margin-top: -1px;
}
.tabs-tab{
    display: inline-block;
    padding: 4px 16px;
    margin-right: 6px;
    background: #fff;
    border: 1px solid #d7dde4;
    cursor: pointer;
    position: relative;
}
.tabs-tab-active{
    color: #3399ff;
    border-top: 1px solid #3399ff;
    border-bottom: 1px solid #fff;
}
.tabs-tab-active:before{
    content: '';
    display: block;
    height: 1px;
    background: #3399ff;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}
.tabs-content{
    padding: 8px 0;
}</pre>
                <p class="calibre4 pv pid280" id="p280" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>给pane组件新增一个prop：closable的布尔值，来支持是否可以关闭这个pane，如果开启，在tabs的标签标题上会有一个关闭的按钮。
                </p>
                <p class="kindle-cn-para-left pv pid280" id="p280">提示</p>
                <p class="kindle-cn-para-no-indent pv pid281" id="p281" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">在初始化pane时，我们是在mounted里通知的，关闭时，你会用到beforeDestroy。</span></p>
                <p class="calibre4 pv pid281" id="p281" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>尝试在切换pane的显示与隐藏时，使用滑动的动画。提示：可以使用CSS
                    3的transform: translateX。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="54" data-chapter-url="24047094" alt="64157308">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第7章　组件详解</h2>
                <p class="calibre4 pv pid3" id="p3">
                    组件（Component）是Vue.js最核心的功能，也是整个框架设计最精彩的地方，当然也是最难掌握的。本章将带领你由浅入深地学习组件的全部内容，并通过几个实战项目熟练使用Vue组件。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_41 pv pid4" id="p4" name="sigil_toc_id_41">7.1　组件与复用</h3><h4
                        class="kindle-cn-heading3 sigil_toc_id_42 pv pid5" id="p5" name="sigil_toc_id_42">
                    7.1.1　为什么使用组件</h4>
                <p class="calibre4 pv pid6" id="p6">在正式介绍组件前，我们先来看一个简单的场景，如图7-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid7" id="p7" style="margin: 0px;"><img alt="079"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/56d04bdfe67e0ce2.jpg"
                                                                                                       href="./image/00014.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图7-1　常见的聊天界面</p></div>
                <p class="calibre4 pv pid7" id="p7">
                    图7-1中是一个很常见的聊天界面，有一些标准的控件，比如右上角的关闭按钮、输入框、发送按钮等。你可能要问了，这有什么难的，不就是几个div、input吗？好，那现在需求升级了，这几个控件还有别的地方要用到。没问题，复制粘贴呗。那如果输入框要带数据验证，按钮的图标支持自定义呢？这样用JavaScript封装后一起复制吧。那等到项目快完结时，产品经理说，所有使用输入框的地方，都要改成支持回车键提交。好吧，给我一天的时间，我一个一个加上去。</p>
                <p class="calibre4 pv pid8" id="p8">
                    上面的需求虽然有点变态，但却是业务中很常见的，那就是一些控件、JavaScript能力的复用。没错，Vue.js的组件就是提高重用性的，让代码可复用，当学习完组件后，上面的问题就可以分分钟搞定了，再也不用害怕产品经理的奇葩需求。</p>
                <p class="calibre4 pv pid9" id="p9">我们先看一下图7-1中的示例用组件来编写是怎样的，示例代码如下：</p>
                <pre class="calibre7 pv pid10" id="p10">&lt;Card style="width: 350px;"&gt;
    &lt;p slot="title"&gt;与xxx 聊天中&lt;/p&gt;
    &lt;a href="#" slot="extra"&gt;
        &lt;Icon type="android-close" size="18"&gt;&lt;/Icon&gt;
    &lt;/a&gt;
    &lt;div style="height: 100px;"&gt;

    &lt;/div&gt;
    &lt;div&gt;
        &lt;Row :gutter="16"&gt;
            &lt;i-col span="17"&gt;
                &lt;i-input
                    v-model="value"
                    placeholder="请输入..."&gt;&lt;/i-input&gt;
            &lt;/i-col&gt;
            &lt;i-col span="4"&gt;
                &lt;i-button
                    type="primary"
                    icon="paper-airplane"&gt;发送&lt;/i-button&gt;
            &lt;/i-col&gt;
        &lt;/Row&gt;
    &lt;/div&gt;
&lt;/Card&gt;</pre>
                <p class="calibre4 pv pid11" id="p11">是不是很奇怪，有很多我们从来都没有见过的标签，比如&lt;Card&gt;、&lt;Row&gt;、&lt;i-col&gt;、&lt;i-input&gt;和&lt;i-button&gt;等，而且整段代码除了内联的几个样式外，一句
                    CSS 代码也没有，但最终实现的UI就是图7-1的效果。</p>
                <p class="calibre4 pv pid12" id="p12">
                    这些没见过的自定义标签就是组件，每个标签代表一个组件，在任何使用Vue的地方都可以直接使用。接下来，我们就来看看组件的具体用法。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_43 pv pid13" id="p13" name="sigil_toc_id_43">
                    7.1.2　组件用法</h4>
                <p class="calibre4 pv pid14" id="p14">回顾一下我们创建Vue实例的方法：</p>
                <pre class="calibre7 pv pid15" id="p15">var app = new Vue({
    el: '#app'
})</pre>
                <p class="calibre4 pv pid16" id="p16">
                    组件与之类似，需要注册后才可以使用。注册有全局注册和局部注册两种方式。全局注册后，任何Vue实例都可以使用。全局注册示例代码如下：</p>
                <pre class="calibre7 pv pid17" id="p17">Vue.component('my-component', {
    //选项
})</pre>
                <p class="calibre4 pv pid18" id="p18">my-component就是注册的组件自定义标签名称，推荐使用小写加减号分割的形式命名。</p>
                <p class="calibre4 pv pid19" id="p19">要在父实例中使用这个组件，必须要在实例创建前注册，之后就可以用&lt;my-component&gt; &lt;/my-component&gt;的形式来使用组件了，示例代码如下：</p>
                <pre class="calibre7 pv pid20" id="p20">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        //选项
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid21" id="p21">此时打开页面还是空白的，因为我们注册的组件没有任何内容，在组件选项中添加template就可以显示组件内容了，示例代码如下：</p>
                <pre class="calibre7 pv pid22" id="p22">Vue.component('my-component', {
    template: '&lt;div&gt;这里是组件的内容&lt;/div&gt;'
});</pre>
                <p class="calibre4 pv pid23" id="p23">渲染后的结果是：</p>
                <pre class="calibre7 pv pid24" id="p24">&lt;div id="app"&gt;
    &lt;div&gt;这里是组件的内容&lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid25" id="p25">template的DOM结构必须被一个元素包含，如果直接写成“这里是组件的内容”，不带“&lt;div&gt;&lt;/div&gt;”是无法渲染的。</p>
                <p class="calibre4 pv pid26" id="p26">
                    在Vue实例中，使用components选项可以局部注册组件，注册后的组件只有在该实例作用域下有效。组件中也可以使用components选项来注册组件，使组件可以嵌套。示例代码如下：</p>
                <pre class="calibre7 pv pid27" id="p27">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    var Child = {
        template: '&lt;div&gt;局部注册组件的内容&lt;/div&gt;'
    }

    var app = new Vue({
        el: '#app',
        components: {
            'my-component': Child
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid28" id="p28">Vue组件的模板在某些情况下会受到HTML的限制，比如&lt;table&gt;内规定只允许是&lt;tr&gt;、&lt;td&gt;、&lt;th&gt;等这些表格元素，所以在&lt;table&gt;内直接使用组件是无效的。这种情况下，可以使用特殊的is属性来挂载组件，示例代码如下：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div id="app"&gt;
    &lt;table&gt;
        &lt;tbody is="my-component"&gt;&lt;/tbody&gt;
    &lt;/table&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;div&gt;这里是组件的内容&lt;/div&gt;'
    });
    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">tbody在渲染时，会被替换为组件的内容。常见的限制元素还有&lt;ul&gt;、&lt;ol&gt;、&lt;select&gt;
                    。</p>
                <p class="kindle-cn-para-left pv pid31" id="p31">提示</p>
                <p class="kindle-cn-para-no-indent pv pid32" id="p32" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果使用的是字符串模板，是不受限制的，比如后面章节介绍的.vue单文件用法等。</span></p>
                <p class="calibre4 pv pid32" id="p32">
                    除了template选项外，组件中还可以像Vue实例那样使用其他的选项，比如data、computed、methods等。但是在使用data时，和实例稍有区别，data必须是函数，然后将数据return出去，例如：</p>
                <pre class="calibre7 pv pid33" id="p33">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;',
        data: function () {
            return {
                message: '组件内容'
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid34" id="p34">
                    JavaScript对象是引用关系，所以如果return出的对象引用了外部的一个对象，那这个对象就是共享的，任何一方修改都会同步。比如下面的示例：</p>
                <pre class="calibre7 pv pid35" id="p35">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    var data = {
        counter: 0
    };

    Vue.component('my-component', {
        template: '&lt;button @click="counter++"&gt;{{ counter }}&lt;/button&gt;',
        data: function () {
            return data;
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid36" id="p36">组件使用了3次，但是点击任意一个&lt;button&gt;，3个的数字都会加1，那是因为组件的data引用的是外部的对象，这肯定不是我们期望的效果，所以给组件返回一个新的data对象来独立，示例代码如下：</p>
                <pre class="calibre7 pv pid37" id="p37">&lt;div id="app"&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
    &lt;my-component&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        template: '&lt;button @click="counter++"&gt;{{ counter }}&lt;/button&gt;',
        data: function () {
            return {
                counter: 0
            };
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid38" id="p38">这样，点击3个按钮就互不影响了，完全达到复用的目的。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_44 pv pid39" id="p39" name="sigil_toc_id_44">
                    7.2　使用props传递数据</h3><h4 class="kindle-cn-heading3 sigil_toc_id_45 pv pid40" id="p40"
                                            name="sigil_toc_id_45">7.2.1　基本用法</h4>
                <p class="calibre4 pv pid41" id="p41">
                    组件不仅仅是要把模板的内容进行复用，更重要的是组件间要进行通信。通常父组件的模板中包含子组件，父组件要正向地向子组件传递数据或参数，子组件接收到后根据参数的不同来渲染不同的内容或执行操作。这个正向传递数据的过程就是通过props来实现的。</p>
                <p class="calibre4 pv pid42" id="p42">
                    在组件中，使用选项props来声明需要从父级接收的数据，props的值可以是两种，一种是字符串数组，一种是对象，本小节先介绍数组的用法。比如我们构造一个数组，接收一个来自父级的数据message，并把它在组件模板中渲染，示例代码如下：</p>
                <pre class="calibre7 pv pid43" id="p43">&lt;div id="app"&gt;
    &lt;my-component message="来自父组件的数据"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['message'],
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid44" id="p44">渲染后的结果为：</p>
                <pre class="calibre7 pv pid45" id="p45">&lt;div id="app"&gt;
    &lt;div&gt;来自父组件的数据&lt;/div&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid46" id="p46">
                    props中声明的数据与组件data函数return的数据主要区别就是props的来自父级，而data中的是组件自己的数据，作用域是组件本身，这两种数据都可以在模板template及计算属性computed和方法methods中使用。上例的数据message就是通过props从父级传递过来的，在组件的自定义标签上直接写该props的名称，如果要传递多个数据，在props数组中添加项即可。</p>
                <p class="calibre4 pv pid47" id="p47">
                    由于HTML特性不区分大小写，当使用DOM模板时，驼峰命名（camelCase）的props名称要转为短横分隔命名（kebab-case），例如：</p>
                <pre class="calibre7 pv pid48" id="p48">&lt;div id="app"&gt;
    &lt;my-component warning-text="提示信息"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['warningText'],
        template: '&lt;div&gt;{{ warningText }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid49" id="p49">提示</p>
                <p class="kindle-cn-para-no-indent pv pid50" id="p50" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果使用的是字符串模板，仍然可以忽略这些限制。</span></p>
                <p class="calibre4 pv pid50" id="p50">
                    有时候，传递的数据并不是直接写死的，而是来自父级的动态数据，这时可以使用指令v-bind来动态绑定props的值，当父组件的数据变化时，也会传递给子组件。示例代码如下：</p>
                <pre class="calibre7 pv pid51" id="p51">&lt;div id="app"&gt;
    &lt;input type="text" v-model="parentMessage"&gt;
    &lt;my-component :message="parentMessage"&gt;&lt;/my-component&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('my-component', {
        props: ['message'],
        template: '&lt;div&gt;{{ message }}&lt;/div&gt;'
    });

    var app = new Vue({
        el: '#app',
        data: {
            parentMessage: ''
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid52" id="p52">这里用v-model绑定了父级的数据parentMessage，当通过输入框任意输入时，子组件接收到的props
                    “message”也会实时响应，并更新组件模板。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="83" data-chapter-url="24047095" alt="64157337">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第8章　自定义指令</h2>
                <p class="calibre4 pv pid3" id="p3">
                    在第5章里我们已经介绍过了许多Vue内置的指令，比如v-if、v-show等，这些丰富的内置指令能满足我们的绝大部分业务需求，不过在需要一些特殊功能时，我们仍然希望对DOM进行底层的操作，这时就要用到自定义指令。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_70 pv pid4" id="p4" name="sigil_toc_id_70">8.1　基本用法</h3>
                <p class="calibre4 pv pid5" id="p5">自定义指令的注册方法和组件很像，也分全局注册和局部注册，比如注册一个v-focus的指令，用于在&lt;input&gt;、&lt;textarea&gt;元素初始化时自动获得焦点，两种写法分别是：</p>
                <pre class="calibre7 pv pid6" id="p6">// 全局注册
Vue.directive('focus', {
    //指令选项
});

// 局部注册
var app = new Vue({
    el: '#app',
    directives: {
        focus: {
            //指令选项
        }
    }
})</pre>
                <p class="calibre4 pv pid7" id="p7">
                    写法与组件基本类似，只是方法名由component改为了directive。上例只是注册了自定义指令v-focus，还没有实现具体功能，下面具体介绍自定义指令的各个选项。</p>
                <p class="calibre4 pv pid8" id="p8">自定义指令的选项是由几个钩子函数组成的，每个都是可选的。</p>
                <ul class="kindle-cn-ul-disc pv pid9" id="p9" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">bind：只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">inserted：被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于document中）。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">update：被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">componentUpdated：被绑定元素所在模板完成一次更新周期时调用。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">unbind：只调用一次，指令与元素解绑时调用。</span></li>
                </ul>
                <p class="calibre4 pv pid9" id="p9">
                    可以根据需求在不同的钩子函数内完成逻辑代码，例如上面的v-focus，我们希望在元素插入父节点时就调用，那用到的最好是inserted。示例代码如下：</p>
                <pre class="calibre7 pv pid10" id="p10">&lt;div id="app"&gt;
    &lt;input type="text" v-focus&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.directive('focus', {
        inserted: function (el) {
            // 聚焦元素
            el.focus();
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid11" id="p11">在浏览器中的效果如图8-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid12" id="p12" style="margin: 0px;"><img alt="133"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/f0e8514beff8b118.jpg"
                                                                                                         href="./image/00021.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图8-1　v-focus渲染后的效果</p></div>
                <p class="calibre4 pv pid12" id="p12">可以看到，打开这个页面，input输入框就自动获得了焦点，成为可输入状态。</p>
                <p class="calibre4 pv pid13" id="p13">每个钩子函数都有几个参数可用，比如上面我们用到了el。它们的含义如下：</p>
                <ul class="kindle-cn-ul-disc pv pid14" id="p14" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">el　指令所绑定的元素，可以用来直接操作DOM。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">binding　一个对象，包含以下属性：</span></li>
                </ul>
                <div class="kindle-cn-toc-level1 pv pid14" id="p14" style="margin: 0px;">
                    <ul class="kindle-cn-ul-square">
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">name　指令名，不包括v-前缀。</span></li>
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">value　指令的绑定值，例如v-my-directive="1 + 1"，value的值是2。</span>
                        </li>
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">oldValue　指令绑定的前一个值，仅在update和componentUpdated钩子中可用。无论值是否改变都可用。</span>
                        </li>
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">expression　绑定值的字符串形式。例如v-my-directive="1 + 1"，expression的值是"1 + 1"。</span>
                        </li>
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">arg　传给指令的参数。例如v-my-directive:foo，arg的值是foo。</span>
                        </li>
                        <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">modifiers　一个包含修饰符的对象。例如v-my-directive.foo.bar，修饰符对象modifiers的值是{ foo: true, bar: true }。</span>
                        </li>
                    </ul>
                </div>
                <ul class="kindle-cn-ul-disc pv pid14" id="p14" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">vnode　Vue编译生成的虚拟节点，在进阶篇中介绍。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">oldVnode　上一个虚拟节点仅在update和componentUpdated 钩子中可用。</span>
                    </li>
                </ul>
                <p class="calibre4 pv pid14" id="p14">下面是结合了以上参数的一个具体示例，代码如下：</p>
                <pre class="calibre7 pv pid15" id="p15">&lt;div id="app"&gt;
    &lt;div v-test:msg.a.b="message"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.directive('test', {
        bind: function (el, binding, vnode) {
            var keys = [];
            for (var i in vnode) {
                keys.push(i);
            }
            el.innerHTML =
                'name: '       + binding.name + '&lt;br&gt;' +
                'value: '      + binding.value + '&lt;br&gt;' +
                'expression: ' + binding.expression + '&lt;br&gt;' +
                'argument: '   + binding.arg + '&lt;br&gt;' +
                'modifiers: '  + JSON.stringify(binding.modifiers) + '&lt;br&gt;' +
                'vnode keys: ' + keys.join(', ')
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            message: 'some text'
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid16" id="p16">执行后，&lt;div&gt;的内容会使用innerHTML重置，结果为：</p>
                <pre class="calibre7 pv pid17" id="p17">name: test
value: some text
expression: message
argument: msg
modifiers: {"a":true,"b":true}
vnode keys:
tag,data,children,text,elm,ns,context,functionalContext,key,componentOptions,componentInstance,parent,raw,isStatic,isRootInsert,isComment,isCloned,isOnce</pre>
                <p class="calibre4 pv pid18" id="p18">
                    在大多数使用场景，我们会在bind钩子里绑定一些事件，比如在document上用addEventListener绑定，在unbind里用removeEventListener解绑，比较典型的示例就是让这个元素随着鼠标拖拽。在后面的8.2节中，我们会详细介绍。</p>
                <p class="calibre4 pv pid19" id="p19">
                    如果需要多个值，自定义指令也可以传入一个JavaScript对象字面量，只要是合法类型的JavaScript表达式都是可以的。示例代码如下：</p>
                <pre class="calibre7 pv pid20" id="p20">&lt;div id="app"&gt;
    &lt;div v-test="{msg: 'hello', name: 'Aresn'}"&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.directive('test', {
        bind: function (el, binding, vnode) {
            console.log(binding.value.msg);
            console.log(binding.value.name);
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid21" id="p21">Vue 2.x移除了大量Vue
                    1.x自定义指令的配置。在使用自定义指令时，应该充分理解业务需求，因为很多时候你需要的可能并不是自定义指令，而是组件。在下一节中，我们结合两个经典的示例来进一步了解自定义指令的使用场景和用法。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_71 pv pid22" id="p22" name="sigil_toc_id_71">8.2　实战</h3><h4
                        class="kindle-cn-heading3 sigil_toc_id_72 pv pid23" id="p23" name="sigil_toc_id_72">
                    8.2.1　开发一个可从外部关闭的下拉菜单</h4>
                <p class="calibre4 pv pid24" id="p24">网页中有很多常见的下拉菜单，比如图8-2所示的用户信息菜单。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid25" id="p25" style="margin: 0px;"><img alt="136"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/b64f4476e9f8194d.jpg"
                                                                                                         href="./image/00022.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图8-2　点击用户的下拉菜单</p></div>
                <p class="calibre4 pv pid25" id="p25">
                    点击用户头像和名称，会弹出一个下拉菜单，然后点击页面中其他空白区域（除了菜单本身外），菜单就关闭了。本示例就用自定义指令来实现这样的需求。</p>
                <p class="calibre4 pv pid26" id="p26">先来分析一下如何实现。</p>
                <p class="calibre4 pv pid27" id="p27">
                    该示例有两个特点，一是点击下拉菜单本身是不会关闭的，二是点击下拉菜单以外的所有区域都要关闭。点击所有区域可以在document上绑定click事件来实现，同时只要过滤出是否点击的是目标元素内部的元素即可。</p>
                <p class="calibre4 pv pid28" id="p28">示例最终呈现的效果如图8-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid29" id="p29" style="margin: 0px;"><img alt="136-2"
                                                                                                         class="kindle-cn-bodycontent-image-alone30-withnote"
                                                                                                         src="./index_files/e5b953206a283c0e.jpg"
                                                                                                         href="./image/00023.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图8-3　下拉菜单示例最终效果</p></div>
                <p class="calibre4 pv pid29" id="p29">首先初始化各个文件。</p>
                <p class="calibre4 pv pid30" id="p30" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid30" id="p30">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;可从外部关闭的下拉菜单&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;

    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="clickoutside.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid31" id="p31" style="margin: 0px;"><span class="kindle-cn-bold">index.js：</span>
                </p>
                <pre class="calibre7 pv pid31" id="p31">var app = new Vue({
    el: '#app'
});</pre>
                <p class="calibre4 pv pid32" id="p32" style="margin: 0px;"><span
                        class="kindle-cn-bold">clickoutside.js：</span></p>
                <pre class="calibre7 pv pid32" id="p32">Vue.directive('clickoutside', {

});</pre>
                <p class="calibre4 pv pid33" id="p33">利用组件的基本知识很容易完成index.html和index.js的逻辑：</p>
                <pre class="calibre7 pv pid34" id="p34">&lt;div id="app" v-cloak&gt;
    &lt;div class="main" v-clickoutside="handleClose"&gt;
        &lt;button @click="show = !show"&gt;点击显示下拉菜单&lt;/button&gt;
        &lt;div class="dropdown" v-show="show"&gt;
            &lt;p&gt;下拉框的内容，点击外面区域可以关闭&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

var app = new Vue({
    el: '#app',
    data: {
        show: false
    },
    methods: {
        handleClose: function () {
            this.show = false;
        }
    }
});</pre>
                <p class="calibre4 pv pid35" id="p35">逻辑很简单，点击按钮时显示class为dropdown的div元素。</p>
                <p class="calibre4 pv pid36" id="p36">
                    自定义指令v-clickoutside绑定了一个函数handleClose，用来关闭菜单。先来看一下clickoutside.js的内容：</p>
                <pre class="calibre7 pv pid37" id="p37">Vue.directive('clickoutside', {
    bind: function (el, binding, vnode) {
        function documentHandler (e) {
            if (el.contains(e.target)) {
                return false;
            }
            if (binding.expression) {
                binding.value(e);
            }
        }
        el.__vueClickOutside__ = documentHandler;
        document.addEventListener('click', documentHandler);
    },
    unbind: function (el, binding) {
        document.removeEventListener('click', el.__vueClickOutside__);
        delete el.__vueClickOutside__;
    }
});</pre>
                <p class="calibre4 pv pid38" id="p38">
                    之前分析过，要在document上绑定click事件，所以在bind钩子内声明了一个函数documentHandler，并将它作为句柄绑定在document的click事件上。documentHandler函数做了两个判断，第一个是判断点击的区域是否是指令所在的元素内部，如果是，就跳出函数，不往下继续执行。</p>
                <p class="kindle-cn-para-left pv pid39" id="p39">提示</p>
                <p class="kindle-cn-para-no-indent pv pid40" id="p40" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">contains方法是用来判断元素A是否包含了元素B，包含返回true，不包含返回false。示例代码如下：</span>
                </p>
                <pre class="calibre7 pv pid40" id="p40">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;contains&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="parent"&gt;
        父元素
        &lt;div id="children"&gt;子元素&lt;/div&gt;
    &lt;/div&gt;
    &lt;script type="text/javascript"&gt;
        var A = document.getElementById('parent');
        var B = document.getElementById('children');
        console.log(A.contains(B));  // true
        console.log(B.contains(A));  // false
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid41" id="p41">
                    第二个判断的是当前的指令v-clickoutside有没有写表达式，在该自定义指令中，表达式应该是一个函数，在过滤了内部元素后，点击外面任何区域应该执行用户表达式中的函数，所以binding.value()就是用来执行当前上下文
                    methods中指定的函数的。</p>
                <p class="calibre4 pv pid42" id="p42">与Vue
                    1.x不同的是，在自定义指令中，不能再用this.xxx的形式在上下文中声明一个变量，所以用了el.__vueClickOutside__引用了documentHandler，这样就可以在unbind钩子里移除对document的click事件监听。如果不移除，当组件或元素销毁时，它仍然存在于内存中。</p>
                <p class="calibre4 pv pid43" id="p43">以上代码分解与完整代码基本一致，不再重复提供。下面是style.css的代码：</p>
                <pre class="calibre7 pv pid44" id="p44">[v-cloak] {
    display: none;
}
.main{
    width: 125px;
}
button{
    display: block;
    width: 100%;
    color: #fff;
    background-color: #39f;
    border: 0;
    padding: 6px;
    text-align: center;
    font-size: 12px;
    border-radius: 4px;
    cursor: pointer;
    outline: none;
    position: relative;
}
button:active{
    top: 1px;
    left: 1px;
}
.dropdown{
    width: 100%;
    height: 150px;
    margin: 5px 0;
    font-size: 12px;
    background-color: #fff;
    border-radius: 4px;
    box-shadow: 0 1px 6px rgba(0,0,0,.2);
}
.dropdown p{
    display: inline-block;
    padding: 6px;
}</pre>
                <p class="calibre4 pv pid45" id="p45" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>在update钩子中支持表达式的更新。
                </p>
                <p class="calibre4 pv pid45" id="p45" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>扩展clickoutside.js，实现在点击按钮显示下拉菜单后，通过按下键盘的ESC
                    键也可以关闭下拉菜单。</p>
                <p class="calibre4 pv pid45" id="p45" style="margin: 0px;"><span class="kindle-cn-bold">练习3：</span>将练习2的ESC按键关闭功能作为可选项。提示，可以用修饰符，比如v-clickoutside.esc。
                </p><h4 class="kindle-cn-heading3 sigil_toc_id_73 pv pid45" id="p45" name="sigil_toc_id_73">
                    8.2.2　开发一个实时时间转换指令v-time</h4>
                <p class="calibre4 pv pid46" id="p46">在一些社区，比如微博、朋友圈等，发布的动态会有一个相对本机时间转换后的相对时间，如图8-4中波浪线圈出的时间。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid47" id="p47" style="margin: 0px;"><img alt="140"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/6c865fb6aeae6edb.jpg"
                                                                                                         href="./image/00024.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图8-4　程序员社区talkingcoder.com最新文章列表</p></div>
                <p class="calibre4 pv pid47" id="p47">一般在服务端的存储时间格式是Unix时间戳，比如2017-01-01
                    00:00:00的时间戳是1483200000。前端在拿到数据后，将它转换为可读的时间格式再显示出来。为了显示出实时性，在一些社交类产品中，甚至会实时转换为几秒钟前、几分钟前、几小时前等不同的格式，这样比直接转换为年、月、日、时、分、秒更友好。本示例就来实现这样一个自定义指令v-time，将表达式传入的时间戳实时转换为相对时间。</p>
                <p class="calibre4 pv pid48" id="p48">便于演示效果，我们初始化时定义了两个时间。</p>
                <p class="calibre4 pv pid49" id="p49" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid49" id="p49">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;时间转换指令&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;
        &lt;div v-time="timeNow"&gt;&lt;/div&gt;
        &lt;div v-time="timeBefore"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="time.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid50" id="p50" style="margin: 0px;"><span class="kindle-cn-bold">index.js：</span>
                </p>
                <pre class="calibre7 pv pid50" id="p50">var app = new Vue({
    el: '#app',
    data: {
        timeNow: (new Date()).getTime(),
        timeBefore: 1488930695721
    }
});</pre>
                <p class="calibre4 pv pid51" id="p51">timeNow是目前的时间，timeBefore是一个写死的时间：2017-03-08。</p>
                <p class="kindle-cn-para-left pv pid52" id="p52">提示</p>
                <p class="kindle-cn-para-no-indent pv pid53" id="p53" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本示例所用的时间戳都是毫秒级的，如服务端返回秒级时间戳需要乘以1000后再使用。</span></p>
                <p class="calibre4 pv pid53" id="p53">分析一下时间转换的逻辑：</p>
                <ul class="kindle-cn-ul-disc pv pid54" id="p54" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">1分钟以前，显示“刚刚”。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">1分钟~1小时之间，显示“xx分钟前”。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">1小时~1天之间，显示“xx小时前”。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">1天~1个月（31天）之间，显示“xx天前”。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">大于1个月，显示“xx年xx月xx日”。</span></li>
                </ul>
                <p class="calibre4 pv pid54" id="p54">
                    为了使判断逻辑更简单，统一使用时间戳进行大小判断。在写指令v-time之前，需要先写一系列与时间相关的函数，我们声明一个对象Time，把它们都封装在里面。</p>
                <p class="calibre4 pv pid55" id="p55" style="margin: 0px;"><span class="kindle-cn-bold">time.js：</span>
                </p>
                <pre class="calibre7 pv pid55" id="p55">var Time = {
    // 获取当前时间戳
    getUnix: function () {
        var date = new Date();
        return date.getTime();
    },
    // 获取今天0点0分0秒的时间戳
    getTodayUnix: function () {
        var date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date.getTime();
    },
    // 获取今年1月1日0点0分0秒的时间戳
    getYearUnix: function () {
        var date = new Date();
        date.setMonth(0);
        date.setDate(1);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date.getTime();
    },
    // 获取标准年月日
    getLastDate: function(time) {
        var date = new Date(time);
        var month = date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1;
        var day = date.getDate() &lt; 10 ? '0' + date.getDate() : date.getDate();
        return date.getFullYear() + '-' + month + "-" + day;
    },
    // 转换时间
    getFormatTime: function(timestamp) {
        var now = this.getUnix();               //当前时间戳
        var today = this.getTodayUnix();        //今天0点时间戳
        var year = this.getYearUnix();          //今年0点时间戳
        var timer = (now - timestamp) / 1000;   //转换为秒级时间戳
        var tip = '';

        if (timer &lt;= 0) {
            tip = '刚刚';
        } else if (Math.floor(timer/60) &lt;= 0) {
            tip = '刚刚';
        } else if (timer &lt; 3600) {
            tip = Math.floor(timer/60) + '分钟前';
        } else if (timer &gt;= 3600 &amp;&amp; (timestamp - today &gt;= 0) ) {
            tip = Math.floor(timer/3600) + '小时前';
        } else if (timer/86400 &lt;= 31) {
            tip = Math.ceil(timer/86400) + '天前';
        } else {
            tip = this.getLastDate(timestamp);
        }
        return tip;
    }
};</pre>
                <p class="kindle-cn-para-left pv pid56" id="p56">提示</p>
                <p class="kindle-cn-para-no-indent pv pid57" id="p57" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果你对JavaScript的Date类型不了解，可以到MDN查阅学习Date常用的API：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date</span>
                </p>
                <p class="calibre4 pv pid57" id="p57">
                    Time.getFormatTime()方法就是自定义指令v-time所需要的，入参为毫秒级时间戳，返回已经整理好时间格式的字符串。</p>
                <p class="calibre4 pv pid58" id="p58">最后在time.js里补全剩余的代码：</p>
                <pre class="calibre7 pv pid59" id="p59">Vue.directive('time', {
    bind: function (el, binding) {
        el.innerHTML = Time.getFormatTime(binding.value);
        el.__timeout__ = setInterval(function() {
            el.innerHTML = Time.getFormatTime(binding.value);
        }, 60000);
    },
    unbind: function (el) {
        clearInterval(el.__timeout__);
        delete el.__timeout__;
    }
});</pre>
                <p class="calibre4 pv pid60" id="p60">
                    在bind钩子里，将指令v-time表达式的值binding.value作为参数传入Time.getFormatTime()方法得到格式化时间，再通过el.innerHTML写入指令所在元素。定时器el.__timeout__每分钟触发一次，更新时间，并且在unbind
                    钩子里清除掉。</p>
                <p class="calibre4 pv pid61" id="p61" style="margin: 0px;"><span class="kindle-cn-bold">总结：</span>在编写自定义指令时，给DOM绑定一次性事件等初始动作，建议在bind钩子内完成，同时要在unbind内解除相关绑定。在自定义指令里，理论上可以任意操作DOM，但这又违背Vue.js的初衷，所以对于大幅度的DOM变动，应该使用组件。
                </p>
                <p class="calibre4 pv pid61" id="p61" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>开发一个自定义指令v-birthday，接收一个出生日期的时间戳，将它转换为已经出生了xxx天。
                </p>
                <p class="calibre4 pv pid61" id="p61" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>扩展练习1的自定义指令v-birthday，将出生了xxx天转换为具体年龄，比如25岁8个月10天。
                </p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="88" data-chapter-url="24047096" alt="64157342">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px">
                <div class="calibre3 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0"></div>
                <h1 class="kindle-cn-heading calibre_pb_1 pv pid3" id="p3" name="calibre_pb_1">第2篇　进阶篇</h1>
                <p class="calibre4 pv pid4" id="p4">基础篇的章节内容基本涵盖了Vue.js
                    2.x最常用的功能。如果不需要前端路由和自动化工程，那么你已经可以利用这些内容做一些中小型项目了。</p>
                <p class="calibre4 pv pid5" id="p5">
                    从下一章开始，介绍的内容会由浅入深，逐步向前端工程化迈进，使用到的知识点也逐渐增加，比如NPM、Node.js、ES2015。当然，你完全不用担心，所有知识点都会详细讲解到。</p>
                <p class="calibre4 pv pid6" id="p6">
                    如果你是编程新手、前端入门者，或者刚从后端转到前端，那建议你在阅读后面章节前先巩固一下基础篇所讲的知识点，尤其是组件的章节，最好是先练习一些典型的题目，加深对Vue.js
                    基础知识的理解。以下是推荐的一个小项目。</p>
                <p class="calibre4 pv pid7" id="p7" style="margin: 0px;"><span class="kindle-cn-bold">项目：</span>调查问卷
                    WebApp。</p>
                <p class="calibre4 pv pid7" id="p7" style="margin: 0px;"><span class="kindle-cn-bold">描述：</span>制作一个简单的调查问卷HTML
                    5小应用，每页有一道题目，题目可以是单选题、多选题、填写题等。最终效果如下图所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid7" id="p7" style="margin: 0px;"><img alt="145"
                                                                                                       class="kindle-cn-bodycontent-image-alone1"
                                                                                                       src="./index_files/a04096aa1b22cee3.jpg"
                                                                                                       href="./image/00025.jpeg">
                </div>
                <p class="calibre4 pv pid7" id="p7" style="margin: 0px;"><span class="kindle-cn-bold">说明：</span>每一页可以通过v-show或v-if在切换步骤时显示，点击重置，当前页的控件还原到初始状态。要对每页的数据进行校验，比如单选题必须要选择，多选题最少选择2项，最多选择3项，文本框输入不能少于100字，若当前页不满足验证要求，则下一步的按钮置灰，不可点击。
                </p>
                <p class="calibre4 pv pid7" id="p7" style="margin: 0px;"><span class="kindle-cn-bold">要求：</span>按钮要制作成组件，可以控制颜色、状态（禁用），点击后传递一个自定义事件on-click。
                </p>
                <p class="calibre4 pv pid7" id="p7">如果你可以轻松完成这个小练习，或者已经迫不及待地想阅读下一章节，那就做好准备，来探索新的内容吧！</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="89" data-chapter-url="24047097" alt="64157343">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第9章　Render函数</h2>
                <p class="calibre4 pv pid3" id="p3">Vue.js 2.x与Vue.js 1.x最大的区别就在于2.x使用了Virtual
                    Dom（虚拟DOM）来更新DOM节点，提升渲染性能。</p>
                <p class="calibre4 pv pid4" id="p4">虽然前面章节我们的组件模板都是写在template选项里的，但是在Vue.js编译时，都会解析为Virtual Dom。</p>
                <p class="calibre4 pv pid5" id="p5">本章我们就来探索Vue.js用于实现Virtual
                    Dom的Render函数用法，在介绍Render函数前，我们先来看看什么是Virtual Dom。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_74 pv pid6" id="p6" name="sigil_toc_id_74">9.1　什么是Virtual
                    Dom</h3>
                <p class="calibre4 pv pid7" id="p7">React和Vue 2都使用了Virtual Dom技术，Virtual
                    Dom并不是真正意义上的DOM，而是一个轻量级的JavaScript对象，在状态发生变化时，Virtual Dom会进行Diff 运算，来更新只需要被替换的DOM，而不是全部重绘。</p>
                <p class="calibre4 pv pid8" id="p8">与DOM操作相比，Virtual Dom是基于JavaScript计算的，所以开销会小很多。图9-1演示了Virtual
                    Dom运行的过程。</p>
                <p class="calibre4 pv pid9" id="p9">正常的DOM节点在HTML中是这样的：</p>
                <pre class="calibre7 pv pid10" id="p10">&lt;div id="main"&gt;
    &lt;p&gt;文本内容&lt;/p&gt;
    &lt;p&gt;文本内容&lt;/p&gt;
&lt;/div&gt;</pre>
                <div class="kindle-cn-bodycontent-div-alone pv pid11" id="p11" style="margin: 0px;"><img alt="148"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/23b86a13b36d3d9c.jpg"
                                                                                                         href="./image/00026.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-1　Virtual Dom运行过程</p></div>
                <p class="calibre4 pv pid11" id="p11">用Virtual Dom创建的JavaScript对象一般会是这样的：</p>
                <pre class="calibre7 pv pid12" id="p12">var vNode = {
    tag: 'div',
    attributes: {
        id: 'main'
    },
    children: [
        // p 节点
    ]
}</pre>
                <p class="calibre4 pv pid13" id="p13">vNode对象通过一些特定的选项描述了真实的DOM结构。</p>
                <p class="calibre4 pv pid14" id="p14">在Vue.js 2中，Virtual
                    Dom就是通过一种VNode类表达的，每个DOM元素或组件都对应一个VNode对象，在Vue.js源码中是这样定义的：</p>
                <pre class="calibre7 pv pid15" id="p15">export interface VNode {
    tag?: string;
    data?: VNodeData;
    children?: VNode[];
    text?: string;
    elm?: Node;
    ns?: string;
    context?: Vue;
    key?: string | number;
    componentOptions?: VNodeComponentOptions;
    componentInstance?: Vue;
    parent?: VNode;
    raw?: boolean;
    isStatic?: boolean;
    isRootInsert: boolean;
    isComment: boolean;
}</pre>
                <p class="calibre4 pv pid16" id="p16">具体含义如下：</p>
                <ul class="kindle-cn-ul-disc pv pid17" id="p17" style="margin: 0px;">
                    <li class="calibre6">tag　<span class="kindle-cn-specialtext-kaiti">当前节点的标签名。</span></li>
                    <li class="calibre6">data　<span class="kindle-cn-specialtext-kaiti">当前节点的数据对象。</span></li>
                </ul>
                <p class="calibre4 pv pid17" id="p17">VNodeData代码如下：</p>
                <pre class="calibre7 pv pid18" id="p18">export interface VNodeData {
    key?: string | number;
    slot?: string;
    scopedSlots?: { [key: string]: ScopedSlot };
    ref?: string;
    tag?: string;
    staticClass?: string;
    class?: any;
    staticStyle?: { [key: string]: any };
    style?: Object[] | Object;
    props?: { [key: string]: any };
    attrs?: { [key: string]: any };
    domProps?: { [key: string]: any };
    hook?: { [key: string]: Function };
    on?: { [key: string]: Function | Function[] };
    nativeOn?: { [key: string]: Function | Function[] };
    transition?: Object;
    show?: boolean;
    inlineTemplate?: {
      render: Function;
      staticRenderFns: Function[];
    };
    directives?: VNodeDirective[];
    keepAlive?: boolean;
}</pre>
                <ul class="kindle-cn-ul-disc pv pid19" id="p19" style="margin: 0px;">
                    <li class="calibre6">children　<span class="kindle-cn-specialtext-kaiti">子节点，数组，也是VNode类型。</span>
                    </li>
                    <li class="calibre6">text　<span class="kindle-cn-specialtext-kaiti">当前节点的文本，一般文本节点或注释节点会有该属性。</span>
                    </li>
                    <li class="calibre6">elm　<span class="kindle-cn-specialtext-kaiti">当前虚拟节点对应的真实的DOM节点。</span></li>
                    <li class="calibre6">ns　<span class="kindle-cn-specialtext-kaiti">节点的namespace。</span></li>
                    <li class="calibre6">context　<span class="kindle-cn-specialtext-kaiti">编译作用域。。</span></li>
                    <li class="calibre6">functionalContext　<span class="kindle-cn-specialtext-kaiti">函数化组件的作用域。</span>
                    </li>
                    <li class="calibre6">key　<span
                            class="kindle-cn-specialtext-kaiti">节点的key属性，用于作为节点的标识，有利于patch的优化。</span></li>
                    <li class="calibre6">componentOptions　<span
                            class="kindle-cn-specialtext-kaiti">创建组件实例时会用到的选项信息。</span></li>
                    <li class="calibre6">child　<span class="kindle-cn-specialtext-kaiti">当前节点对应的组件实例。</span></li>
                    <li class="calibre6">parent　<span class="kindle-cn-specialtext-kaiti">组件的占位节点。</span></li>
                    <li class="calibre6">raw　<span class="kindle-cn-specialtext-kaiti">原始html。</span></li>
                    <li class="calibre6">isStatic　<span class="kindle-cn-specialtext-kaiti">静态节点的标识。</span></li>
                    <li class="calibre6">isRootInsert　<span class="kindle-cn-specialtext-kaiti">是否作为根节点插入，被&lt;transition&gt;包裹的节点，该属性的值为false。</span>
                    </li>
                    <li class="calibre6">isComment　<span class="kindle-cn-specialtext-kaiti">当前节点是否是注释节点。</span></li>
                    <li class="calibre6">isCloned　<span class="kindle-cn-specialtext-kaiti">当前节点是否为克隆节点。</span></li>
                    <li class="calibre6">isOnce　<span class="kindle-cn-specialtext-kaiti">当前节点是否有v-once指令。</span></li>
                </ul>
                <p class="calibre4 pv pid19" id="p19">VNode 主要可以分为如下几类，如图9-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid20" id="p20" style="margin: 0px;"><img alt="150"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/820f598311507550.jpg"
                                                                                                         href="./image/00027.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-2　VNode主要类型</p></div>
                <ul class="kindle-cn-ul-disc pv pid20" id="p20" style="margin: 0px;">
                    <li class="calibre6">TextVNode　<span class="kindle-cn-specialtext-kaiti">文本节点。</span></li>
                    <li class="calibre6">ElementVNode　<span class="kindle-cn-specialtext-kaiti">普通元素节点。</span></li>
                    <li class="calibre6">ComponentVNode　<span class="kindle-cn-specialtext-kaiti">组件节点。</span></li>
                    <li class="calibre6">EmptyVNode　<span class="kindle-cn-specialtext-kaiti">没有内容的注释节点。</span></li>
                    <li class="calibre6">CloneVNode　<span class="kindle-cn-specialtext-kaiti">克隆节点，可以是以上任意类型的节点，唯一的区别在于isCloned属性为true。</span>
                    </li>
                </ul>
                <p class="calibre4 pv pid20" id="p20">使用Virtual
                    Dom就可以完全发挥JavaScript的编程能力。在多数场景中，我们使用template就足够了，但在一些特定的场景下，使用Virtual
                    Dom会更简单，下节就来介绍Vue的Render函数的用法。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_75 pv pid21" id="p21" name="sigil_toc_id_75">
                    9.2　什么是Render函数</h3>
                <p class="calibre4 pv pid22" id="p22">先来看这样一个场景：在很多文章类型的网站中（比如文档、博客）都有区分一级标题、二级标题、三级标题……为方便分享
                    url，它们都做成了锚点，点击一下，会将内容加在网址后面，以“#”分割，如图9-3所示。</p>
                <p class="calibre4 pv pid23" id="p23">图中的“特性”是一个&lt;h2&gt; 标签，内容含有一个&lt;a href="#特性"&gt;#&lt;/a&gt;的链接，点击后，url就带有了锚点信息，别人打开时，会直接聚焦到“特性”所在的位置。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid24" id="p24" style="margin: 0px;"><img alt="151"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/739e1fe829f42e62.jpg"
                                                                                                         href="./image/00028.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-3　带有锚点的标题</p></div>
                <p class="calibre4 pv pid24" id="p24">如果把它封装为一个组件，一般写法可能会是这样：</p>
                <pre class="calibre7 pv pid25" id="p25">&lt;div id="app"&gt;
    &lt;anchor :level="2" title="特性"&gt;特性&lt;/anchor&gt;

    &lt;script type="text/x-template" id="anchor"&gt;
        &lt;div&gt;
            &lt;h1 v-if="level === 1"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h1&gt;
            &lt;h2 v-if="level === 2"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h2&gt;
            &lt;h3 v-if="level === 3"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h3&gt;
            &lt;h4 v-if="level === 4"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h4&gt;
            &lt;h5 v-if="level === 5"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h5&gt;
            &lt;h6 v-if="level === 6"&gt;
                &lt;a :href="'#' + title"&gt;
                    &lt;slot&gt;&lt;/slot&gt;
                &lt;/a&gt;
            &lt;/h6&gt;
        &lt;/div&gt;
    &lt;/script&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('anchor', {
        template: '#anchor',
        props: {
            level: {
                type: Number,
                required: true
            },
            title: {
                type: String,
                default: ''
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid26" id="p26">
                    这样写没有任何错误，只是缺点很明显：代码冗长，组件的template大部分代码是重复的，只是heading元素的级别不同，再者必须插入一个根元素&lt;div&gt;，这是组件的要求。</p>
                <p class="calibre4 pv pid27" id="p27">
                    template写法在大多时候是很好用的，但到了这里使用起来就很别扭。事实上，prop：level已经具备了heading级别的含义，我们更希望能像拼接字符串的形式来构造heading元素，比如"h"
                    + this.level。在Render函数中的确可以这样做。</p>
                <p class="calibre4 pv pid28" id="p28">下面是使用Render函数改写后的代码：</p>
                <pre class="calibre7 pv pid29" id="p29">&lt;div id="app"&gt;
    &lt;anchor :level="2" title="特性"&gt;特性&lt;/anchor&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('anchor', {
        props: {
            level: {
                type: Number,
                required: true
            },
            title: {
                type: String,
                default: ''
            }
        },
        render: function (createElement) {
            return createElement(
                'h' + this.level,
                [
                    createElement(
                        'a',
                        {
                            domProps: {
                                href: '#' + this.title
                            }
                        },
                        this.$slots.default
                    )
                ]

            )
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">Render函数通过createElement参数来创建Virtual
                    Dom，结构精简了很多。在第7章组件中介绍slot时，有提到过访问slot的用法，使用场景就是在Render函数。</p>
                <p class="calibre4 pv pid31" id="p31">Render函数所有神奇的地方都在这个createElement里，下一节我们就来介绍它的详细配置和用法。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_76 pv pid32" id="p32" name="sigil_toc_id_76">
                    9.3　createElement用法</h3><h4 class="kindle-cn-heading3 sigil_toc_id_77 pv pid33" id="p33"
                                                name="sigil_toc_id_77">9.3.1　基本参数</h4>
                <p class="calibre4 pv pid34" id="p34">createElement构成了Vue Virtual Dom的模板，它有3个参数：</p>
                <pre class="calibre7 pv pid35" id="p35">createElement(
    // {String | Object | Function}
    // 一个HTML标签，组件选项，或一个函数
    //必须Return上述其中一个
    'div',
    // {Object}
    // 一个对应属性的数据对象，可选
    // 您可以在template中使用
    {
        // 稍后详细介绍
    },
    // {String | Array}
    // 子节点（VNodes），可选
    [
        createElement('h1', 'hello world'),
        createElement(MyComponent, {
            props: {
                someProp: 'foo'
            }
        }),
        'bar'
    ]
)</pre>
                <p class="calibre4 pv pid36" id="p36">
                    第一个参数必选，可以是一个HTML标签，也可以是一个组件或函数；第二个是可选参数，数据对象，在template中使用。第三个是子节点，也是可选参数，用法一致。</p>
                <p class="calibre4 pv pid37" id="p37">对于第二个参数“数据对象”，具体的选项如下：</p>
                <pre class="calibre7 pv pid38" id="p38">{
    //和v-bind:class一样的API
    'class': {
        foo: true,
        bar: false
    },
    //和v-bind:style一样的API
    style: {
        color: 'red',
        fontSize: '14px'
    },
    // 正常的HTML特性
    attrs: {
        id: 'foo'
    },
    //组件props
    props: {
        myProp: 'bar'
    },
    // DOM属性
    domProps: {
        innerHTML: 'baz'
    },
    // 自定义事件监听器"on"
    //不支持如v-on:keyup.enter的修饰器
    // 需要手动匹配 keyCode
    on: {
        click: this.clickHandler
    },
    // 仅对于组件，用于监听原生事件
    // 而不是组件使用vm.$emit触发的自定义事件
    nativeOn: {
        click: this.nativeClickHandler
    },
    // 自定义指令
    directives: [
        {
            name: 'my-custom-directive',
            value: '2'
            expression: '1 + 1',
            arg: 'foo',
            modifiers: {
                bar: true
            }
        }
    ],
    // 作用域slot
    // { name: props =&gt; VNode | Array&lt;VNode&gt; }
    scopedSlots: {
        default: props =&gt; h('span', props.text)
    },
    // 如果子组件有定义slot的名称
    slot: 'name-of-slot'
    // 其他特殊顶层属性
    key: 'myKey',
    ref: 'myRef'
}</pre>
                <p class="calibre4 pv pid39" id="p39">
                    以往在template里，我们都是在组件的标签上使用形容v-bind:class、v-bind:style、v-on:click这样的指令，在Render函数都将其写在了数据对象里，比如下面的组件，使用传统的template写法是：</p>
                <pre class="calibre7 pv pid40" id="p40">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        template: '\
            &lt;div id="element" \
            :class="{show: show}" \
            @click="handleClick"&gt;文本内容&lt;/div&gt;',
        data: function () {
            return {
                show: true
            }
        },
        methods: {
            handleClick: function () {
                console.log('clicked!');
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid41" id="p41">使用Render改写后的代码如下：</p>
                <pre class="calibre7 pv pid42" id="p42">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            return createElement(
                'div',
                {
                    // 动态绑定class，同:class
                    class: {
                        'show': this.show
                    },
                    // 普通html 特性
                    attrs: {
                        id: 'element'
                    },
                    //给div绑定click事件
                    on: {
                        click: this.handleClick
                    }
                },
                '文本内容'
            )
        },
        data: function () {
            return {
                show: true
            }
        },
        methods: {
            handleClick: function () {
                console.log('clicked!');
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid43" id="p43">
                    就此例而言，template的写法明显比Render写法要可读而且简洁，所以要在合适的场景使用Render函数，否则只会增加负担。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_78 pv pid44" id="p44" name="sigil_toc_id_78">
                    9.3.2　约束</h4>
                <p class="calibre4 pv pid45" id="p45">所有的组件树中，如果VNode是组件或含有组件的slot，那么VNode必须唯一。所以下面的两个示例都是错误的。</p>
                <p class="calibre4 pv pid46" id="p46">示例一，重复使用组件，代码如下：</p>
                <pre class="calibre7 pv pid47" id="p47">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    // 局部声明组件
    var Child = {
        render: function(createElement) {
            return createElement('p', 'text');
        }
    };
    Vue.component('ele', {
        render: function (createElement) {
            // 创建一个子节点，使用组件Child
            var ChildNode = createElement(Child);
            return createElement('div', [
                ChildNode,
                ChildNode
            ]);
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid48" id="p48">示例二，重复使用含有组件的slot，代码如下：</p>
                <pre class="calibre7 pv pid49" id="p49">&lt;div id="app"&gt;
    &lt;ele&gt;
        &lt;div&gt;
            &lt;Child&gt;&lt;/Child&gt;
        &lt;/div&gt;
    &lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    // 全局注册组件
    Vue.component('Child', {
        render: function (createElement) {
            return createElement('p', 'text');
        }
    });
    Vue.component('ele', {
        render: function (createElement) {
            return createElement('div', [
                this.$slots.default,
                this.$slots.default
            ]);
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid50" id="p50">这两个示例都期望在子节点内渲染出两个Child组件，也就是两个&lt;p&gt;text&lt;/p&gt;
                    节点，实际预览时只渲染出了一个，因为在这种情况下，VNode 受到了约束。</p>
                <p class="calibre4 pv pid51" id="p51">对于重复渲染多个组件（或元素）的方法有很多，比如下面的示例：</p>
                <pre class="calibre7 pv pid52" id="p52">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    // 局部声明组件
    var Child = {
        render: function(createElement) {
            return createElement('p', 'text');
        }
    };
    Vue.component('ele', {
        render: function (createElement) {
            return createElement('div',
                Array.apply(null, {
                    length: 5
                }).map(function() {
                    return createElement(Child);
                })
            );
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid53" id="p53">
                    上例通过一个循环和工厂函数就可以渲染5个重复的子组件Child。对于含有组件的slot，复用就要稍微复杂一点了，需要将slot的每个子节点都克隆一份。示例代码如下：</p>
                <pre class="calibre7 pv pid54" id="p54">&lt;div id="app"&gt;
    &lt;ele&gt;
        &lt;div&gt;
            &lt;Child&gt;&lt;/Child&gt;
        &lt;/div&gt;
    &lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    // 全局注册组件
    Vue.component('Child', {
        render: function (createElement) {
            return createElement('p', 'text');
        }
    });
    Vue.component('ele', {
        render: function (createElement) {
            // 克隆 slot 节点的方法
            function cloneVNode (vnode) {
                // 递归遍历所有子节点，并克隆
                const clonedChildren = vnode.children &amp;&amp;
                vnode.children.map(function(vnode) {
                    return cloneVNode(vnode);
                });
                const cloned = createElement(
                    vnode.tag,
                    vnode.data,
                    clonedChildren
                );
                cloned.text = vnode.text;
                cloned.isComment = vnode.isComment;
                cloned.componentOptions = vnode.componentOptions;
                cloned.elm = vnode.elm;
                cloned.context = vnode.context;
                cloned.ns = vnode.ns;
                cloned.isStatic = vnode.isStatic;
                cloned.key = vnode.key;

                return cloned;
            }

            const vNodes = this.$slots.default;
            const clonedVNodes = vNodes.map(function(vnode) {
                return cloneVNode(vnode);
            });

            return createElement('div', [
                vNodes,
                clonedVNodes
            ]);
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid55" id="p55">
                    在Render函数里创建了一个cloneVNode的工厂函数，通过递归将slot所有子节点都克隆了一份，并对VNode的关键属性也进行复制。</p>
                <p class="calibre4 pv pid56" id="p56">深度克隆slot的做法有点偏黑科技，不过在一般业务中几乎不会遇到这样的需求，主要还是运用在独立组件中。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_79 pv pid57" id="p57" name="sigil_toc_id_79">
                    9.3.3　使用JavaScript代替模板功能</h4>
                <p class="calibre4 pv pid58" id="p58">
                    在Render函数中，不再需要Vue内置的指令，比如v-if、v-for，当然，也没办法使用它们。无论要实现什么功能，都可以用原生JavaScript。比如v-if和v-else可以这样写：</p>
                <pre class="calibre7 pv pid59" id="p59">&lt;div id="app"&gt;
    &lt;ele :show="show"&gt;&lt;/ele&gt;
    &lt;button @click="show = !show"&gt;切换 show&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            if (this.show) {
                return createElement('p', 'show的值为true');
            } else {
                return createElement('p', 'show的值为false');
            }
        },
        props: {
            show: {
                type: Boolean,
                default: false
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            show: false
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid60" id="p60">上例直接使用了JavaScript的if和else语句来完成逻辑判断。对于v-for，可以用一个简单的for循环来实现：</p>
                <pre class="calibre7 pv pid61" id="p61">&lt;div id="app"&gt;
    &lt;ele :list="list"&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            var nodes = [];
            for (var i = 0; i &lt; this.list.length; i++) {
                nodes.push(createElement('p', this.list[i]));
            }
            return createElement('div', nodes);
        },
        props: {
            list: {
                type: Array
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            list: [
                '《Vue.js实战》',
                '《JavaScript高级程序设计》',
                '《JavaScript语言精粹》'
            ]
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid62" id="p62">
                    在一开始接触Render写法时，可能会有点不适应，毕竟这种用createElement创建DOM节点的方法不够直观和可读，而且受Vue内置指令的影响，有时会绕不过弯。不过只要把它当作JavaScript一个普通的函数来使用，写习惯后就没有那么难理解了，说到底，它只是JavaScript而已。比如下面的示例展示了JavaScript的if、else语句和数组map方法充分配合使用来渲染一个列表。示例代码如下：</p>
                <pre class="calibre7 pv pid63" id="p63">&lt;div id="app"&gt;
    &lt;ele :list="list"&gt;&lt;/ele&gt;
    &lt;button @click="handleClick"&gt;显示列表&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            if (this.list.length) {
                return createElement('ul', this.list.map(function (item) {
                    return createElement('li', item);
                }));
            } else {
                return createElement('p', '列表为空');
            }
        },
        props: {
            list: {
                type: Array,
                default: function () {
                    return [];
                }
            }
        }
    });

    var app = new Vue({
        el: '#app',
        data: {
            list: []
        },
        methods: {
            handleClick: function () {
                this.list = [
                    '《Vue.js实战》',
                    '《JavaScript高级程序设计》',
                    '《JavaScript语言精粹》'
                ];
            }
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid64" id="p64">首先是判断prop：list是否为空，如果是空，就渲染一个“列表为空”的&lt;p&gt;元素；如果不为空数组，那就把每一项作为&lt;li&gt;
                    渲染，放在&lt;ul&gt;下。</p>
                <p class="kindle-cn-para-left pv pid65" id="p65">提示</p>
                <p class="kindle-cn-para-no-indent pv pid66" id="p66" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">map()方法是快速改变数组结构，返回了一个新数组，如果你不熟悉数组的这种链式操作（map 常和filter、sort等方法一起使用，因为它们返回的都是新数组），可以使用简单的for循环，这样更容易理解。</span>
                </p>
                <p class="calibre4 pv pid66" id="p66">上例的Render函数对应的template 写法如下：</p>
                <pre class="calibre7 pv pid67" id="p67">&lt;ul v-if="list.length"&gt;
    &lt;li v-for="item in list"&gt;{{ item }}&lt;/li&gt;
&lt;/ul&gt;
&lt;p v-else&gt;列表为空&lt;/p&gt;</pre>
                <p class="calibre4 pv pid68" id="p68">Render函数里也没有与v-model对应的API，需要自己来实现逻辑。示例代码如下：</p>
                <pre class="calibre7 pv pid69" id="p69">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            var _this = this;
            return createElement('div', [
                createElement('input', {
                    domProps: {
                        value: this.value
                    },
                    on: {
                        input: function (event) {
                            _this.value = event.target.value;
                        }
                    }
                }),
                createElement('p', 'value：' + this.value)
            ])
        },
        data: function () {
            return {
                value: ''
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid70" id="p70">
                    事实上，v-model就是prop：value和event：input组合使用的一个语法糖，虽然在Render里写起来比较复杂，但是可以自由控制，深入到更底层。</p>
                <p class="calibre4 pv pid71" id="p71">上例的Render函数对应的template 写法如下：</p>
                <pre class="calibre7 pv pid72" id="p72">&lt;div&gt;
    &lt;input v-model="value"&gt;
    &lt;p&gt;value：{{ value }}&lt;/p&gt;
&lt;/div&gt;</pre>
                <p class="calibre4 pv pid73" id="p73">对于事件修饰符和按键修饰符，基本也需要自己实现，表9-1列举了大部分修饰符对应的实现方案。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid74" id="p74" style="margin: 0px;"><p
                        class="kindle-cn-picture-txt-withfewcharactors">表9-1　部分事件修饰符和按键修饰符对应的句柄</p><img alt="165"
                                                                                                        class="kindle-cn-bodycontent-image-alone2"
                                                                                                        src="./index_files/7a61e3959e58897f.jpg"
                                                                                                        href="./image/00029.jpeg">
                </div>
                <p class="calibre4 pv pid74" id="p74">对于事件修饰符.capture和.once，Vue提供了特殊的前缀，可以直接写在on的配置里，如表9-2所示。</p>
                <p class="kindle-cn-picture-txt-withfewcharactors pv pid75" id="p75">表9-2　.capture和.once事件修饰符的前缀</p>
                <table cellspacing="0" class="kindle-cn-table-body pv pid76" id="p76" style="margin: 0px;">
                    <tbody>
                    <tr class="calibre8">
                        <td class="kindle-cn-table-th" width="50%">修饰符</td>
                        <td class="kindle-cn-table-th" width="50%">前缀</td>
                    </tr>
                    <tr class="calibre8">
                        <td class="kindle-cn-table-dg">.capture</td>
                        <td class="kindle-cn-table-dg">!</td>
                    </tr>
                    <tr class="calibre8">
                        <td class="kindle-cn-table-dg">.once</td>
                        <td class="kindle-cn-table-dg">~</td>
                    </tr>
                    <tr class="calibre8">
                        <td class="kindle-cn-table-dg">.capture.once或.once.capture</td>
                        <td class="kindle-cn-table-dg">~!</td>
                    </tr>
                    </tbody>
                </table>
                <p class="calibre4 pv pid76" id="p76">写法如下：</p>
                <pre class="calibre7 pv pid77" id="p77">on: {
    '!click': this.doThisInCapturingMode,
    '~keyup': this.doThisOnce,
    '~!mouseover': this.doThisOnceInCapturingMode
}</pre>
                <p class="calibre4 pv pid78" id="p78">例如，下面的示例简单模拟了聊天发送内容的场景。示例代码如下：</p>
                <pre class="calibre7 pv pid79" id="p79">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            var _this = this;
            // 渲染聊天内容列表
            if (this.list.length) {
                var listNode = createElement('ul', this.list.map(function(item) {
                    return createElement('li', item);
                }));
            } else {
                var listNode = createElement('p', '暂无聊天内容');
            }
            return createElement('div', [
                listNode,
                createElement('input', {
                    attrs: {
                        placeholder: '输入内容，按回车键发送'
                    },
                    style: {
                        width: '200px'
                    },
                    on: {
                        keyup: function (event) {
                            // 如果不是回车键，不发送数据
                            if (event.keyCode !== 13) return;
                            //添加输入的内容到聊天列表
                            _this.list.push(event.target.value);
                            // 发送后，清空输入框
                            event.target.value = '';
                        }
                    }
                })
            ])
        },
        data: function () {
            return {
                value: '',
                list: []
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid80" id="p80">
                    对于slot，我们已经介绍过可以用this.$slots来访问，在Render函数中会大量使用，不过没有使用slot时，会显示一个默认的内容，这部分逻辑需要我们自己实现。示例代码如下：</p>
                <pre class="calibre7 pv pid81" id="p81">&lt;div id="app"&gt;
    &lt;ele&gt;&lt;/ele&gt;
    &lt;ele&gt;
        &lt;p&gt;slot的内容&lt;/p&gt;
    &lt;/ele&gt;
&lt;/div&gt;
&lt;script&gt;
    Vue.component('ele', {
        render: function (createElement) {
            if (this.$slots.default === undefined) {
                return createElement('div', '没有使用slot时显示的文本');
            } else {
                return createElement('div', this.$slots.default);
            }
        }
    });

    var app = new Vue({
        el: '#app'
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid82" id="p82">this.$slots.default等于undefined，就说明父组件中没有定义slot，这时可以自定义显示的内容。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_80 pv pid83" id="p83" name="sigil_toc_id_80">9.4　函数化组件</h3>
                <p class="calibre4 pv pid84" id="p84">
                    Vue.js提供了一个functional的布尔值选项，设置为true可以使组件无状态和无实例，也就是没有data和this上下文。这样用render函数返回虚拟节点可以更容易渲染，因为函数化组件只是一个函数，渲染开销要小很多。</p>
                <p class="calibre4 pv pid85" id="p85">
                    使用函数化组件时，Render函数提供了第二个参数context来提供临时上下文。组件需要的data、props、slots、children、parent都是通过这个上下文来传递的，比如this.level要改写为context.props.level，this.$slots.default改写为context.children。</p>
                <p class="calibre4 pv pid86" id="p86">例如，下面的示例用函数化组件展示了一个根据数据智能选择不同组件的场景：</p>
                <pre class="calibre7 pv pid87" id="p87">&lt;div id="app"&gt;
    &lt;smart-item :data="data"&gt;&lt;/smart-item&gt;
    &lt;button @click="change('img')"&gt;切换为图片组件&lt;/button&gt;
    &lt;button @click="change('video')"&gt;切换为视频组件&lt;/button&gt;
    &lt;button @click="change('text')"&gt;切换为文本组件&lt;/button&gt;
&lt;/div&gt;
&lt;script&gt;
    // 图片组件选项
    var ImgItem = {
        props: ['data'],
        render: function (createElement) {
            return createElement('div', [
                createElement('p', '图片组件'),
                createElement('img', {
                    attrs: {
                        src: this.data.url
                    }
                })
            ]);
        }
    };
    // 视频组件选项
    var VideoItem = {
        props: ['data'],
        render: function (createElement) {
            return createElement('div', [
                createElement('p', '视频组件'),
                createElement('video', {
                    attrs: {
                        src: this.data.url,
                        controls: 'controls',
                        autoplay: 'autoplay'
                    }
                })
            ]);
        }
    };
    // 纯文本组件选项
    var TextItem = {
        props: ['data'],
        render: function (createElement) {
            return createElement('div', [
                createElement('p', '纯文本组件'),
                createElement('p', this.data.text)
            ]);
        }
    };
    Vue.component('smart-item', {
        //函数化组件
        functional: true,
        render: function (createElement, context) {
            // 根据传入的数据，智能判断显示哪种组件
            function getComponent () {
                var data = context.props.data;
                // 判断 prop: data的type 字段是属于哪种类型的组件
                if (data.type === 'img')   return ImgItem;
                if (data.type === 'video') return VideoItem;
                return TextItem;
            }
            return createElement(
                getComponent(),
                {
                    props: {
                        //把smart-item的prop: data传给上面智能选择的组件
                        data: context.props.data
                    }
                },
                context.children
            )
        },
        props: {
            data: {
                type: Object,
                required: true
            }
        }
    })

    var app = new Vue({
        el: '#app',
        data: {
            data: {}
        },
        methods: {
            // 切换不同类型组件的数据
            change: function (type) {
                if (type === 'img') {
                    this.data = {
                        type: 'img',
                        url: 'https://raw.githubusercontent.com/iview/
iview/master/assets/logo.png'
                    }
                } else if (type === 'video') {
                    this.data = {
                        type: 'video',
                        url: 'http://vjs.zencdn.net/v/oceans.mp4'
                    }
                } else if (type === 'text') {
                    this.data = {
                        type: 'text',
                        content: '这是一段纯文本'
                    }
                }
            }
        },
        created: function () {
            // 初始化时，默认设置图片组件的数据
            this.change('img');
        }
    })
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid88" id="p88">
                    代码片段比较长，逐步分析一下实现的内容。ImgItem、VideoItem、TextItem这3个对象分别是图片组件、视频组件和纯文本组件的选项，它们都接收一个prop：data。在函数化组件smart-item里，也有props：data，通过getComponent函数来判断其字段type的值，选择这条数据适合渲染的组件。通过createElement把getComponent()返回的对象设置为第一个参数，然后通过第二个参数把smart-item的data传递到选择的组件里的prop：data，组件渲染出不同的内容。</p>
                <p class="calibre4 pv pid89" id="p89">根实例app中的方法change用来生成不同的数据，通过3个button来切换。</p>
                <p class="calibre4 pv pid90" id="p90">该示例难理解的地方在于smart-item和3个功能组件都有prop：data，它们的传递顺序和原理看起来比较含糊。</p>
                <p class="calibre4 pv pid91" id="p91">
                    函数化组件在业务中并不是很常用，而且也有其他类似的方法来实现，比如上例也可以用组件的is特性来动态挂载。总结起来，函数化组件主要适用于以下两个场景：</p>
                <ul class="kindle-cn-ul-disc pv pid92" id="p92" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">程序化地在多个组件中选择一个。</span></li>
                    <li class="calibre6"><span
                            class="kindle-cn-specialtext-kaiti">在将children, props, data 传递给子组件之前操作它们。</span></li>
                </ul>
                <h3 class="kindle-cn-heading2 sigil_toc_id_81 pv pid92" id="p92" name="sigil_toc_id_81">9.5　JSX</h3>
                <p class="calibre4 pv pid93" id="p93">
                    使用Render函数最不友好的地方就是在模板比较简单时，写起来也很复杂，而且难以阅读出DOM结构，尤其当子节点嵌套较多时，嵌套的createElement就像盖楼一样一层层延伸下去。举一个例子，比如使用template
                    书写的模板是：</p>
                <pre class="calibre7 pv pid94" id="p94">&lt;Anchor :level="1"&gt;
    &lt;span&gt;一级&lt;/span&gt; 标题
&lt;/Anchor&gt;</pre>
                <p class="calibre4 pv pid95" id="p95">使用createElement改写后应该是：</p>
                <pre class="calibre7 pv pid96" id="p96">return createElement('Anchor', {
    props: {
        level: 1
    }
}, [
    createElement('span', '一级'),
    '标题'
]);</pre>
                <p class="calibre4 pv pid97" id="p97">
                    为了让Render函数更好地书写和阅读，Vue.js提供了插件babel-plugin-transform-vue-jsx来支持JSX语法。</p>
                <p class="calibre4 pv pid98" id="p98">
                    JSX是一种看起来像HTML，但实际是JavaScript的语法扩展，它用更接近DOM结构的形式来描述一个组件的UI和状态信息，最早在React.js里大量应用。</p>
                <p class="calibre4 pv pid99" id="p99">比如上面的Render用JSX改写后的代码是：</p>
                <pre class="calibre7 pv pid100" id="p100">new Vue({
    el: '#app',
    render (h) {
        return (
            &lt;Anchor level={1}&gt;
                &lt;span&gt;一级&lt;/span&gt; 标题
            &lt;/Anchor&gt;
        )
    }
})</pre>
                <p class="calibre4 pv pid101" id="p101">
                    上面的代码无法直接运行，需要在webpack里配置插件babel-plugin-transform-vue-jsx编译后才可以，后面章节会介绍到webpack的用法。</p>
                <p class="calibre4 pv pid102" id="p102">
                    这里的render使用了ES2015的语法缩写了函数，也会在后面的章节提到。需要注意的是，参数h不能省略，否则使用时会触发错误。</p>
                <p class="calibre4 pv pid103" id="p103">使用createElement时，常用的配置示例如下：</p>
                <pre class="calibre7 pv pid104" id="p104">render(createElement) {
    return createElement('div', {
        props: {
            text: 'some text'
        },
        attrs: {
            id: 'myDiv'
        },
        domProps: {
            innerHTML: 'content'
        },
        on: {
            change: this.changeHandler
        },
        nativeOn: {
            click: this.clickHandler
        },
        class: {
            show: true,
            on: false
        },
        style: {
            color: '#fff',
            background: '#f50'
        },
        key: 'key',
        ref: 'element',
        refInFor: true,
        slot: 'slot'
    })
}</pre>
                <p class="calibre4 pv pid105" id="p105">上面的示例使用JSX后等同于下面的代码：</p>
                <pre class="calibre7 pv pid106" id="p106">render (h) {
    return (
        &lt;div
            id="myDiv"
            domPropsInnerHTML="content"
            onChange={this.changeHandler}
            nativeOnClick={this.clickHandler}
            class={{ show: true, on: false }}
            style={{ color: '#fff', background: '#f50' }}
            key="key"
            ref="element"
            refInFor
            slot="slot"&gt;
        &lt;/div&gt;
    )
}</pre>
                <p class="calibre4 pv pid107" id="p107">
                    JSX仍然是JavaScript而不是DOM，如果你的团队不是JSX强驱动的，建议还是以模板template的方式为主，特殊场景（比如锚点标题）使用Render的createElement
                    辅助完成。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_82 pv pid108" id="p108" name="sigil_toc_id_82">
                    9.6　实战：使用Render函数开发可排序的表格组件</h3>
                <p class="calibre4 pv pid109" id="p109">
                    表格可以用来展示大量结构化的数据。本节将以Render函数为基础，开发一个可以对表格某一列数据进行排序的表格组件。最终效果如图9-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid110" id="p110" style="margin: 0px;"><img alt="173"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/988136bce4cfe90e.jpg"
                                                                                                           href="./image/00030.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-4　可排序表格组件效果图</p></div>
                <p class="calibre4 pv pid110" id="p110">一个标准的表格由&lt;table&gt;、&lt;thead&gt;、&lt;tbody&gt;、&lt;tr&gt;、&lt;th&gt;、&lt;td&gt;等元素组成。</p>
                <p class="calibre4 pv pid111" id="p111">表格组件的所有内容（表头和行数据）由两个prop构成：columns和data。两者都是数组，columns
                    用来描述每列的信息，并渲染在表头 &lt;thead&gt;内，可以指定某一列是否需要排序；data是每一行的数据，由 columns 决定每一行里各列的顺序。</p>
                <p class="calibre4 pv pid112" id="p112">按照惯例，先初始化各个文件。</p>
                <p class="calibre4 pv pid113" id="p113" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid113" id="p113">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;可排序的表格组件&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;
        &lt;v-table&gt;&lt;/v-table&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="table.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid114" id="p114" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid114" id="p114">var app = new Vue({
    el: '#app'
});</pre>
                <p class="calibre4 pv pid115" id="p115" style="margin: 0px;"><span
                        class="kindle-cn-bold">table.js：</span></p>
                <pre class="calibre7 pv pid115" id="p115">Vue.component('vTable', {
    props: {
        columns: {
            type: Array,
            default: function () {
                return [];
            }
        },
        data: {
            type: Array,
            default: function () {
                return [];
            }
        }
    }
});</pre>
                <p class="calibre4 pv pid116" id="p116">
                    为了让排序后的columns和data不影响原始数据，给v-table组件的data选项添加两个对应的数据，组件所有的操作将在这两个数据上完成，不对原始数据做任何处理：</p>
                <pre class="calibre7 pv pid117" id="p117">Vue.component('vTable', {
    // ...
    data: function () {
        return {
            currentColumns: [],
            currentData: []
        }
    }
});</pre>
                <p class="calibre4 pv pid118" id="p118">
                    columns的每一项是一个对象，其中title和key字段是必填的，用来标识这列的表头标题，key是对应data中列内容的字段名。sortable是选填字段，如果值为true，说明该列需要排序。在index.js中构造数据，比如：</p>
                <pre class="calibre7 pv pid119" id="p119">var app = new Vue({
    el: '#app',
    data: {
        columns: [
            {
                title: '姓名',
                key: 'name'
            },
            {
                title: '年龄',
                key: 'age',
                sortable: true
            }
        ],
        data: [
            {
                name: '王小明',
                age: 18,
                birthday: '1999-02-21',
                address: '北京市朝阳区芍药居'
            }
        ]
    }
});</pre>
                <p class="calibre4 pv pid120" id="p120">在index.html里，把数据传递给组件v-table：</p>
                <pre class="calibre7 pv pid121" id="p121">&lt;v-table :data="data" :columns="columns"&gt;&lt;/v-table&gt;</pre>
                <p class="calibre4 pv pid122" id="p122">
                    v-table组件目前的prop：columns和data的数据已经从父级传递过来了，不过前面介绍过，v-table不直接使用它们，而是使用data选项的currentColumns和currentData。所以在v-table初始化时，需要把columns和data赋值给currentColumns和currentData。在v-table的methods选项里定义两个方法用来赋值，并在mounted钩子内调用：</p>
                <pre class="calibre7 pv pid123" id="p123">Vue.component('vTable', {
    // ...
    methods: {
        makeColumns: function () {
            this.currentColumns = this.columns.map(function (col, index) {
                //添加一个字段标识当前列排序的状态，后续使用
                col._sortType = 'normal';
                //添加一个字段标识当前列在数组中的索引，后续使用
                col._index = index;
                return col;
            });
        },
        makeData: function () {
            this.currentData = this.data.map(function (row, index) {
                //添加一个字段标识当前行在数组中的索引，后续使用
                row._index = index;
                return row;
            });
        }
    },
    mounted () {
        // v-table 初始化时调用
        this.makeColumns();
        this.makeData();
    }
});</pre>
                <p class="calibre4 pv pid124" id="p124">
                    map()是JavaScript数组的一个方法，根据传入的函数重新构造一个新数组。排序分升序（asc）和降序（desc）两种，而且同时只能对一列数据进行排序，与其他列互斥，为了标识当前列的排序状态，在map列添加数据时，默认给每列都添加一个_sortType的字段，并且赋值为normal，表示默认排序（也就是不排序）。在排序后，currentData每项的顺序可能都会发生变化，所以给currentColumns和currentData的每个数据都添加_index字段，代表当前数据在原始数据中的索引。</p>
                <p class="calibre4 pv pid125" id="p125">有了数据，下面就来用Render函数构造虚拟DOM。</p>
                <p class="calibre4 pv pid126" id="p126">表格的最外层是&lt;table&gt;元素，里面包含了&lt;thead&gt;表头和&lt;tbody&gt;表格主体。thead是一行多列（一个&lt;tr&gt;、多个&lt;th&gt;），tbody是多行多列（多个&lt;tr&gt;、多个&lt;td&gt;）。先由外至内构建出大致的DOM结构：</p>
                <pre class="calibre7 pv pid127" id="p127">Vue.component('vTable', {
    // ...
    render: function(h) {
        var ths = [];
        var trs = [];
        return h('table',[
            h('thead', [
                h('tr', ths)
            ]),
            h('tbody', trs)
        ])
    }
    // ...
});</pre>
                <p class="calibre4 pv pid128" id="p128">
                    这里的h就是createElement，只是换了个名称。表格主体trs是一个二维数组，数据由currentColumns和CurrentData组成：</p>
                <pre class="calibre7 pv pid129" id="p129">render: function(h) {
    var _this = this;
    // ...
    var trs = [];
    this.currentData.forEach(function(row) {
        var tds = [];
        _this.currentColumns.forEach(function(cell) {
            tds.push(h('td', row[cell.key]));
        });
        trs.push(h('tr', tds));
    });
    // ...
}</pre>
                <p class="calibre4 pv pid130" id="p130">先遍历所有的行，然后在每一行内再遍历各列，最终组合出主体内容节点 trs。</p>
                <p class="calibre4 pv pid131" id="p131">表头的节点ths要相对复杂一点，因为有排序的功能：</p>
                <pre class="calibre7 pv pid132" id="p132">render: function(h) {
    var _this = this;
    var ths = [];
    this.currentColumns.forEach(function(col, index) {
        if (col.sortable) {
            ths.push(h('th', [
                h('span', col.title),
                // 升序
                h('a', {
                    class: {
                        on: col._sortType === 'asc'
                    },
                    on: {
                        click: function () {
                            _this.handleSortByAsc(index)
                        }
                    }
                }, '↑'),
                // 降序
                h('a', {
                    class: {
                        on: col._sortType === 'desc'
                    },
                    on: {
                        click: function () {
                            _this.handleSortByDesc(index)
                        }
                    }
                }, '↓')
            ]));
        } else {
            ths.push(h('th', col.title));
        }
    });
    // ...
}</pre>
                <p class="calibre4 pv pid133" id="p133">如果col.sortable没有定义，或值为false，就直接把col.title渲染出来，否则除了渲染title，还加了两个&lt;a&gt;元素来实现升序和降序的操作。handleSortByAsc和handleSortByDesc代码如下：</p>
                <pre class="calibre7 pv pid134" id="p134">Vue.component('vTable', {
    // ...
    methods: {
        handleSortByAsc: function (index) {
            var key = this.currentColumns[index].key;
            this.currentColumns.forEach(function (col) {
                col._sortType = 'normal';
            });
            this.currentColumns[index]._sortType = 'asc';

            this.currentData.sort(function (a, b) {
                return a[key] &gt; b[key] ? 1 : -1;
            });
        },
        handleSortByDesc: function (index) {
            var key = this.currentColumns[index].key;
            this.currentColumns.forEach(function (col) {
                col._sortType = 'normal';
            });
            this.currentColumns[index]._sortType = 'desc';

            this.currentData.sort(function (a, b) {
                return a[key] &lt; b[key] ? 1 : -1;
            });
        }
    }
    // ...
});</pre>
                <p class="calibre4 pv pid135" id="p135">
                    两个方法基本类似（读者可尝试将两个方法合并为一个），一个是升序操作，一个是降序操作，目的都是改变currentColumns数组每项的顺序。排序使用了JavaScript数组的sort()方法，这里之所以返回1和-1，而不直接返回a[key]
                    &lt;
                    b[key]，也就是true或false，是因为在部分浏览器（比如Safari）对sort()的处理不同，而1和-1可以做到兼容。排序前，先将所有列的排序状态都重置为normal，然后设置当前列的排序状态（asc或desc），对应到render里&lt;a&gt;元素的class名称on，后面会通过CSS来高亮显示当前列的排序状态。</p>
                <p class="calibre4 pv pid136" id="p136">
                    当渲染完表格后，父级修改了data数据，比如增加或删除，v-table的currentData也应该更新，如果某列已经存在排序状态，更新后应该直接处理一次排序。其代码如下：</p>
                <pre class="calibre7 pv pid137" id="p137">Vue.component('vTable', {
    // ...
    watch: {
        data: function () {
            this.makeData();
            var sortedColumn = this.currentColumns.filter(function (col) {
                return col._sortType !== 'normal';
            });

            if (sortedColumn.length &gt; 0) {
                if (sortedColumn[0]._sortType === 'asc') {
                    this.handleSortByAsc(sortedColumn[0]._index);
                } else {
                    this.handleSortByDesc(sortedColumn[0]._index);
                }
            }
        }
    }
    // ...
});</pre>
                <p class="calibre4 pv pid138" id="p138">
                    通过遍历currentColumns来找出是否按某一列进行过排序，如果有，就按照当前排序状态对更新后的数据做一次排序操作。</p>
                <p class="calibre4 pv pid139" id="p139">以下是完整的代码。</p>
                <p class="calibre4 pv pid140" id="p140" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid140" id="p140">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;可排序的表格组件&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak&gt;
        &lt;v-table :data="data" :columns="columns"&gt;&lt;/v-table&gt;
        &lt;button @click="handleAddData"&gt;添加数据&lt;/button&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="table.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid141" id="p141" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid141" id="p141">var app = new Vue({
    el: '#app',
    data: {
        columns: [
            {
                title: '姓名',
                key: 'name'
            },
            {
                title: '年龄',
                key: 'age',
                sortable: true
            },
            {
                title: '出生日期',
                key: 'birthday',
                sortable: true
            },
            {
                title: '地址',
                key: 'address'
            }
        ],
        data: [
            {
                name: '王小明',
                age: 18,
                birthday: '1999-02-21',
                address: '北京市朝阳区芍药居'
            },
            {
                name: '张小刚',
                age: 25,
                birthday: '1992-01-23',
                address: '北京市海淀区西二旗'
            },
            {
                name: '李小红',
                age: 30,
                birthday: '1987-11-10',
                address: '上海市浦东新区世纪大道'
            },
            {
                name: '周小伟',
                age: 26,
                birthday: '1991-10-10',
                address: '深圳市南山区深南大道'
            }
        ]
    },
    methods: {
        handleAddData: function () {
            this.data.push({
                name: '刘小天',
                age: 19,
                birthday: '1998-05-30',
                address: '北京市东城区东直门'
            });
        }
    }
});</pre>
                <p class="calibre4 pv pid142" id="p142" style="margin: 0px;"><span
                        class="kindle-cn-bold">table.js：</span></p>
                <pre class="calibre7 pv pid142" id="p142">Vue.component('vTable', {
    props: {
        columns: {
            type: Array,
            default: function () {
                return [];
            }
        },
        data: {
            type: Array,
            default: function () {
                return [];
            }
        }
    },
    data: function () {
        return {
            currentColumns: [],
            currentData: []
        }
    },
    render: function(h) {
        var _this = this;
        var ths = [];
        this.currentColumns.forEach(function(col, index) {
            if (col.sortable) {
                ths.push(h('th', [
                    h('span', col.title),
                    h('a', {
                        class: {
                            on: col._sortType === 'asc'
                        },
                        on: {
                            click: function () {
                                _this.handleSortByAsc(index)
                            }
                        }
                    }, '↑'),
                    h('a', {
                        class: {
                            on: col._sortType === 'desc'
                        },
                        on: {
                            click: function () {
                                _this.handleSortByDesc(index)
                            }
                        }
                    }, '↓')
                ]));
            } else {
                ths.push(h('th', col.title));
            }
        });

        var trs = [];
        this.currentData.forEach(function(row) {
            var tds = [];
            _this.currentColumns.forEach(function(cell) {
                tds.push(h('td', row[cell.key]));
            });
            trs.push(h('tr', tds));
        });
        return h('table',[
            h('thead', [
                h('tr', ths)
            ]),
            h('tbody', trs)
        ])
    },
    methods: {
        makeColumns: function () {
            this.currentColumns = this.columns.map(function (col, index) {
                col._sortType = 'normal';
                col._index = index;
                return col;
            });
        },
        makeData: function () {
            this.currentData = this.data.map(function(row, index) {
                row._index = index;
                return row;
            });
        },
        handleSortByAsc: function (index) {
            var key = this.currentColumns[index].key;
            this.currentColumns.forEach(function (col) {
                col._sortType = 'normal';
            });
            this.currentColumns[index]._sortType = 'asc';

            this.currentData.sort(function (a, b) {
                return a[key] &gt; b[key] ? 1 : -1;
            });
        },
        handleSortByDesc: function (index) {
            var key = this.currentColumns[index].key;
            this.currentColumns.forEach(function (col) {
                col._sortType = 'normal';
            });
            this.currentColumns[index]._sortType = 'desc';

            this.currentData.sort(function (a, b) {
                return a[key] &lt; b[key] ? 1 : -1;
            });
        }
    },
    watch: {
        data: function () {
            this.makeData();
            var sortedColumn = this.currentColumns.filter(function (col) {
                return col._sortType !== 'normal';
            });

            if (sortedColumn.length &gt; 0) {
                if (sortedColumn[0]._sortType === 'asc') {
                    this.handleSortByAsc(sortedColumn[0]._index);
                } else {
                    this.handleSortByDesc(sortedColumn[0]._index);
                }
            }
        }
    },
    mounted () {
        this.makeColumns();
        this.makeData();
    }
});</pre>
                <p class="calibre4 pv pid143" id="p143" style="margin: 0px;"><span
                        class="kindle-cn-bold">style.css：</span></p>
                <pre class="calibre7 pv pid143" id="p143">[v-cloak]{
    display: none;
}
table{
    width: 100%;
    margin-bottom: 24px;
    border-collapse: collapse;
    border-spacing: 0;
    empty-cells: show;
    border: 1px solid #e9e9e9;
}
table th{
    background: #f7f7f7;
    color: #5c6b77;
    font-weight: 600;
    white-space: nowrap;
}
table td, table th{
    padding: 8px 16px;
    border: 1px solid #e9e9e9;
    text-align: left;
}
table th a{
    display: inline-block;
    margin: 0 4px;
    cursor: pointer;
}
table th a.on{
    color: #3399ff;
}
table th a:hover{
    color: #3399ff;
}</pre>
                <p class="calibre4 pv pid144" id="p144" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>查阅资料，了解表格的&lt;colgroup&gt;和&lt;col&gt;元素用法后，给v-table的columns增加一个可以设置列宽的width字段，并实现该功能。
                </p>
                <p class="calibre4 pv pid144" id="p144" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>将该示例的render写法改写为template写法，加以对比，总结出两者的差异性，深刻理解其使用场景。
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_83 pv pid144" id="p144" name="sigil_toc_id_83">
                    9.7　实战：留言列表</h3>
                <p class="calibre4 pv pid145" id="p145">本节将继续使用Render函数来完成一个留言列表的小功能，效果如图9-5所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid146" id="p146" style="margin: 0px;"><img alt="186"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/eef26c9b0a0417c6.jpg"
                                                                                                           href="./image/00031.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-5　留言列表效果图</p></div>
                <p class="calibre4 pv pid146" id="p146">
                    与之前的几个实战案例不同的是，留言列表更偏向于业务，而之前的实战（数字输入框、标签页、表格）都是独立的功能组件。将留言列表用组件树展示，如图9-6所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid147" id="p147" style="margin: 0px;"><img alt="186-2"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/1fdc76e1b04663b5.jpg"
                                                                                                           href="./image/00032.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-6　留言列表组件树</p></div>
                <p class="calibre4 pv pid147" id="p147">先来初始化各个文件。</p>
                <p class="calibre4 pv pid148" id="p148" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid148" id="p148">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;留言列表&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak style="width: 500px;margin: 0 auto;"&gt;
        &lt;div class="message"&gt;

        &lt;/div&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="input.js"&gt;&lt;/script&gt;
    &lt;script src="list.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid149" id="p149" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid149" id="p149">var app = new Vue({
    el: '#app'
});</pre>
                <p class="calibre4 pv pid150" id="p150" style="margin: 0px;"><span
                        class="kindle-cn-bold">input.js：</span></p>
                <pre class="calibre7 pv pid150" id="p150">Vue.component('vInput', {

});

Vue.component('vTextarea', {

});</pre>
                <p class="calibre4 pv pid151" id="p151">发布一条留言，需要的数据有昵称和留言内容，发布操作应该在根实例app内完成。留言列表的数据也是从app
                    获取的。所以在index.js中添加这3项数据：</p>
                <pre class="calibre7 pv pid152" id="p152">var app = new Vue({
    el: '#app',
    data: {
        username: '',
        message: '',
        list: []
    },
    methods: {
        handleSend: function () {
            this.list.push({
                name: this.username,
                message: this.message
            });
            this.message = '';
        }
    }
});</pre>
                <p class="calibre4 pv pid153" id="p153">
                    数组list存储了所有的留言内容，通过函数handleSend给list添加一项留言数据，添加成功后，把textarea文本框置空。在index.html中，使用v-model将username和message
                    双向绑定：</p>
                <pre class="calibre7 pv pid154" id="p154">&lt;v-input v-model="username"&gt;&lt;/v-input&gt;
&lt;v-textarea v-model="message"&gt;&lt;/v-textarea&gt;</pre>
                <p class="calibre4 pv pid155" id="p155">
                    9.3节里已经介绍过Render函数内的节点如何使用v-model：动态绑定value，并且监听input事件，把输入的内容通过$emit('input')派发给父组件。所以组件v-input的代码如下：</p>
                <pre class="calibre7 pv pid156" id="p156">Vue.component('vInput', {
    props: {
        value: {
            type: [String, Number],
            default: ''
        }
    },
    render: function (h) {
        var _this = this;
        return h('div', [
            h('span', '昵称：'),
            h('input', {
                attrs: {
                    type: 'text'
                },
                domProps: {
                    value: this.value
                },
                on: {
                    input: function (event) {
                        _this.value = event.target.value;
                        _this.$emit('input', event.target.value);
                    }
                }
            })
        ]);
    }
});</pre>
                <p class="calibre4 pv pid157" id="p157">v-textarea与v-input基本一致，可查看后面的完整代码。</p>
                <p class="calibre4 pv pid158" id="p158">列表的节点树如图9-7所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid159" id="p159" style="margin: 0px;"><img alt="189"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/1f58b53a7cf225de.jpg"
                                                                                                           href="./image/00033.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图9-7　列表树示意图</p></div>
                <p class="calibre4 pv pid159" id="p159">
                    列表数据list为空时，渲染一个“列表为空”的信息提示节点；不为空时，每个list-item应包含昵称、留言内容和回复按钮3个子节点。list.js的render内容如下：</p>
                <pre class="calibre7 pv pid160" id="p160">render: function (h) {
    var _this = this;
    var list = [];
    this.list.forEach(function (msg, index) {
        var node = h('div', {
            attrs: {
                class: 'list-item'
            }
        }, [
            h('span', msg.name + '：'),
            h('div', {
                attrs: {
                    class: 'list-msg'
                }
            }, [
                h('p', msg.message),
                h('a', {
                    attrs: {
                        class: 'list-reply'
                    },
                    on: {
                        click: function () {
                            _this.handleReply(index);
                        }
                    }
                }, '回复')
            ])
        ])
        list.push(node);
    });
    if (this.list.length) {
        return h('div', {
            attrs: {
                class: 'list'
            },
        }, list);
    } else {
        return h('div', {
            attrs: {
                class: 'list-nothing'
            }
        }, '留言列表为空');
    }
}</pre>
                <p class="calibre4 pv pid161" id="p161">
                    this.list.forEach相当于template里的v-for指令，遍历出每条留言。句柄handleReply直接向父组件派发一个事件reply，父组件（app）接收后，将当前
                    list-item的昵称提取，并设置到v-textarea内。相关代码如下：</p>
                <pre class="calibre7 pv pid162" id="p162">// list.js
handleReply: function (index) {
    this.$emit('reply', index);
}

// index.html
&lt;list :list="list" @reply=“handleReply"&gt;&lt;/list&gt;

// index.js
handleReply: function (index) {
    var name = this.list[index].name;
    this.message = '回复@' + name + '：';
}</pre>
                <p class="calibre4 pv pid163" id="p163">
                    还有剩余的几个小细节，比如点击回复按钮后，文本框立刻聚焦；提交留言前，做非空判断，读者可在完整代码中继续探索。完整代码如下。</p>
                <p class="calibre4 pv pid164" id="p164" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.html：</span></p>
                <pre class="calibre7 pv pid164" id="p164">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;留言列表&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app" v-cloak style="width: 500px;margin: 0 auto;"&gt;
        &lt;div class="message"&gt;
            &lt;v-input v-model="username"&gt;&lt;/v-input&gt;
            &lt;v-textarea v-model="message" ref="message"&gt;&lt;/v-textarea&gt;
            &lt;button @click="handleSend"&gt;发布&lt;/button&gt;
        &lt;/div&gt;
        &lt;list :list="list" @reply="handleReply"&gt;&lt;/list&gt;
    &lt;/div&gt;
    &lt;script src="https://unpkg.com/vue/dist/vue.min.js"&gt;&lt;/script&gt;
    &lt;script src="input.js"&gt;&lt;/script&gt;
    &lt;script src="list.js"&gt;&lt;/script&gt;
    &lt;script src="index.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid165" id="p165" style="margin: 0px;"><span
                        class="kindle-cn-bold">index.js：</span></p>
                <pre class="calibre7 pv pid165" id="p165">var app = new Vue({
    el: '#app',
    data: {
        username: '',
        message: '',
        list: []
    },
    methods: {
        handleSend: function () {
            if (this.username === '') {
                window.alert('请输入昵称');
                return;
            }
            if (this.message === '') {
                window.alert('请输入留言内容');
                return;
            }
            this.list.push({
                name: this.username,
                message: this.message
            });
            this.message = '';
        },
        handleReply: function (index) {
            var name = this.list[index].name;
            this.message = '回复@' + name + '：';
            this.$refs.message.focus();
        }
    }
});</pre>
                <p class="calibre4 pv pid166" id="p166" style="margin: 0px;"><span
                        class="kindle-cn-bold">input.js：</span></p>
                <pre class="calibre7 pv pid166" id="p166">Vue.component('vInput', {
    props: {
        value: {
            type: [String, Number],
            default: ''
        }
    },
    render: function (h) {
        var _this = this;
        return h('div', [
            h('span', '昵称：'),
            h('input', {
                attrs: {
                    type: 'text'
                },
                domProps: {
                    value: this.value
                },
                on: {
                    input: function (event) {
                        _this.value = event.target.value;
                        _this.$emit('input', event.target.value);
                    }
                }
            })
        ]);
    }
});

Vue.component('vTextarea', {
    props: {
        value: {
            type: String,
            default: ''
        }
    },
    render: function (h) {
        var _this = this;
        return h('div', [
            h('span', '留言内容：'),
            h('textarea', {
                attrs: {
                    placeholder: '请输入留言内容'
                },
                domProps: {
                    value: this.value
                },
                ref: 'message',
                on: {
                    input: function (event) {
                        _this.value = event.target.value;
                        _this.$emit('input', event.target.value);
                    }
                }
            })
        ]);
    },
    methods: {
        focus: function () {
            this.$refs.message.focus();
        }
    }
});</pre>
                <p class="calibre4 pv pid167" id="p167" style="margin: 0px;"><span
                        class="kindle-cn-bold">list.js：</span></p>
                <pre class="calibre7 pv pid167" id="p167">Vue.component('list', {
    props: {
        list: {
            type: Array,
            default: function () {
                return [];
            }
        }
    },
    render: function (h) {
        var _this = this;
        var list = [];
        this.list.forEach(function (msg, index) {
            var node = h('div', {
                attrs: {
                    class: 'list-item'
                }
            }, [
                h('span', msg.name + '：'),
                h('div', {
                    attrs: {
                        class: 'list-msg'
                    }
                }, [
                    h('p', msg.message),
                    h('a', {
                        attrs: {
                            class: 'list-reply'
                        },
                        on: {
                            click: function () {
                                _this.handleReply(index);
                            }
                        }
                    }, '回复')
                ])
            ])
            list.push(node);
        });
        if (this.list.length) {
            return h('div', {
                attrs: {
                    class: 'list'
                },
            }, list);
        } else {
            return h('div', {
                attrs: {
                    class: 'list-nothing'
                }
            }, '留言列表为空');
        }
    },
    methods: {
        handleReply: function (index) {
            this.$emit('reply', index);
        }
    }
});</pre>
                <p class="calibre4 pv pid168" id="p168" style="margin: 0px;"><span
                        class="kindle-cn-bold">style.css：</span></p>
                <pre class="calibre7 pv pid168" id="p168">[v-cloak]{
    display: none;
}
*{
    padding: 0;
    margin: 0;
}
.message{
    width: 450px;
    text-align: right;
}
.message div{
    margin-bottom: 12px;
}
.message span{
    display: inline-block;
    width: 100px;
    vertical-align: top;
}
.message input, .message textarea{
    width: 300px;
    height: 32px;
    padding: 0 6px;
    color: #657180;
    border: 1px solid #d7dde4;
    border-radius: 4px;
    cursor: text;
    outline: none;
}
.message input:focus, .message textarea:focus{
    border: 1px solid #3399ff;
}
.message textarea{
    height: 60px;
    padding: 4px 6px;
}
.message button{
    display: inline-block;
    padding: 6px 15px;
    border: 1px solid #39f;
    border-radius: 4px;
    color: #fff;
    background-color: #39f;
    cursor: pointer;
    outline: none;
}
.list{
    margin-top: 50px;
}
.list-item{
    padding: 10px;
    border-bottom: 1px solid #e3e8ee;
    overflow: hidden;
}
.list-item span{
    display: block;
    width: 60px;
    float: left;
    color: #39f;
}
.list-msg{
    display: block;
    margin-left: 60px;
    text-align: justify;
}
.list-msg a{
    color: #9ea7b4;
    cursor: pointer;
    float: right;
}
.list-msg a:hover{
    color: #39f;
}
.list-nothing{
    text-align: center;
    color: #9ea7b4;
    padding: 20px;
}</pre>
                <p class="calibre4 pv pid169" id="p169" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>给每条留言都增加一个删除的功能。
                </p>
                <p class="calibre4 pv pid169" id="p169" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>将该示例的render写法改写为template写法，加以对比，总结出两者的差异性，深刻理解其使用场景。
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_84 pv pid169" id="p169" name="sigil_toc_id_84">9.8　总结</h3>
                <p class="calibre4 pv pid170" id="p170">
                    本章两个实战的练习题中都有用template写法还原render函数，目的是充分理解render函数的使用场景。如果你已经做了还原，应该会发现使用template写法更简单、可读，尤其是第二个示例。的确，这两个实战示例都更适合用template来实现，在业务中，生产效率是第一位，所以绝大部分业务代码都应当用template来完成。你不用在意性能问题，如果使用了webpack做编译（后面章节会介绍），template都会被预编译为render函数。</p>
                <p class="calibre4 pv pid171" id="p171">
                    在本书一开始介绍Vue.js时，就提到过它是一个渐进式JavaScript框架。Vue.js的基本用法到本章就结束了，到目前为止，所有的示例都是通过&lt;script&gt;引入Vue.js和其他文件来运行的，从下一章开始，将陆续介绍前端工程化和Vue生态。</p>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="101" data-chapter-url="24047098" alt="64157355">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第10章　使用webpack</h2>
                <p class="calibre4 pv pid3" id="p3">
                    高效的开发离不开基础工程的搭建。本章主要介绍目前热门的JavaScript应用程序的模块打包工具webpack。在开始学习本章前，需要先安装Node.js和NPM，如果你不熟悉它们，可以先查阅相关资料，完成安装并了解NPM最基本的用法。</p>
                <p class="kindle-cn-para-left pv pid4" id="p4">提示</p>
                <p class="kindle-cn-para-no-indent pv pid5" id="p5" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本章所介绍的webpack是指webpack 2版本。</span></p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_85 pv pid5" id="p5" name="sigil_toc_id_85">
                    10.1　前端工程化与webpack</h3>
                <p class="calibre4 pv pid6" id="p6">
                    近几年来，前端领域发展迅速，前端的工作早已不再是切几张图那么简单，项目比较大时，可能会多人协同开发。模块化、组件化、CSS预编译等概念也成了经常讨论的话题。</p>
                <p class="calibre4 pv pid7" id="p7">通常，前端自动化（半自动化）工程主要解决以下问题：</p>
                <p class="kindle-cn-exam-choice pv pid8" id="p8" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">· JavaScript、CSS 代码的· 合并和压缩。<br class="calibre5">· CSS 预处理：Less、Sass、Stylus的编译。<br
                        class="calibre5">· 生成雪碧图（CSS Sprite）。<br class="calibre5">· ES 6 转 ES 5。<br class="calibre5">· 模块化。</span><br
                        class="calibre5">……</p>
                <p class="calibre4 pv pid8" id="p8">
                    如果使用过Gulp，并且了解RequireJS，上面几个问题应该难不倒你。只需配置几行代码，就可以实现对JS代码的合并与压缩。不过，经过Gulp合并压缩后的代码仍然是你写的代码，只是局部变量名被替换，一些语法做了转换而已，整体内容并没有发生变化。而本章要介绍的前端工程化工具webpack，打包后的代码已经不只是你写的代码，其中夹杂了很多webpack自身的模块处理代码。因此，学习webpack最难的是理解“编译”的这个概念，否则会一直存在一个疑问：为什么要这样做？</p>
                <p class="calibre4 pv pid9" id="p9">图10-1是来自webpack官方网站（https://webpack.js.org/）经典的模块化示意图。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid10" id="p10" style="margin: 0px;"><img alt="199"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/0535a983862e92b7.jpg"
                                                                                                         href="./image/00034.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-1　webpack模块化示意图</p></div>
                <p class="calibre4 pv pid10" id="p10">
                    左边是在业务中写的各种格式的文件，比如typescript、less、jpg，还有本章后面要介绍的.vue格式的文件。这些格式的文件通过特定的加载器（Loader）编译后，最终统一生成为.js、.css、.png等静态资源文件。在webpack的世界里，一张图片、一个css甚至一个字体，都称为模块（Module），彼此存在依赖关系，webpack就是来处理模块间的依赖关系的，并把它们进行打包。</p>
                <p class="calibre4 pv pid11" id="p11">举一个简单的例子，平时加载CSS大多通过&lt;link&gt;标签引入CSS文件，而在webpack里，直接在一个.js文件中导入，比如：</p>
                <pre class="calibre7 pv pid12" id="p12">import 'src/styles/index.css';</pre>
                <p class="calibre4 pv pid13" id="p13">import是ES 2015的语法，这里也可以写成require('src/styles/index.css')
                    。在打包时，index.css会被打包进一个js文件里，通过动态创建&lt;style&gt;的形式来加载css样式，当然也可以进一步配置，在打包编译时把所有的css都提取出来，生成一个css的文件，后面会详细介绍。</p>
                <p class="calibre4 pv pid14" id="p14">
                    webpack的主要适用场景是单页面富应用（SPA）。SPA通常是由一个html文件和一堆按需加载的js组成，它的html结构可能会非常简单，比如：</p>
                <pre class="calibre7 pv pid15" id="p15">&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;webpack app&lt;/title&gt;
    &lt;link rel="stylesheet" href="dist/main.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="dist/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid16" id="p16">看起来很简单是吧？只有一个&lt;div&gt;节点，所有的代码都集成在了神奇的main.js文件中，理论上它可以实现像知乎、淘宝这样大型的项目。</p>
                <p class="calibre4 pv pid17" id="p17">
                    在开始讲解webpack的用法前，先介绍两个ES6中的语法export和import，因为在后面会大量使用，如果对它不了解，可能会感到很困惑。</p>
                <p class="calibre4 pv pid18" id="p18">
                    export和import是用来导出和导入模块的。一个模块就是一个js文件，它拥有独立的作用域，里面定义的变量外部是无法获取的。比如将一个配置文件作为模块导出，示例代码如下：</p>
                <pre class="calibre7 pv pid19" id="p19">// config.js
var Config = {
    version: '1.0.0'
};
export { Config };</pre>
                <p class="calibre4 pv pid20" id="p20">或：</p>
                <pre class="calibre7 pv pid21" id="p21">// config.js
export var Config = {
    version: '1.0.0'
};</pre>
                <p class="calibre4 pv pid22" id="p22">其他类型（比如函数、数组、常量等）也可以导出，比如导出一个函数：</p>
                <pre class="calibre7 pv pid23" id="p23">// add.js
export function add(a, b) {
    return a + b;
};</pre>
                <p class="calibre4 pv pid24" id="p24">模块导出后，在需要使用模块的文件使用import再导入，就可以在这个文件内使用这些模块了。示例代码如下：</p>
                <pre class="calibre7 pv pid25" id="p25">// main.js
import { Config } from './config.js';
import { add } from './add.js';

console.log(Config);  // { version: '1.0.0' }
console.log(add(1, 1));  // 2</pre>
                <p class="calibre4 pv pid26" id="p26">
                    以上几个示例中，导入的模块名称都是在export的文件中设置的，也就是说用户必须预先知道这个名称叫什么，比如Config、add。而有的时候，用户不想去了解名称是什么，只是把模块的功能拿来使用，或者想自定义名称，这时可以使用export
                    default来输出默认的模块。示例代码如下：</p>
                <pre class="calibre7 pv pid27" id="p27">// config.js
export default {
    version: '1.0.0'
};

// add.js
export default function (a, b) {
    return a + b;
};

// main.js
import conf from './config.js';
import Add from './add.js';

console.log(conf);  // { version: '1.0.0' }
console.log(Add(1, 1));  // 2</pre>
                <p class="calibre4 pv pid28" id="p28">如果使用npm安装了一些库，在webpack中可以直接导入，示例代码如下：</p>
                <pre class="calibre7 pv pid29" id="p29">import Vue from 'vue';
import $ from 'jquery';</pre>
                <p class="calibre4 pv pid30" id="p30">上例分别导入了Vue和jQuery的库，并且命名为Vue和$，在这个文件中就可以使用这两个模块。</p>
                <p class="calibre4 pv pid31" id="p31">export和import还有其他的用法，这里不做太详细的介绍，如果有兴趣，可以查阅相关资料进一步学习。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_86 pv pid32" id="p32" name="sigil_toc_id_86">
                    10.2　webpack基础配置</h3><h4 class="kindle-cn-heading3 sigil_toc_id_87 pv pid33" id="p33"
                                             name="sigil_toc_id_87">10.2.1　安装webpack与webpack-dev-server</h4>
                <p class="calibre4 pv pid34" id="p34">
                    本节将从基础的webpack安装开始介绍，逐步完成对Vue工程的配置。在开始学习本节前，先确保已经安装了最新版的Node.js和NPM，并已经了解NPM的基本用法。</p>
                <p class="calibre4 pv pid35" id="p35">首先，创建一个目录，比如demo，使用NPM初始化配置：</p>
                <pre class="calibre7 pv pid36" id="p36">npm init</pre>
                <p class="calibre4 pv pid37" id="p37">执行后，会有一系列选项，可以按回车键快速确认，完成后会在demo目录生成一个package.json的文件。</p>
                <p class="calibre4 pv pid38" id="p38">之后在本地局部安装 webpack：</p>
                <pre class="calibre7 pv pid39" id="p39">npm install webpack --save-dev</pre>
                <p class="calibre4 pv pid40" id="p40">--save-dev会作为开发依赖来安装 webpack。安装成功后，在package.json中会多一项配置：</p>
                <pre class="calibre7 pv pid41" id="p41">"devDependencies": {
    "webpack": "^2.3.2"
}</pre>
                <p class="calibre4 pv pid42" id="p42">
                    接着需要安装webpack-dev-server，它可以在开发环境中提供很多服务，比如启动一个服务器、热更新、接口代理等，配置起来也很简单。同样，在本地局部安装：</p>
                <pre class="calibre7 pv pid43" id="p43">npm install webpack-dev-server --save-dev</pre>
                <p class="calibre4 pv pid44" id="p44">安装完成后，最终的package.json文件内容为：</p>
                <pre class="calibre7 pv pid45" id="p45">{
  "name": "demo",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^2.3.2",
    "webpack-dev-server": "^2.4.2"
  }
}</pre>
                <p class="calibre4 pv pid46" id="p46">
                    如果你的devDependencies中包含webpack和webpack-dev-server，恭喜你，已经安装成功，很快就可以启动webpack 工程了。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_88 pv pid47" id="p47" name="sigil_toc_id_88">
                    10.2.2　就是一个js文件而已</h4>
                <p class="calibre4 pv pid48" id="p48">接下来需要了解webpack的一些核心概念。</p>
                <p class="calibre4 pv pid49" id="p49">
                    归根到底，webpack就是一个.js配置文件，你的架构好或差都体现在这个配置里，随着需求的不断出现，工程配置也是逐渐完善的。我们从浅入深，一步步来支持更多的功能。</p>
                <p class="calibre4 pv pid50" id="p50">首先在目录DEMO下创建一个js文件：webpack.config.js，并初始化它的内容：</p>
                <pre class="calibre7 pv pid51" id="p51">var config = {

};

module.exports = config;</pre>
                <p class="kindle-cn-para-left pv pid52" id="p52">提示</p>
                <p class="kindle-cn-para-no-indent pv pid53" id="p53" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">这里的module.exports = config; 相当于export default config;。由于目前还没有安装支持ES6的编译插件，因此不能直接使用ES6的语法，否则会报错。</span>
                </p>
                <p class="calibre4 pv pid53" id="p53">然后在package.json的scripts里增加一个快速启动webpack-dev-server服务的脚本：</p>
                <pre class="calibre7 pv pid54" id="p54">{
  // ...
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1",
    "dev": "webpack-dev-server --open --config webpack.config.js"
  },
  // ...
}</pre>
                <p class="calibre4 pv pid55" id="p55">当运行npm run dev命令时，就会执行webpack-dev-server --open --config
                    webpack.config.js命令。其中--config是指向webpack-dev-server读取的配置文件路径，这里直接读取我们在上一步创建的webpack.config.js文件。--open会在执行命令时自动在浏览器打开页面，默认地址是127.0.0.1:8080，不过IP和端口都是可以配置的，比如：</p>
                <pre class="calibre7 pv pid56" id="p56">{
  "scripts": {
    "dev": "webpack-dev-server --host 172.172.172.1 --port 8888 --open --config webpack.config.js"
  }
}</pre>
                <p class="calibre4 pv pid57" id="p57">
                    这样访问地址就改为了172.172.172.1:8888。一般在局域网下，需要让其他同事访问时可以这样配置，否则用默认的127.0.0.1（localhost）就可以了。</p>
                <p class="calibre4 pv pid58" id="p58">
                    webpack配置中最重要也是必选的两项是入口（Entry）和出口（Output）。入口的作用是告诉webpack从哪里开始寻找依赖，并且编译，出口则用来配置编译后的文件存储位置和文件名。</p>
                <p class="calibre4 pv pid59" id="p59">在demo目录下新建一个空的main.js 作为入口的文件，然后在webpack.config.js中进行入口和输出的配置：</p>
                <pre class="calibre7 pv pid60" id="p60">var path = require('path');

var config = {
    entry: {
        main: './main'
    },
    output: {
        path: path.join(__dirname, './dist'),
        publicPath: '/dist/',
        filename: 'main.js'
    }
};

module.exports = config;</pre>
                <p class="calibre4 pv pid61" id="p61">
                    entry中的main就是我们配置的单入口，webpack会从main.js文件开始工作。output中path选项用来存放打包后文件的输出目录，是必填项。publicPath指定资源文件引用的目录，如果你的资源存放在CDN上，这里可以填CDN的网址。filename用于指定输出文件的名称。因此，这里配置的output意为打包后的文件会存储为demo/dist/main.js文件，只要在html中引入它就可以了。</p>
                <p class="calibre4 pv pid62" id="p62">在demo目录下，新建一个index.html作为我们SPA的入口：</p>
                <pre class="calibre7 pv pid63" id="p63">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;webpack App&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        Hello World.
    &lt;/div&gt;
    &lt;script type="text/javascript" src="/dist/main.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
                <p class="calibre4 pv pid64" id="p64">现在在终端执行下面的命令，就会自动在浏览器中打开页面了：</p>
                <pre class="calibre7 pv pid65" id="p65">npm run dev</pre>
                <p class="calibre4 pv pid66" id="p66">如果打开的页面跟图10-2一致，那么你已经完成整个工程中最重要的一步了。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid67" id="p67" style="margin: 0px;"><img alt="204"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/8f2a917aba43dcbf.jpg"
                                                                                                         href="./image/00035.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-2　在浏览器中打开webpack项目</p></div>
                <p class="calibre4 pv pid67" id="p67">打开demo/main.js文件，添加一行JavaScript 代码来修改页面的内容：</p>
                <pre class="calibre7 pv pid68"
                     id="p68">document.getElementById('app').innerHTML = 'Hello webpack.';</pre>
                <p class="calibre4 pv pid69" id="p69">保存文件，回到刚才打开的页面，发现页面内容已经变为了“Hello
                    webpack.”。注意，此时并没有刷新浏览器，就已经自动更新了，这就是webpack-dev-server的热更新功能，它通过建立一个WebSocket连接来实时响应代码的修改。</p>
                <p class="calibre4 pv pid70" id="p70">
                    在本章第1节中介绍过：学习webpack最难的是理解它“编译”的这个概念。我们来看一下webpack编译出的/dist/main.js究竟是什么。在Chrome浏览器开发者工具的network视图中查看main.js的内容，如图10-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid71" id="p71" style="margin: 0px;"><img alt="205"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/fe76e1bf64f20bc1.jpg"
                                                                                                         href="./image/00036.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-3　编译后的main.js文件</p></div>
                <p class="calibre4 pv pid71" id="p71">
                    是不是很震惊，我们只写了一行JS代码，却编译出了9000多行。不过不用担心，这里面很多都是webpack-dev-server的功能，只在开发时有效，在生产环境下编译就不会这么臃肿了。比如执行下面的命令进行打包：</p>
                <pre class="calibre7 pv pid72" id="p72">webpack --progress --hide-modules</pre>
                <p class="calibre4 pv pid73" id="p73">这时会生成一个demo/dist/main.js文件，它只有不到100行，而且是没有压缩的。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_89 pv pid74" id="p74" name="sigil_toc_id_89">
                    10.2.3　逐步完善配置文件</h4>
                <p class="calibre4 pv pid75" id="p75">
                    10.2.2小节通过配置入口（Entry）和出口（Output）已经可以启动webpack项目了，不过这并不是webpack的特点，如果它只有这些作用，根本就不用这么麻烦。本节将对文件webpack.config.js
                    进一步配置，来实现更强大的功能。</p>
                <p class="calibre4 pv pid76" id="p76">
                    在webpack的世界里，每个文件都是一个模块，比如.css、.js、.html、.jpg、.less等。对于不同的模块，需要用不同的加载器（Loaders）来处理，而加载器就是webpack最重要的功能。通过安装不同的加载器可以对各种后缀名的文件进行处理，比如现在要写一些CSS样式，就要用到style-loader和css-loader。下面就通过NPM来安装它们：</p>
                <pre class="calibre7 pv pid77" id="p77">npm install css-loader --save-dev
npm install style-loader --save-dev</pre>
                <p class="calibre4 pv pid78" id="p78">安装完成后，在webpack.config.js文件里配置Loader，增加对.css文件的处理：</p>
                <pre class="calibre7 pv pid79" id="p79">var config = {
    // ...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: [
                    'style-loader',
                    'css-loader'
                ]
            }
        ]
    }
};

module.exports = config;</pre>
                <p class="calibre4 pv pid80" id="p80">
                    在module对象的rules属性中可以指定一系列的loaders，每一个loader都必须包含test和use两个选项。这段配置的意思是说，当webpack编译过程中遇到require()或import语句导入一个后缀名为.css的文件时，先将它通过css-loader转换，再通过style-loader转换，然后继续打包。use选项的值可以是数组或字符串，如果是数组，它的编译顺序就是从后往前。</p>
                <p class="calibre4 pv pid81" id="p81">在demo目录下新建一个style.css的文件，并在main.js中导入：</p>
                <pre class="calibre7 pv pid82" id="p82">/* style.css */
#app{
    font-size: 24px;
    color: #f50;
}

// main.js
import './style.css';
document.getElementById('app').innerHTML = 'Hello webpack.’;</pre>
                <p class="calibre4 pv pid83" id="p83">重新执行npm run dev命令，可以看到页面中的文字已经变成红色，并且字号也大了，如图10-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid84" id="p84" style="margin: 0px;"><img alt="207"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/a0d3db3ee70a54c1.jpg"
                                                                                                         href="./image/00037.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-4　使用css后的效果</p></div>
                <p class="calibre4 pv pid84" id="p84">可以看到，CSS是通过JavaScript动态创建&lt;style&gt;标签来写入的，这意味着样式代码都已经编译在了main.js文件里，但在实际业务中，可能并不希望这样做，因为项目大了样式会很多，都放在JS里太占体积，还不能做缓存。这时就要用到webpack最后一个重要的概念——插件（Plugins）。</p>
                <p class="calibre4 pv pid85" id="p85">
                    webpack的插件功能很强大而且可以定制。这里我们使用一个extract-text-webpack-plugin的插件来把散落在各地的css提取出来，并生成一个main.css的文件，最终在index.html里通过&lt;link&gt;的形式加载它。</p>
                <p class="calibre4 pv pid86" id="p86">通过NPM安装extract-text-webpack-plugin插件：</p>
                <pre class="calibre7 pv pid87" id="p87">npm install extract-text-webpack-plugin --save-dev</pre>
                <p class="calibre4 pv pid88" id="p88">然后在配置文件中导入插件，并改写loader的配置：</p>
                <pre class="calibre7 pv pid89" id="p89">// 导入插件
var ExtractTextPlugin = require('extract-text-webpack-plugin');

var config = {
    // ...
    module: {
        rules: [
            {
                test: /\.css$/,
                use: ExtractTextPlugin.extract({
                    use: 'css-loader',
                    fallback: 'style-loader'
                })
            }
        ]
    },
    plugins: [
        // 重命名提取后的css文件
        new ExtractTextPlugin("main.css")
    ]
};

module.exports = config;

// index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;webpack App&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="/dist/main.css"&gt;
&lt;/head&gt;
……</pre>
                <p class="calibre4 pv pid90" id="p90">插件还可以进行丰富的配置，我们会在后面结合Vue使用时详细介绍。现在重新启动服务，就可以看到&lt;style&gt;
                    已经没有了，通过&lt;link&gt; 引入的main.css文件已经生效。</p>
                <p class="calibre4 pv pid91" id="p91">
                    webpack虽然概念比较新，看似复杂，但它只不过是一个js配置文件，只要搞清楚入口（Entry）、出口（Output）、加载器（Loaders）和插件（Plugins）这4个概念，使用起来就不那么困惑了。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_90 pv pid92" id="p92" name="sigil_toc_id_90">
                    10.3　单文件组件与vue-loader</h3>
                <p class="calibre4 pv pid93" id="p93">
                    回顾一下第7章关于组件的内容，我们是如何创建并使用一个组件的。如果你练习过几个示例，肯定会觉得在字符串模板template选项里拼写字符串DOM非常费劲，尤其是用“\”换行。Vue.js是一个渐进式的JavaScript框架，在使用webpack构建Vue项目时，可以使用一种新的构建模式：.vue单文件组件。</p>
                <p class="calibre4 pv pid94" id="p94">
                    顾名思义，.vue单文件组件就是一个后缀名为.vue的文件，在webpack中使用vue-loader就可以对.vue格式的文件进行处理。</p>
                <p class="calibre4 pv pid95" id="p95">一个.vue文件一般包含3部分，即&lt;template&gt;、&lt;script&gt;和&lt;style&gt;，如图10-5所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid96" id="p96" style="margin: 0px;"><img alt="208"
                                                                                                         class="kindle-cn-bodycontent-image-alone50-withnote"
                                                                                                         src="./index_files/0509188dab626b20.jpg"
                                                                                                         href="./image/00038.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-5　.vue单文件</p></div>
                <p class="calibre4 pv pid96" id="p96">在component.vue文件中，&lt;template&gt;&lt;/template&gt;之间的代码就是该组件的模板HTML，&lt;style&gt;&lt;/style&gt;之间的是CSS样式，示例中的&lt;style&gt;标签使用了scoped属性，表示当前的CSS只在这个组件有效，如果不加，那么div的样式会应用到整个项目。&lt;style&gt;还可以结合CSS预编译一起使用，比如使用Less处理可以写成&lt;style
                    lang="less"&gt; 。</p>
                <p class="calibre4 pv pid97" id="p97">使用.vue文件需要先安装vue-loader、vue-style-loader等加载器并做配置。因为要使用ES6语法，还需要安装
                    babel和babel-loader等加载器。使用npm逐个安装以下依赖：</p>
                <pre class="calibre7 pv pid98" id="p98">npm install --save vue
npm install --save-dev vue-loader
npm install --save-dev vue-style-loader
npm install --save-dev vue-template-compiler
npm install --save-dev vue-hot-reload-api
npm install --save-dev babel
npm install --save-dev babel-loader
npm install --save-dev babel-core
npm install --save-dev babel-plugin-transform-runtime
npm install --save-dev babel-preset-es2015
npm install --save-dev babel-runtime</pre>
                <p class="calibre4 pv pid99" id="p99">安装完成后，修改配置文件webpack.config.js来支持对.vue文件及ES6的解析：</p>
                <pre class="calibre7 pv pid100" id="p100">var path = require('path');
var ExtractTextPlugin = require('extract-text-webpack-plugin');

var config = {
    entry: {
        main: './main'
    },
    output: {
        path: path.join(__dirname, './dist'),
        publicPath: '/dist/',
        filename: 'main.js'
    },
    module: {
        rules: [
            {
                test: /\.vue$/,
                loader: 'vue-loader',
                options: {
                    loaders: {
                        css: ExtractTextPlugin.extract({
                          use: 'css-loader',
                          fallback: 'vue-style-loader'
                        })
                    }
                }
            },
            {
                test: /\.js$/,
                loader: 'babel-loader',
                exclude: /node_modules/
            },
            {
                test: /\.css$/,
                use: ExtractTextPlugin.extract({
                    use: 'css-loader',
                    fallback: 'style-loader'
                })
            }
        ]
    },
    plugins: [
        new ExtractTextPlugin("main.css")
    ]
};

module.exports = config;</pre>
                <p class="calibre4 pv pid101" id="p101">vue-loader在编译.vue文件时，会对&lt;template&gt;、&lt;script&gt;、&lt;style&gt;分别处理，所以在vue-loader选项里多了一项options来进一步对不同语言进行配置。比如在对css进行处理时，会先通过css-loader解析，然后把处理结果再交给vue-style-loader处理。当你的技术栈多样化时，可以给&lt;template&gt;、&lt;script&gt;和&lt;style&gt;都指定不同的语言，比如&lt;template
                    lang="jade"&gt;和&lt;style lang="less"&gt; ，然后配置loaders就可以了。</p>
                <p class="calibre4 pv pid102" id="p102">
                    在demo目录下新建一个名为.babelrc的文件，并写入babel的配置，webpack会依赖此配置文件来使用babel编译ES6代码：</p>
                <pre class="calibre7 pv pid103" id="p103">{
    "presets": ["es2015"],
    "plugins": ["transform-runtime"],
    "comments": false
}</pre>
                <p class="calibre4 pv pid104" id="p104">配置好这些后，就可以使用.vue文件了。记住，每个.vue文件就代表一个组件，组件之间可以相互依赖。</p>
                <p class="calibre4 pv pid105" id="p105">在demo目录下新建一个app.vue的文件并写入以下内容：</p>
                <pre class="calibre7 pv pid106" id="p106">&lt;template&gt;
    &lt;div&gt;Hello {{ name }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                name: 'Vue.js'
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    div{
        color: #f60;
        font-size: 24px;
    }
&lt;/style&gt;</pre>
                <p class="kindle-cn-para-left pv pid107" id="p107">提示</p>
                <p class="kindle-cn-para-no-indent pv pid108" id="p108" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <pre class="calibre7 pv pid108" id="p108">data () { }</pre>
                <p class="kindle-cn-para-no-indent pv pid109" id="p109" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">等同于：</span></p>
                <pre class="calibre7 pv pid109" id="p109">data: function () { }</pre>
                <p class="kindle-cn-para-no-indent pv pid110" id="p110" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">在&lt;template&gt;内写的HTML写法完全同html文件，不用加“\”换行，webpack最终会把它编译为Render函数的形式。写在&lt;style&gt;里的样式，我们已经用插件extract-text-webpack-plugin配置过了，最终会统一提取并打包在main.css里，因为加了scoped属性，这部分样式只会对当前组件app.vue有效。</span>
                </p>
                <p class="calibre4 pv pid110" id="p110">
                    .vue的组件是没有名称的，在父组件使用时可以对它自定义。写好了组件，就可以在入口main.js中使用它了。打开main.js文件，把内容替换为下面的代码：</p>
                <pre class="calibre7 pv pid111" id="p111">// 导入Vue框架
import Vue from 'vue';
// 导入app.vue组件
import App from './app.vue';

// 创建Vue 根实例
new Vue({
    el: '#app',
    render: h =&gt; h(App)
});</pre>
                <p class="kindle-cn-para-left pv pid112" id="p112">提示</p>
                <p class="kindle-cn-para-no-indent pv pid113" id="p113" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <pre class="calibre7 pv pid113" id="p113">=&gt;是箭头函数</pre>
                <p class="kindle-cn-para-no-indent pv pid114" id="p114" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">render: h =&gt; h(App)等同于：</span></p>
                <pre class="calibre7 pv pid114" id="p114">render: function (h) {
    return h(App)
}</pre>
                <p class="kindle-cn-para-no-indent pv pid115" id="p115" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">也等同于：</span></p>
                <pre class="calibre7 pv pid115" id="p115">render: h =&gt; {
    return h(App);
}</pre>
                <p class="calibre4 pv pid116" id="p116">
                    箭头函数里的this指向与普通函数是不一样的，箭头函数体内的this对象就是定义时所在的对象，而不是使用时所在的对象，比如：</p>
                <pre class="calibre7 pv pid117" id="p117">function Timer () {
    this.id = 1;

    var _this = this;
    setTimeout(function () {
        console.log(this.id);  // undefined
        console.log(_this.id);  // 1
    }, 1000);

    setTimeout(() =&gt; {
        console.log(this.id);  // 1
    }, 2000);
}

var timer = new Timer();</pre>
                <p class="calibre4 pv pid118" id="p118">执行命令npm run dev，第一个Vue工程就跑起来了。打开Chrome调试工具，在Elements面板可以看到，&lt;div
                    id="app"&gt;已经被组件替换成了：</p>
                <pre class="calibre7 pv pid119" id="p119">&lt;div data-v-8ecbb1fa&gt;Hello Vue.js&lt;/div&gt;</pre>
                <p class="calibre4 pv pid120" id="p120">对应的main.css为：</p>
                <pre class="calibre7 pv pid121" id="p121">div[data-v-8ecbb1fa]{
    color: #f60;
    font-size: 24px;
}</pre>
                <p class="calibre4 pv pid122" id="p122">之所以多了一串data-v-xxx的内容，是因为使用了&lt;style scoped&gt;功能，如果去掉
                    scoped，就只剩下&lt;div&gt;Hello Vue.js&lt;/div&gt;了。</p>
                <p class="calibre4 pv pid123" id="p123">接下来，在demo目录下再新建两个文件，title.vue和button.vue。</p>
                <p class="calibre4 pv pid124" id="p124" style="margin: 0px;"><span
                        class="kindle-cn-bold">title.vue：</span></p>
                <pre class="calibre7 pv pid124" id="p124">&lt;template&gt;
    &lt;h1&gt;
        &lt;a :href="'#' + title"&gt;{{ title }}&lt;/a&gt;
    &lt;/h1&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        props: {
            title: {
                type: String
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    h1 a{
        color: #3399ff;
        font-size: 24px;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid125" id="p125" style="margin: 0px;"><span
                        class="kindle-cn-bold">button.vue：</span></p>
                <pre class="calibre7 pv pid125" id="p125">&lt;template&gt;
    &lt;button @click="handleClick" :style="styles"&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/button&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        props: {
            color: {
                type: String,
                default: '#00cc66'
            }
        },
        computed: {
            styles () {
                return {
                    background: this.color
                }
            }
        },
        methods: {
            handleClick (e) {
                this.$emit('click', e);
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    button{
        border: 0;
        outline: none;
        color: #fff;
        padding: 4px 8px;
    }
    button:active{
        position: relative;
        top: 1px;
        left: 1px;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid126" id="p126">改写根实例app.vue组件，把title.vue和button.vue导入进来：</p>
                <pre class="calibre7 pv pid127" id="p127">&lt;template&gt;
    &lt;div&gt;
        &lt;v-title title="Vue组件化"&gt;&lt;/v-title&gt;
        &lt;v-button @click="handleClick"&gt;点击按钮&lt;/v-button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    // 导入组件
    import vTitle from './title.vue';
    import vButton from './button.vue';

    export default {
        components: {
            vTitle,
            vButton
        },
        methods: {
            handleClick (e) {
                console.log(e);
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid128" id="p128">提示</p>
                <p class="kindle-cn-para-no-indent pv pid129" id="p129" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <pre class="calibre7 pv pid129" id="p129">components: {
    vTitle,
    vButton
}</pre>
                <p class="kindle-cn-para-no-indent pv pid130" id="p130" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">等同于：</span></p>
                <pre class="calibre7 pv pid130" id="p130">components: {
    vTitle: vTitle,
    vButton: vButton
}</pre>
                <p class="kindle-cn-para-no-indent pv pid131" id="p131" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">对象字面量缩写。当对象的key和value 名称一致时，可以缩写成一个。</span></p>
                <p class="calibre4 pv pid131" id="p131">导入的组件都是局部注册的，而且可以自定义名称，其他用法和组件一致。</p>
                <p class="calibre4 pv pid132" id="p132">
                    打开浏览器，如果已经正确渲染出了这两个组件，那么恭喜你，已经进入Vue.js的高级领域了，可以更高效地开发Vue项目，后面的章节都会基于webpack和单文件组件展开。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_91 pv pid133" id="p133" name="sigil_toc_id_91">
                    10.4　用于生产环境</h3>
                <p class="calibre4 pv pid134" id="p134">我们先对webpack进一步配置，来支持更多常用的功能。</p>
                <p class="calibre4 pv pid135" id="p135">安装 url-loader和file-loader来支持图片、字体等文件：</p>
                <pre class="calibre7 pv pid136" id="p136">npm install --save-dev url-loader
npm install --save-dev file-loader

// webpack.config.js
var config = {
    // ...
    module: {
        rules: [
            // ...
            {
                test: /\.(gif|jpg|png|woff|svg|eot|ttf)\??.*$/,
                loader: 'url-loader?limit=1024'
            }
        ]
    }
};</pre>
                <p class="calibre4 pv pid137" id="p137">
                    当遇到.gif、.png、.ttf等格式文件时，url-loader会把它们一起编译到dist目录下，“?limit=1024”是指如果这个文件小于1kb，就以base64的形式加载，不会生成一个文件。</p>
                <p class="calibre4 pv pid138" id="p138">找一张图片，保存为demo/images/image.png，并在app.vue中加载它：</p>
                <pre class="calibre7 pv pid139" id="p139">&lt;template&gt;
    &lt;div&gt;
        &lt;v-title title="Vue组件化"&gt;&lt;/v-title&gt;
        &lt;v-button @click="handleClick"&gt;点击按钮&lt;/v-button&gt;
        &lt;p&gt;
            &lt;img src="./images/image.png" style="width: 200px;"&gt;
        &lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;</pre>
                <p class="calibre4 pv pid140" id="p140">效果如图10-6所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid141" id="p141" style="margin: 0px;"><img alt="216"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/27b52040c11c5ebc.jpg"
                                                                                                           href="./image/00039.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-6　在webpack项目中使用图片</p></div>
                <p class="calibre4 pv pid141" id="p141">介绍打包上线前，先来分析webpack打包后的产物有哪些。</p>
                <p class="calibre4 pv pid142" id="p142">
                    本书所介绍和使用的都是单页面富应用（SPA）技术，这意味着最终只有一个html的文件，其余都是静态资源。实际部署到生产环境时，一般会将html挂在后端程序下，由后端路由渲染这个页面，将所有的静态资源（css、js、image、iconfont等）单独部署到CDN，当然也可以和后端程序部署在一起，这样就实现了前后端完全分离。</p>
                <p class="calibre4 pv pid143" id="p143">
                    我们在webpack的ouput选项里已经指定了path和publicPath，打完包后，所有的资源都会保存在demo/dist目录下。</p>
                <p class="calibre4 pv pid144" id="p144">打包会用到下面两个依赖，使用NPM安装：</p>
                <pre class="calibre7 pv pid145" id="p145">npm install --save-dev webpack-merge
npm install --save-dev html-webpack-plugin</pre>
                <p class="calibre4 pv pid146" id="p146">
                    为了方便开发和生产环境的切换，我们在demo目录下再新建一个用于生产环境的配置文件webpack.prod.config.js。</p>
                <p class="calibre4 pv pid147" id="p147">编译打包，直接执行webpack命令就可以。在package.json中，再加入一个build的快捷脚本用来打包：</p>
                <pre class="calibre7 pv pid148" id="p148">"scripts": {
  "dev": "webpack-dev-server --open --config webpack.config.js",
  "build": "webpack --progress --hide-modules --config webpack.prod.config.js"
}</pre>
                <p class="calibre4 pv pid149" id="p149">先来看一下webpack.prod.config.js的代码：</p>
                <pre class="calibre7 pv pid150" id="p150">var webpack = require('webpack');
var HtmlwebpackPlugin = require('html-webpack-plugin');
var ExtractTextPlugin = require('extract-text-webpack-plugin');
var merge = require('webpack-merge');
var webpackBaseConfig = require('./webpack.config.js');

// 清空基本配置的插件列表
webpackBaseConfig.plugins = [];

module.exports = merge(webpackBaseConfig, {
    output: {
        publicPath: '/dist/',
        //将入口文件重命名为带有20 位 hash 值的唯一文件
        filename: '[name].[hash].js'
    },
    plugins: [
        new ExtractTextPlugin({
            // 提取 css，并重命名为带有20 位 hash 值的唯一文件
            filename: '[name].[hash].css',
            allChunks: true
        }),
        // 定义当前 node 环境为生产环境
        new webpack.DefinePlugin({
            'process.env': {
                NODE_ENV: '"production"'
            }
        }),
        // 压缩 js
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false
            }
        }),
        // 提取模板，并保存入口 html文件
        new HtmlWebpackPlugin({
            filename: '../index_prod.html',
            template: './index.ejs',
            inject: false
        })
    ]
});</pre>
                <p class="calibre4 pv pid151" id="p151">
                    上面安装的webpack-merge模块就是用于合并两个webpack的配置文件，所以prod的配置是在webpack.config.js基础上扩展的。静态资源在大部分场景下都有缓存（304），更新上线后一般都希望用户能及时地看到内容，所以给打包后的css和js文件的名称都加了20位的hash值，这样文件名就唯一了（比如main.b3dd20e2dae9d76af86b.js），只要不对html文件设置缓存，上线后立即就可以加载最新的静态资源。</p>
                <p class="calibre4 pv pid152" id="p152">
                    html-webpack-plugin是用来生成html文件的，它通过template选项来读取指定的模板index.ejs，然后输出到filename指定的目录，也就是demo/index_prod.html。模板index.ejs动态设置了静态资源的路径和文件名，代码如下：</p>
                <pre class="calibre7 pv pid153" id="p153">&lt;!DOCTYPE html&gt;
&lt;html lang="zh-CN"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;webpack App&lt;/title&gt;
    &lt;link rel="stylesheet" href="&lt;%= htmlwebpackPlugin.files.css[0] %&gt;"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="&lt;%= htmlwebpackPlugin.files.js[0] %&gt;"&gt; &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt; </pre>
                <p class="kindle-cn-para-left pv pid154" id="p154">提示</p>
                <p class="kindle-cn-para-no-indent pv pid155" id="p155" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">ejs是一个JavaScript模板库，用来从JSON数据中生成HTML字符串，常用于Node.js。</span>
                </p>
                <p class="calibre4 pv pid155" id="p155">最后在终端运行npm run
                    build，等待一会就会完成打包，成功后在demo下会生成一个dist的目录，里面就是打包完的所有静态资源。打包过程如图10-7所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid156" id="p156" style="margin: 0px;"><img alt="219"
                                                                                                           class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                           src="./index_files/7fdece76b161ba1b.jpg"
                                                                                                           href="./image/00040.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图10-7　打包过程</p></div>
                <p class="calibre4 pv pid156" id="p156">
                    以上就是webpack的核心功能和主要配置。除了本章介绍的这些内容外，webpack还有很多高级的配置和丰富的插件及加载器，读者可查阅webpack文档进一步学习：https://webpack.js.org/。</p>
                <p class="calibre4 pv pid157" id="p157">本章所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid158" id="p158">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid159" id="p159">vue-book下的demo目录就是本章的代码，在该目录下执行npm install命令会自动安装所有的依赖，然后执行npm
                    run dev启动服务。</p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="109" data-chapter-url="24047099" alt="64157363">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第11章　插件</h2>
                <p class="calibre4 pv pid3" id="p3">
                    Vue.js提供了插件机制，可以在全局添加一些功能。它们可以简单到几个方法、属性，也可以很复杂，比如一整套组件库。本章将介绍几个官方的核心插件，然后通过实战来开发一个插件。</p>
                <p class="calibre4 pv pid4" id="p4">注册插件需要一个公开的方法install，它的第一个参数是Vue构造器，第二个参数是一个可选的选项对象。示例代码如下：</p>
                <pre class="calibre7 pv pid5" id="p5">MyPlugin.install = function (Vue, options) {
    // 全局注册组件（指令等功能资源类似）
    Vue.component('component-name', {
        //组件内容
    })
    //添加实例方法
    Vue.prototype.$Notice = function () {
        // 逻辑...
    }
    //添加全局方法或属性
    Vue.globalMethod = function () {
        // 逻辑...
    }
    //添加全局混合
    Vue.mixin({
        mounted: function () {
            // 逻辑...
        }
    })
}</pre>
                <p class="calibre4 pv pid6" id="p6">通过Vue.use()来使用插件：</p>
                <pre class="calibre7 pv pid7" id="p7">Vue.use(MyPlugin)
//或
Vue.use(MyPlugin, {
    // 参数
})</pre>
                <p class="calibre4 pv pid8" id="p8">
                    绝大多数情况下，开发插件主要是通过NPM发布后给别人使用的，在自己的项目中可以直接在入口调用以上的方法，无须多一步注册和使用的步骤。</p>
                <p class="kindle-cn-para-left pv pid9" id="p9">提示</p>
                <p class="kindle-cn-para-no-indent pv pid10" id="p10" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本章示例是基于上一章的webpack配置开始的，会在此基础上进一步开发，所以要确保先正确跑通了上一章的示例，也可以直接从https://github.com/icarusion/vue-book下载最终的示例。</span>
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_92 pv pid10" id="p10" name="sigil_toc_id_92">
                    11.1　前端路由与vue-router</h3><h4 class="kindle-cn-heading3 sigil_toc_id_93 pv pid11" id="p11"
                                                 name="sigil_toc_id_93">11.1.1　什么是前端路由</h4>
                <p class="calibre4 pv pid12" id="p12">
                    上一章介绍webpack时提到它的主要使用场景是单页面富应用（SPA），而SPA的核心就是前端路由。那什么是路由呢？通俗地讲，就是网址，比如https://www.iviewui.com/docs/guide/introduce；再专业一点，就是每次GET或者POST等请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的Controller，进行各种操作，最终将html或数据返回给前端，这就完成了一次IO。</p>
                <p class="calibre4 pv pid13" id="p13">
                    当然，目前绝大多数的网站都是这种后端路由，也就是多页面的，这样的好处有很多，比如页面可以在服务端渲染好直接返回给浏览器，不用等待前端加载任何js和css就可以直接显示网页内容，再比如对SEO的友好等。后端路由的缺点也是很明显的，就是模板是由后端来维护或改写的。前端开发者需要安装整套的后端服务，必要时还得学习像PHP或Java这些非前端语言来改写html结构，所以html和数据、逻辑混为一谈，维护起来既臃肿又麻烦。</p>
                <p class="calibre4 pv pid14" id="p14">
                    然后就有了前后端分离的开发模式，后端只提供API来返回数据，前端通过Ajax获取数据后，再用一定的方式渲染到页面里，这么做的优点就是前后端做的事情分得很清楚，后端专注在数据上，前端专注在交互和可视化上，如果今后再开发移动App，那就正好能使用一套API了。当然，缺点也很明显，就是首屏渲染需要时间来加载css和js。这种开发模式被很多公司认同，也出现了很多前端技术栈，比如以jQuery
                    + artTemplate + Seajs(requirejs) +
                    gulp为主的开发模式可谓是万金油了。在Node.js出现后，这种现象有了改善，就是所谓的大前端，得益于Node.js和JavaScript的语言特性，html模板可以完全由前端来控制，同步或异步渲染完全由前端自由决定，并且由前端维护一套模板，这就是为什么在服务端使用artTemplate、React以及Vue
                    2的原因。说了这么多，到底怎样算是SPA呢？其实就是在前后端分离的基础上，加一层前端路由。</p>
                <p class="calibre4 pv pid15" id="p15">
                    前端路由，即由前端来维护一个路由规则。实现有两种，一种是利用url的hash，就是常说的锚点（#），JavaScript通过hashChange事件来监听url的改变，IE7及以下需要用轮询；另一种就是HTML5的History模式，它使
                    url看起来像普通网站那样，以“/”分割，没有#，但页面并没有跳转，不过使用这种模式需要服务端支持，服务端在接收到所有的请求后，都指向同一个html文件，不然会出现404。因此，SPA只有一个html，整个网站所有的内容都在这一个html里，通过JavaScript来处理。</p>
                <p class="calibre4 pv pid16" id="p16">
                    前端路由的优点有很多，比如页面持久性，像大部分音乐网站，你都可以在播放歌曲的同时跳转到别的页面，而音乐没有中断。再比如前后端彻底分离。前端路由的框架通用的有Director（https://github.com/flatiron/director），不过更多还是结合具体框架来用，比如Angular的ngRouter，React的ReactRouter，以及本节要介绍的Vue的vue-router。</p>
                <p class="calibre4 pv pid17" id="p17">如果要独立开发一个前端路由，需要考虑到页面的可插拔、页面的生命周期、内存管理等问题。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_94 pv pid18" id="p18" name="sigil_toc_id_94">
                    11.1.2　vue-router基本用法</h4>
                <p class="calibre4 pv pid19" id="p19">
                    回顾第7章7.5.3小节，当时介绍了通过is特性来实现动态组件的方法。vue-router的实现原理与之类似，路由不同的页面事实上就是动态加载不同的组件。</p>
                <p class="calibre4 pv pid20" id="p20">新建一个目录router，复制上一章的代码并安装完成后，再通过NPM来安装 vue-router：</p>
                <pre class="calibre7 pv pid21" id="p21">npm install --save vue-router</pre>
                <p class="calibre4 pv pid22" id="p22">在main.js里使用Vue.use() 加载插件：</p>
                <pre class="calibre7 pv pid23" id="p23">import Vue from 'vue';
import VueRouter from 'vue-router';
import App from './app.vue';

Vue.use(VueRouter);</pre>
                <p class="calibre4 pv pid24" id="p24">
                    每个页面对应一个组件，也就是对应一个.vue文件。在router目录下创建views目录，用于存放所有的页面，然后在views里创建index.vue和about.vue两个文件：</p>
                <pre class="calibre7 pv pid25" id="p25">// index.vue
&lt;template&gt;
    &lt;div&gt;首页&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;

// about.vue
&lt;template&gt;
    &lt;div&gt;介绍页&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid26" id="p26">再回到main.js里，完成路由的剩余配置。创建一个数组来制定路由匹配列表，每一个路由映射一个组件：</p>
                <pre class="calibre7 pv pid27" id="p27">const Routers = [
    {
        path: '/index',
        component: (resolve) =&gt; require(['./views/index.vue'], resolve)
    },
    {
        path: '/about',
        component: (resolve) =&gt; require(['./views/about.vue'], resolve)
    }
];</pre>
                <p class="kindle-cn-para-left pv pid28" id="p28">提示</p>
                <p class="kindle-cn-para-no-indent pv pid29" id="p29" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid29" id="p29" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">在ES 6中，使用let和const命令来声明变量，代替了var。let和const的作用域是“块”，比如：</span>
                </p>
                <pre class="calibre7 pv pid29" id="p29">{
    let a = 1;
    var b = 2;
}

console.log(b);  // 2
console.log(a);  // 报错：a is not defined</pre>
                <p class="kindle-cn-para-no-indent pv pid30" id="p30" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">const与let的主要区别是，const用于声明常量，也就是声明后不能再修改。</span></p>
                <p class="kindle-cn-para-no-indent pv pid30" id="p30" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果一时还不了解它们的其他区别，可以先把let和const当作var来理解。</span></p>
                <p class="calibre4 pv pid30" id="p30">
                    Routers里每一项的path属性就是指定当前匹配的路径，component是映射的组件。上例的写法，webpack会把每一个路由都打包为一个js文件，在请求到该页面时，才去加载这个页面的js，也就是异步实现的懒加载（按需加载），这与第7章7.5.4小节异步组件的用法类似。这样做的好处是不需要在打开首页的时候就把所有的页面内容全部加载进来，只在访问时才加载。如果非要一次性加载，可以这样写：</p>
                <pre class="calibre7 pv pid31" id="p31">{
    path: '/index',
    component: require('./views/index.vue')
}</pre>
                <p class="kindle-cn-para-left pv pid32" id="p32">提示</p>
                <p class="kindle-cn-para-no-indent pv pid33" id="p33" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">使用了异步路由后，编译出的每个页面的js都叫作chunk（块），它们命名默认是0.main.js、1.main.js ……可以在webpack配置的出口output里通过设置chunkFilename字段修改chunk命名，例如：</span>
                </p>
                <pre class="calibre7 pv pid33" id="p33">output: {
    publicPath: '/dist/',
    filename: '[name].js',
    chunkFilename: '[name].chunk.js'
}</pre>
                <p class="kindle-cn-para-no-indent pv pid34" id="p34" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">有了chunk后，在每个页面（.vue文件）里写的样式也需要配置后才会打包进main.css，否则仍然会通过JavaScript 动态创建&lt;style&gt; 标签的形式写入。配置插件：</span>
                </p>
                <pre class="calibre7 pv pid34" id="p34">// webpack.config.js
plugins: [
    new ExtractTextPlugin({
        filename: '[name].css',
        allChunks: true
    })
]</pre>
                <p class="calibre4 pv pid35" id="p35">然后继续在main.js里完成配置和路由实例：</p>
                <pre class="calibre7 pv pid36" id="p36">const RouterConfig = {
    // 使用HTML5的History 路由模式
    mode: 'history',
    routes: Routers
};
const router = new VueRouter(RouterConfig);

new Vue({
    el: '#app',
    router: router,
    render: h =&gt; {
        return h(App)
    }
});</pre>
                <p class="calibre4 pv pid37" id="p37">在RouterConfig里，设置mode为history会开启HTML
                    5的History路由模式，通过“/”设置路径。如果不配置mode，就会使用“#”来设置路径。开启History路由，在生产环境时服务端必须进行配置，将所有路由都指向同一个html，或设置404页面为该html，否则刷新时页面会出现404。</p>
                <p class="calibre4 pv pid38" id="p38">webpack-dev-server也要配置下来支持History路由，在package.json中修改dev命令：</p>
                <pre class="calibre7 pv pid39" id="p39">"scripts": {
    "dev": "webpack-dev-server --open --history-api-fallback --config webpack.config.js"
}</pre>
                <p class="calibre4 pv pid40" id="p40">增加了--history-api-fallback，所有的路由都会指向 index.html。</p>
                <p class="calibre4 pv pid41" id="p41">配置好了这些，最后在根实例app.vue里添加一个路由视图&lt;router-view&gt;来挂载所有的路由组件：</p>
                <pre class="calibre7 pv pid42" id="p42">&lt;template&gt;
    &lt;div&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {

    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid43" id="p43">运行网页时，&lt;router-view&gt;会根据当前路由动态渲染不同的页面组件。网页中一些公共部分，比如顶部的导航栏、侧边导航栏、底部的版权信息，这些也可以直接写在app.vue里，与&lt;router-view&gt;
                    同级。路由切换时，切换的是&lt;router-view&gt;挂载的组件，其他的内容并不会变化。</p>
                <p class="calibre4 pv pid44" id="p44">运行npm run
                    dev启动服务，然后访问127.0.0.1:8080/index和127.0.0.1:8080/about就可以访问这两个页面了。</p>
                <p class="calibre4 pv pid45" id="p45">在路由列表里，可以在最后新加一项，当访问的路径不存在时，重定向到首页：</p>
                <pre class="calibre7 pv pid46" id="p46">const Routers = [
    // ...
    {
        path: '*',
        redirect: '/index'
    }
];</pre>
                <p class="calibre4 pv pid47" id="p47">这样直接访问127.0.0.1:8080，就自动跳转到了127.0.0.1:8080/index。</p>
                <p class="calibre4 pv pid48" id="p48">
                    路由列表的path也可以带参数，比如“个人主页”的场景，路由的一部分是固定的，一部分是动态的：/user/123456，其中用户id“123456”就是动态的，但它们路由到同一个页面，在这个页面里，期望获取这个id，然后请求相关数据。在路由里可以这样配置参数：</p>
                <pre class="calibre7 pv pid49" id="p49">// main.js
const Routers = [
    // ...
    {
        path: '/user/:id',
        component: (resolve) =&gt; require(['./views/user.vue'], resolve)
    },
    {
        path: '*',
        redirect: '/index'
    }
];
//在router/views目录下，新建user.vue文件
&lt;template&gt;
    &lt;div&gt;{{ $route.params.id }}&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        mounted () {
            console.log(this.$route.params.id);
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid50" id="p50">这里的this.$route可以访问到当前路由的很多信息，可以打印出来看看都有什么，在开发中会经常用到里面的数据。</p>
                <p class="calibre4 pv pid51" id="p51">
                    因为配置的路由是“/user/:id”，所以直接访问127.0.0.1:8080/user会重定向到/index，需要带一个id才能到user.vue，比如127.0.0.1:8080/user/123456。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_95 pv pid52" id="p52" name="sigil_toc_id_95">11.1.3　跳转</h4>
                <p class="calibre4 pv pid53" id="p53">vue-router有两种跳转页面的方法，第一种是使用内置的&lt;router-link&gt;组件，它会被渲染为一个&lt;a&gt;标签：</p>
                <pre class="calibre7 pv pid54" id="p54">// index.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;首页&lt;/h1&gt;
        &lt;router-link to="/about"&gt;跳转到about&lt;/router-link&gt;
    &lt;/div&gt;
&lt;/template&gt;</pre>
                <p class="calibre4 pv pid55" id="p55">它的用法与一般的组件一样，to是一个prop，指定需要跳转的路径，当然也可以用v-bind 动态设置。使用&lt;router-link&gt;
                    ，在HTML5的History模式下会拦截点击，避免浏览器重新加载页面。</p>
                <p class="calibre4 pv pid56" id="p56">&lt;router-link&gt; 还有其他的一些 prop，常用的有：</p>
                <ul class="kindle-cn-ul-disc pv pid57" id="p57" style="margin: 0px;">
                    <li class="calibre6">tag<br class="calibre5"><span class="kindle-cn-specialtext-kaiti">tag可以指定渲染成什么标签，比如&lt;router-link to="/about" tag="li"&gt; 渲染的结果就是&lt;li&gt; 而不是&lt;a&gt;。</span>
                    </li>
                    <li class="calibre6">replace<br class="calibre5"><span class="kindle-cn-specialtext-kaiti">使用replace不会留下History记录，所以导航后不能用后退键返回上一个页面，如&lt;router-link to="/about" replace&gt;。</span>
                    </li>
                    <li class="calibre6">active-class<br class="calibre5"><span class="kindle-cn-specialtext-kaiti">当&lt;router-link&gt;对应的路由匹配成功时，会自动给当前元素设置一个名为router-link-active的class，设置prop：active-class可以修改默认的名称。在做类似导航栏时，可以使用该功能高亮显示当前页面对应的导航菜单项，但是一般不会修改active-class，直接使用默认值router-link-active就可以。</span>
                    </li>
                </ul>
                <p class="calibre4 pv pid57" id="p57">
                    有时候，跳转页面可能需要在JavaScript里进行，类似于window.location.href。这时可以用第二种跳转方法，使用router实例的方法。比如在about.vue里，通过点击事件跳转：</p>
                <pre class="calibre7 pv pid58" id="p58">// about.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;介绍页&lt;/h1&gt;
        &lt;button @click="handleRouter"&gt;跳转到user&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            handleRouter () {
                this.$router.push('/user/123');
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid59" id="p59">$router还有其他一些方法：</p>
                <ul class="kindle-cn-ul-disc pv pid60" id="p60" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">replace<br class="calibre5">类似于&lt;router-link&gt;的replace 功能，它不会向 history添加新记录，而是替换掉当前的history记录，如this.$router.replace('/user/123');。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">go<br class="calibre5">类似于window.history.go()，在history 记录中向前或者后退多少步，参数是整数，例如：</span>
                    </li>
                </ul>
                <pre class="calibre7 pv pid60" id="p60">// 后退 1 页
this.$router.go(-1);
// 前进 2 页
this.$router.go(2);</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_96 pv pid61" id="p61" name="sigil_toc_id_96">11.1.4　高级用法</h4>
                <p class="calibre4 pv pid62" id="p62">本节将从实际业务需求出发，逐步探索 vue-router的高级用法。</p>
                <p class="calibre4 pv pid63" id="p63">先抛出一个问题：在SPA项目中，如何修改网页的标题？</p>
                <p class="calibre4 pv pid64" id="p64">网页标题是通过&lt;title&gt;&lt;/title&gt;来显示的，但是SPA只有一个固定的html，切换到不同页面时，标题并不会变化，但是可以通过JavaScript修改&lt;title&gt;的内容：</p>
                <pre class="calibre7 pv pid65" id="p65">window.document.title = '要修改的网页标题';</pre>
                <p class="calibre4 pv pid66" id="p66">
                    那么问题就来了，在Vue工程里，在哪里、在什么时候修改标题呢？比较容易想到的一个办法是，在每个页面的.vue文件里，通过mounted钩子修改。这种办法没有问题，但是页面多了维护起来会很麻烦，而且这些逻辑都是重复的。</p>
                <p class="calibre4 pv pid67" id="p67">
                    比较理想的一个思路就是，在页面发生路由改变时，统一设置。vue-router提供了导航钩子beforeEach和afterEach，它们会在路由即将改变前和改变后触发，所以设置标题可以在beforeEach钩子完成。</p>
                <pre class="calibre7 pv pid68" id="p68">// main.js
const Routers = [
    {
        path: '/index',
        meta: {
            title: '首页'
        },
        component: (resolve) =&gt; require(['./views/index.vue'], resolve)
    },
    {
        path: '/about',
        meta: {
            title: '关于'
        },
        component: (resolve) =&gt; require(['./views/about.vue'], resolve)
    },
    {
        path: '/user/:id',
        meta: {
            title: '个人主页'
        },
        component: (resolve) =&gt; require(['./views/user.vue'], resolve)
    },
    {
        path: '*',
        redirect: '/index'
    }
];

const router = new VueRouter(RouterConfig);
router.beforeEach((to, from, next) =&gt; {
    window.document.title = to.meta.title;
    next();
});</pre>
                <p class="calibre4 pv pid69" id="p69">导航钩子有3个参数：</p>
                <ul class="kindle-cn-ul-disc pv pid70" id="p70" style="margin: 0px;">
                    <li class="calibre6">to　<span class="kindle-cn-specialtext-kaiti">即将要进入的目标的路由对象。</span></li>
                    <li class="calibre6">from　<span class="kindle-cn-specialtext-kaiti">当前导航即将要离开的路由对象。</span></li>
                    <li class="calibre6">next　<span class="kindle-cn-specialtext-kaiti">调用该方法后，才能进入下一个钩子。</span></li>
                </ul>
                <p class="calibre4 pv pid70" id="p70">
                    路由列表的meta字段可以自定义一些信息，比如我们将每个页面的title写入了meta来统一维护，beforeEach钩子可以从路由对象to里获取meta信息，从而改变标题。</p>
                <p class="calibre4 pv pid71" id="p71">
                    有了这两个钩子，还能做很多事情来提升用户体验。比如一个页面较长，滚动到某个位置，再跳转到另一个页面，滚动条默认是在上一个页面停留的位置，而好的体验肯定是能返回顶端。通过钩子afterEach就可以实现：</p>
                <pre class="calibre7 pv pid72" id="p72">// main.js
// …
router.afterEach((to, from, next) =&gt; {
    window.scrollTo(0, 0);
});</pre>
                <p class="calibre4 pv pid73" id="p73">类似的需求还有，从一个页面过渡到另一个页面时，可以出现一个全局的Loading动画，等到新页面加载完后再结束动画。</p>
                <p class="calibre4 pv pid74" id="p74">next()方法还可以设置参数，比如下面的场景。</p>
                <p class="calibre4 pv pid75" id="p75">
                    某些页面需要校验是否登录，如果登录了就可以访问，否则跳转到登录页。这里我们通过localStorage来简易判断是否登录，示例代码如下：</p>
                <pre class="calibre7 pv pid76" id="p76">router.beforeEach((to, from, next) =&gt; {
    if (window.localStorage.getItem('token')) {
        next();
    } else {
        next('/login');
    }
});</pre>
                <p class="calibre4 pv pid77" id="p77">next()的参数设置为false时，可以取消导航，设置为具体的路径可以导航到指定的页面。</p>
                <p class="calibre4 pv pid78" id="p78">正确地使用好导航钩子可以方便实现一些全局的功能，而且便于维护。更多的可能需要在业务中不断探索。</p>
                <p class="calibre4 pv pid79" id="p79">本节所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid80" id="p80">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid81" id="p81">vue-book下的router目录就是本节的代码，在该目录下执行npm install命令会自动安装所有的依赖，然后执行npm
                    run dev启动服务。</p>
                <p class="calibre4 pv pid82" id="p82" style="margin: 0px;"><span class="kindle-cn-bold">拓展阅读建议：</span>vue-router还有一些不常用或可不用的功能，比如嵌套路由、路由的命名、视图的命名等，读者可以查阅文档进一步学习，网址为https://router.vuejs.org/。
                </p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_97 pv pid82" id="p82" name="sigil_toc_id_97">
                    11.2　状态管理与Vuex</h3><h4 class="kindle-cn-heading3 sigil_toc_id_98 pv pid83" id="p83"
                                           name="sigil_toc_id_98">11.2.1　状态管理与使用场景</h4>
                <p class="calibre4 pv pid84" id="p84">
                    回顾第7章的7.3.3小节，我们在介绍非父子组件（也就是跨级组件和兄弟组件）通信时，使用了bus（中央事件总线）的一个方法，用来触发和接收事件，进一步起到通信的作用。Vuex所解决的问题与bus类似，它作为Vue的一个插件来使用，可以更好地管理和维护整个项目的组件状态。</p>
                <p class="calibre4 pv pid85" id="p85">
                    一个组件可以分为数据（model）和视图（view），数据更新时，视图也会自动更新。在视图中又可以绑定一些事件，它们触发methods里指定的方法，从而可以改变数据、更新视图，这是一个组件基本的运行模式。比如下面的示例：</p>
                <pre class="calibre7 pv pid86" id="p86">// message.vue
&lt;template&gt;
    &lt;div&gt;
        {{ message }}
        &lt;button @click="handleClick"&gt;Change word&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                message: 'Hello World.'
            };
        },
        methods: {
            handleClick () {
                this.message = 'Hello Vue.';
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid87" id="p87">
                    这里的数据message和方法handleClick只有在message.vue组件里可以访问和使用，其他的组件是无法读取和修改message的。但是在实际业务中，经常有跨组件共享数据的需求，因此Vuex的设计就是用来统一管理组件状态的，它定义了一系列规范来使用和操作数据，使组件应用更加高效。</p>
                <p class="calibre4 pv pid88" id="p88">
                    使用Vuex会有一定的门槛和复杂性，它的主要使用场景是大型单页应用，更适合多人协同开发。如果你的项目不是很复杂，或者希望短期内见效，你需要认真考虑是否真的有必要使用Vuex，也许像7.3.3小节介绍的bus方法就能很简单地解决你的需求。当然，并不是所有大型多人协同开发的SPA项目都必须使用Vuex，事实上，我们在一些生产环境中只是使用bus
                    也能实现得很好，用与否主要取决于你的团队和技术储备。</p>
                <p class="calibre4 pv pid89" id="p89">
                    每一个框架的诞生都是用来解决具体问题的。虽然bus已经可以很好地解决跨组件通信，但它在数据管理、维护、架构设计上还只是一个简单的组件，而Vuex却能更优雅和高效地完成状态管理。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_99 pv pid90" id="p90" name="sigil_toc_id_99">
                    11.2.2　Vuex基本用法</h4>
                <p class="calibre4 pv pid91" id="p91">
                    本节是在上一节的vue-router基础之上进行开发的，在本地创建目录vuex，然后复制上一节的所有代码，或直接从https://github.com/icarusion/vue-book下载后，使用router目录下的代码。</p>
                <p class="calibre4 pv pid92" id="p92">首先通过NPM安装Vuex：</p>
                <pre class="calibre7 pv pid93" id="p93">npm install --save vuex</pre>
                <p class="calibre4 pv pid94" id="p94">它的用法与vue-router类似，在main.js里，通过Vue.use()使用Vuex：</p>
                <pre class="calibre7 pv pid95" id="p95">import Vue from 'vue';
import VueRouter from 'vue-router';
import Vuex from 'vuex';
import App from './app.vue';

Vue.use(VueRouter);
Vue.use(Vuex);

// 路由配置
// 省略...

const store = new Vuex.Store({
    // vuex的配置
});

new Vue({
    el: '#app',
    router: router,
    // 使用vuex
    store: store,
    render: h =&gt; {
        return h(App)
    }
});</pre>
                <p class="calibre4 pv pid96" id="p96">
                    仓库store包含了应用的数据（状态）和操作过程。Vuex里的数据都是响应式的，任何组件使用同一store的数据时，只要store的数据变化，对应的组件也会立即更新。</p>
                <p class="calibre4 pv pid97" id="p97">数据保存在Vuex选项的state字段内，比如要实现一个计数器，定义一个数据count，初始值为0：</p>
                <pre class="calibre7 pv pid98" id="p98">const store = new Vuex.Store({
    state: {
        count: 0
    }
});</pre>
                <p class="calibre4 pv pid99" id="p99">在任何组件内，可以直接通过$store.state.count读取：</p>
                <pre class="calibre7 pv pid100" id="p100">// index.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;首页&lt;/h1&gt;
        {{ $store.state.count }}
    &lt;/div&gt;
&lt;/template&gt;</pre>
                <p class="calibre4 pv pid101" id="p101">直接写在template里显得有点乱，可以用一个计算属性来显示：</p>
                <pre class="calibre7 pv pid102" id="p102">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;首页&lt;/h1&gt;
        {{ count }}
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            count () {
                return this.$store.state.count;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid103" id="p103">现在访问首页，计数0已经可以显示出来了。</p>
                <p class="calibre4 pv pid104" id="p104">在组件内，来自store的数据只能读取，不能手动改变，改变store中数据的唯一途径就是显式地提交mutations。</p>
                <p class="calibre4 pv pid105" id="p105">
                    mutations是Vuex的第二个选项，用来直接修改state里的数据。我们给计数器增加2个mutations，用来加1和减1：</p>
                <pre class="calibre7 pv pid106" id="p106">// main.js
const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment (state) {
            state.count ++;
        },
        decrease (state) {
            state.count --;
        }
    }
});</pre>
                <p class="calibre4 pv pid107" id="p107">
                    在组件内，通过this.$store.commit方法来执行mutations。在index.vue中添加两个按钮用于加和减：</p>
                <pre class="calibre7 pv pid108" id="p108">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;首页&lt;/h1&gt;
        {{ count }}
        &lt;button @click="handleIncrement"&gt;+1&lt;/button&gt;
        &lt;button @click="handleDecrease"&gt;-1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            count () {
                return this.$store.state.count;
            }
        },
        methods: {
            handleIncrement () {
                this.$store.commit('increment');
            },
            handleDecrease () {
                this.$store.commit('decrease');
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid109" id="p109">这看起来很像JavaScript的观察者模式，组件只负责提交一个事件名，Vuex对应的mutations来完成业务逻辑。</p>
                <p class="calibre4 pv pid110" id="p110">
                    mutations还可以接受第二个参数，可以是数字、字符串或对象等类型。比如每次增加的不是1，而是指定的数量，可以这样改写：</p>
                <pre class="calibre7 pv pid111" id="p111">// main.js，部分代码省略
mutations: {
    increment (state, n = 1) {
        state.count += n;
    }
}</pre>
                <p class="kindle-cn-para-left pv pid112" id="p112">提示</p>
                <p class="kindle-cn-para-no-indent pv pid113" id="p113" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid113" id="p113" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">函数的参数可以设定默认值，当没有传入该参数时，使用设置的值。比如上例的increment (state, n = 1)等同于：</span>
                </p>
                <pre class="calibre7 pv pid113" id="p113">increment (state, n) {
    n = n || 1;
}

// index.vue，部分代码省略
&lt;template&gt;
    &lt;div&gt;
        &lt;button @click="handleIncrementMore"&gt;+5&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            handleIncrementMore () {
                this.$store.commit('increment', 5);
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-no-indent pv pid114" id="p114" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">当一个参数不够用时，可以传入一个对象，无限扩展。</span></p>
                <p class="calibre4 pv pid114" id="p114">提交mutation的另一种方式是直接使用包含type属性的对象，比如：</p>
                <pre class="calibre7 pv pid115" id="p115">// main.js
mutations: {
    increment (state, params) {
        state.count += params.count;
    }
}

// index.vue
this.$store.commit({
    type: 'increment',
    count: 10
});</pre>
                <p class="kindle-cn-para-left pv pid116" id="p116">提示</p>
                <p class="kindle-cn-para-no-indent pv pid117" id="p117" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">注意，mutation里尽量不要异步操作数据。如果异步操作数据了，组件在commit后，数据不能立即改变，而且不知道什么时候会改变。在下一节的actions里会介绍如何处理异步。</span>
                </p><h4 class="kindle-cn-heading3 sigil_toc_id_100 pv pid117" id="p117" name="sigil_toc_id_100">
                    11.2.3　高级用法</h4>
                <p class="calibre4 pv pid118" id="p118">Vuex 还有其他3个选项可以使用：getters、actions、modules。</p>
                <p class="calibre4 pv pid119" id="p119">有这样的一个场景：Vuex 定义了某个数据list，它是一个数组，比如：</p>
                <pre class="calibre7 pv pid120" id="p120">// main.js，部分代码省略
const store = new Vuex.Store({
    state: {
        list: [1, 5, 8, 10, 30, 50]
    }
});</pre>
                <p class="calibre4 pv pid121" id="p121">如果只想得到小于10的数据，最容易想到的方法可能是在组件的计算属性里进行过滤。示例代码如下：</p>
                <pre class="calibre7 pv pid122" id="p122">// index.vue，部分代码省略
&lt;template&gt;
    &lt;div&gt;
        &lt;div&gt;{{ list }}&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            list () {
                return this.$store.state.list.filter(item =&gt; item &lt; 10);
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid123" id="p123">
                    这样写完全没有问题。但如果还有其他的组件也需要过滤后的数据时，就得把computed的代码完全复制一份，而且需要修改过滤方法时，每个用到的组件都得修改，这明显不是我们期望的结果。如果能将computed的方法也提取出来就方便多了，getters就是来做这件事的。</p>
                <p class="calibre4 pv pid124" id="p124">使用getters改写上面的示例：</p>
                <pre class="calibre7 pv pid125" id="p125">// main.js，部分代码省略
const store = new Vuex.Store({
    state: {
        list: [1, 5, 8, 10, 30, 50]
    },
    getters: {
        filteredList: state =&gt; {
            return state.list.filter(item =&gt; item &lt; 10);
        }
    }
});

// index.vue，部分代码省略
&lt;template&gt;
    &lt;div&gt;
        &lt;div&gt;{{ list }}&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            list () {
                return this.$store.getters.filteredList;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid126" id="p126">
                    这种用法与组件的计算属性非常像。getter也可以依赖其他的getter，把getter作为第二个参数。比如再写一个getter，计算出 list 过滤后的结果的数量：</p>
                <pre class="calibre7 pv pid127" id="p127">// main.js
const store = new Vuex.Store({
    state: {
        list: [1, 5, 8, 10, 30, 50]
    },
    getters: {
        filteredList: state =&gt; {
            return state.list.filter(item =&gt; item &lt; 10);
        },
        listCount: (state, getters) =&gt; {
            return getters.filteredList.length;
        }
    }
});

// index.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;div&gt;{{ list }}&lt;/div&gt;
        &lt;div&gt;{{ listCount }}&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            list () {
                return this.$store.getters.filteredList;
            },
            listCount () {
                return this.$store.getters.listCount;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid128" id="p128">
                    上一节提到，mutation里不应该异步操作数据，所以有了actions选项。action与mutation很像，不同的是action里面提交的是mutation，并且可以异步操作业务逻辑。</p>
                <p class="calibre4 pv pid129" id="p129">action在组件内通过$store.dispatch 触发，例如使用action来加1：</p>
                <pre class="calibre7 pv pid130" id="p130">// main.js部分代码省略
const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment (state, n = 1) {
            state.count += n;
        }
    },
    actions: {
        increment (context) {
            context.commit('increment');
        }
    }
});

// index.vue 部分代码省略
&lt;template&gt;
    &lt;div&gt;
        {{ count }}
        &lt;button @click="handleActionIncrement"&gt;action +1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            count () {
                return this.$store.state.count;
            }
        },
        methods: {
            handleActionIncrement () {
                this.$store.dispatch('increment');
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid131" id="p131">是不是觉得有点多此一举？没错，就目前示例来看的确是，因为可以直接在组件commit
                    mutation，没必要通过action中转一次。但是加了异步就不一样了，我们用一个Promise在1秒钟后提交mutation，示例代码如下：</p>
                <pre class="calibre7 pv pid132" id="p132">// main.js部分代码省略
const store = new Vuex.Store({
    state: {
        count: 0
    },
    mutations: {
        increment (state, n = 1) {
            state.count += n;
        }
    },
    actions: {
        asyncIncrement (context) {
            return new Promise(resolve =&gt; {
                setTimeout(() =&gt; {
                    context.commit('increment');
                    resolve();
                }, 1000)
            });
        }
    }
});

// index.vue 部分代码省略
&lt;template&gt;
    &lt;div&gt;
        {{ count }}
        &lt;button @click="handleAsyncIncrement"&gt;async +1&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            count () {
                return this.$store.state.count;
            }
        },
        methods: {
            handleAsyncIncrement () {
                this.$store.dispatch('asyncIncrement').then(() =&gt; {
                    console.log(this.$store.state.count); // 1
                });
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid133" id="p133">提示</p>
                <p class="kindle-cn-para-no-indent pv pid134" id="p134" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid134" id="p134" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">Promise是一种异步方案，它有3种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。比如下面的示例，通过判断一个随机数是否大于0.5来模拟完成与失败：</span>
                </p>
                <pre class="calibre7 pv pid134" id="p134">const promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        const random = Math.random();
        if (random &gt; 0.5) {
            resolve(random);
        } else {
            reject(random);
        }
    }, 1000);
});

promise.then((value) =&gt; {
    console.log('success', value);
}).catch((error) =&gt; {
    console.log('fail', error);
});</pre>
                <p class="kindle-cn-para-no-indent pv pid135" id="p135" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">如果暂时还不理解Promise，异步action的示例还可以用普通的回调来实现：</span></p>
                <pre class="calibre7 pv pid135" id="p135">// main.js
actions: {
    asyncIncrement (context, callback) {
        setTimeout(() =&gt; {
            context.commit('increment');
            callback();
        }, 1000);
    }
}

// index.vue
methods: {
    handleAsyncIncrement () {
        this.$store.dispatch('asyncIncrement', () =&gt; {
            console.log(this.$store.state.count); // 1
        });
    }
}</pre>
                <p class="calibre4 pv pid136" id="p136">
                    mutations、actions看起来很相似，可能会觉得不知道该用哪个，但是Vuex很像是一种与开发者的约定，所以涉及改变数据的，就使用mutations，存在业务逻辑的，就用actions。至于将业务逻辑放在action里还是Vue组件里完成，就需要根据实际场景拿捏了。</p>
                <p class="calibre4 pv pid137" id="p137">
                    最后一个选项是modules，它用来将store分割到不同模块。当你的项目足够大时，store里的state、getters、mutations、actions会非常多，都放在main.js里显得不是很友好，使用modules可以把它们写到不同的文件中。每个module
                    拥有自己的state、getters、mutations、actions，而且可以多层嵌套。</p>
                <p class="calibre4 pv pid138" id="p138">比如下面的示例：</p>
                <pre class="calibre7 pv pid139" id="p139">const moduleA = {
    state: { ... },
    mutations: { ... },
    actions: { ... },
    getters: { ... }
}

const moduleB = {
    state: { ... },
    mutations: { ... },
    actions: { ... }
}

const store = new Vuex.Store({
    modules: {
        a: moduleA,
        b: moduleB
    }
})

store.state.a // moduleA的状态
store.state.b // moduleB的状态</pre>
                <p class="calibre4 pv pid140" id="p140">
                    module的mutation和getter接收的第一个参数state是当前模块的状态。在actions和getters中，还可以接收一个参数rootState，来访问根节点的状态。比如getters中rootState将作为第3个参数：</p>
                <pre class="calibre7 pv pid141" id="p141">const moduleA = {
    state: {
        count: 0
    },
    getters: {
        sumCount (state, getters, rootState) {
            return state.count + rootState.count;
        }
    }
}</pre>
                <p class="calibre4 pv pid142" id="p142">本节所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid143" id="p143">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid144" id="p144">vue-book下的vuex目录就是本节的代码，在该目录下执行npm install命令会自动安装所有的依赖，然后执行npm
                    run dev启动服务。</p>
                <p class="calibre4 pv pid145" id="p145" style="margin: 0px;"><span class="kindle-cn-bold">拓展阅读建议：</span>可以到Vuex文档进一步阅读它更多的用法：https://vuex.vuejs.org
                    。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_101 pv pid145" id="p145" name="sigil_toc_id_101">
                    11.3　实战：中央事件总线插件vue-bus</h3>
                <p class="calibre4 pv pid146" id="p146">
                    在第7章的7.3.3小节介绍了中央事件总线bus的用法，它作为一个简单的组件传递事件，用于解决跨级和兄弟组件通信的问题。本节将使用该思想将其封装为一个Vue的插件，可以在所有组件间随意使用，而不需要导入bus。</p>
                <p class="calibre4 pv pid147" id="p147">
                    本节是在上一节的Vuex基础之上进行开发的，在本地创建目录vue-bus，然后复制上一节的所有代码，或直接从https://github.com/icarusion/vue-book下载后，使用vuex目录下的代码。</p>
                <p class="calibre4 pv pid148" id="p148">
                    完成基本安装后，在vue-bus目录下新建vue-bus.js文件。vue-bus插件像vue-router和Vuex一样，给Vue添加一个属性$bus，并代理
                    $emit、$on、$off三个方法。代码如下：</p>
                <pre class="calibre7 pv pid149" id="p149">// vue-bus.js
const install = function (Vue) {
    const Bus = new Vue({
        methods: {
            emit (event, ...args) {
                this.$emit(event, ...args);
            },
            on (event, callback) {
                this.$on(event, callback);
            },
            off (event, callback) {
                this.$off(event, callback);
            }
        }
    });
    Vue.prototype.$bus = Bus;
};
export default install;</pre>
                <p class="kindle-cn-para-left pv pid150" id="p150">提示</p>
                <p class="kindle-cn-para-no-indent pv pid151" id="p151" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid151" id="p151" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">emit (event, ...args)中的...args是函数参数的解构。因为不知道组件会传递多少个参数进来，使用...args可以把从当前参数（这里是第二个）到最后的参数都获取到。</span>
                </p>
                <p class="calibre4 pv pid151" id="p151">在main.js中使用插件：</p>
                <pre class="calibre7 pv pid152" id="p152">// main.js，部分代码省略

import VueBus from './vue-bus';
Vue.use(VueBus);</pre>
                <p class="calibre4 pv pid153" id="p153">在views目录下新建一个组件Counter.vue：</p>
                <pre class="calibre7 pv pid154" id="p154">// views/counter.vue
&lt;template&gt;
    &lt;div&gt;
        {{ number }}
        &lt;button @click="handleAddRandom"&gt;随机增加&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        props: {
            number: {
                type: Number
            }
        },
        methods: {
            handleAddRandom () {
                // 随机获取1~100中的数
                const num = Math.floor(Math.random () * 100 + 1);
                this.$bus.emit('add', num);
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid155" id="p155">在index.vue中使用Counter组件并监听来自counter.vue的自定义事件：</p>
                <pre class="calibre7 pv pid156" id="p156">// index.vue，部分代码省略
&lt;template&gt;
    &lt;div&gt;
        随机增加：
        &lt;Counter :number="number"&gt;&lt;/Counter&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Counter from './counter.vue';

    export default {
        components: {
            Counter
        },
        data () {
            return {
                number: 0
            }
        },
        created () {
            this.$bus.on('add', num =&gt; {
                this.number += num;
            });
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid157" id="p157">
                    vue-bus的代码比较简单，只有不到20行，但它却解决了跨组件通信的问题，而且通过插件的形式使用后，所有组件都可以直接使用$bus，而无须每个组件都导入bus组件。</p>
                <p class="calibre4 pv pid158" id="p158">
                    使用vue-bus有两点需要注意，第一是$bus.on应该在created钩子内使用，如果在mounted使用，它可能接收不到其他组件来自created钩子内发出的事件；第二点是使用了$bus.on，在beforeDestroy钩子里应该再使用$bus.off解除，因为组件销毁后，就没必要把监听的句柄储存在vue-bus里了，所以index.vue可以适当改写为：</p>
                <pre class="calibre7 pv pid159" id="p159">&lt;template&gt;
    &lt;div&gt;
        随机增加：
        &lt;Counter :number="number"&gt;&lt;/Counter&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Counter from './counter.vue';

    export default {
        components: {
            Counter
        },
        methods: {
            handleAddRandom (num) {
                this.number += num;
            }
        },
        data () {
            return {
                number: 0
            }
        },
        created () {
            this.$bus.on('add', this.handleAddRandom);
        },
        beforeDestroy () {
            this.$bus.off('add', this.handleAddRandom);
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid160" id="p160">本节所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid161" id="p161">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid162" id="p162">vue-book下的vue-bus目录就是本节的代码，在该目录下执行npm
                    install命令会自动安装所有的依赖，然后执行npm run dev启动服务。</p>
                <p class="calibre4 pv pid163" id="p163" style="margin: 0px;"><span class="kindle-cn-bold">练习：</span>学习XMLHttpRequest（即XHR）相关知识，开发一个简单的$ajax插件，用于异步获取服务端数据。以下实现Ajax的代码可以作为参考：
                </p>
                <pre class="calibre7 pv pid163" id="p163">const ajax = function (options = {}) {
    options.type = (options.type || 'GET').toUpperCase();

    let data = [];
    for(let i in options.data){
        data.push(encodeURIComponent(i) +
            '=' + encodeURIComponent(options.data[i]));
    }
    data = data.join('&amp;');

    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            const status = xhr.status;
            if (status &gt;= 200 &amp;&amp; status &lt; 300) {
                options.success &amp;&amp;
                options.success(JSON.parse(xhr.responseText), xhr.responseXML);
            } else {
                options.error &amp;&amp; options.error(status);
            }
        }
    };
    if (options.type === 'GET') {
        xhr.open('GET', options.url + '?' + data, true);
        xhr.send(null);
    } else if (options.type === 'POST') {
        xhr.open('POST', options.url, true);
        xhr.setRequestHeader(
            'Content-Type',
            'application/x-www-form-urlencoded');
        xhr.send(data);
    }
};</pre>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="120" data-chapter-url="24047100" alt="64157374">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px">
                <div class="calibre3 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0"></div>
                <h1 class="kindle-cn-heading calibre_pb_1 pv pid3" id="p3" name="calibre_pb_1">第3篇　实战篇</h1>
                <p class="calibre4 pv pid4" id="p4">基础篇和进阶篇的内容已经涵盖了Vue
                    2绝大部分知识点，如果你已经认真阅读过，那么是时候实战了。从下一章开始，会从不同的几个维度来讲述一些实战案例。</p>
                <p class="calibre4 pv pid5" id="p5">第12章将介绍基于Vue
                    2的一套高质量UI组件库——iView。iView是一整套的前端解决方案，本书会介绍它的几个具有代表性的组件设计思想并做代码剖析。</p>
                <p class="calibre4 pv pid6" id="p6">第13章将实现一个Vue版的知乎日报，会用到webpack、vue-router、vuex。</p>
                <p class="calibre4 pv pid7" id="p7">
                    第14章将开发一个简易的电商网站项目，包括商品列表、详情、购物车等常用功能，同样基于webpack、vue-router和vuex。</p>
                <p class="calibre4 pv pid8" id="p8">实战篇的章节代码示例要比基础篇和进阶篇稍有难度，书写风格完全基于ES 6，所以需要掌握进阶篇中所有的ES
                    6语法提示的内容。每一章的完整代码都提交在GitHub，访问地址也会在章末提及。</p>
                <p class="calibre4 pv pid9" id="p9">
                    实战篇的所有内容都是基于真实的生产环境考虑的，所涉及的内容涵盖Vue.js绝大部分API，它很有借鉴意义，但并不一定是适合你的最佳实践。所以在你的项目中，可以根据实际情况来组织代码架构。比如你完全可以不用ES
                    6，而只是使用ES
                    5就足以；再比如可以不使用vuex，而用bus代替；当然，如果你的团队技术不错，可以使用TypeScript等语言来开发。总之，实战篇更多提供的是灵感，而你需要在技术选型上找到平衡。</p>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="121" data-chapter-url="24047101" alt="64157375">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第12章　iView经典组件剖析</h2>
                <p class="calibre4 pv pid3" id="p3">iView是一套基于Vue.js
                    2的开源UI组件库，主要服务于PC界面的中后台产品。简单地理解，它是深度封装的40多个常用业务组件，比如Input、Checkbox、Select、Table；但它同时也是一整套的前端解决方案，包括设计规范、基础样式，支持服务端渲染（SSR），同时提供了可视化脚手架，方便快速构建项目工程。iView的官方网站和GitHub
                    地址如下。</p>
                <p class="calibre4 pv pid4" id="p4">官方网站：https://www.iviewui.com/。</p>
                <p class="calibre4 pv pid5" id="p5">GitHub：https://github.com/iview/iview。</p>
                <p class="calibre4 pv pid6" id="p6">图12-1 展示了部分 iView组件的截图。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid7" id="p7" style="margin: 0px;"><img alt="249"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/062a93da3ff54bab.jpg"
                                                                                                       href="./image/00041.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-1　iView部分组件截图</p></div>
                <p class="calibre4 pv pid7" id="p7">
                    从左往右，从上到下依次为：Slider滑块、DatePicker日期选择器、Select选择器、Cascader级联选择器、Poptip气泡提示、Page分页。</p>
                <p class="calibre4 pv pid8" id="p8">iView以高质量、细致漂亮的UI、事无巨细的文档等特点成为Vue.js组件库中最受欢迎的项目之一。本章就来剖析 iView
                    几个具有代表性的组件，重点是理解设计一个通用组件和组件库的的思想和过程。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_102 pv pid9" id="p9" name="sigil_toc_id_102">
                    12.1　级联选择组件Cascader</h3>
                <p class="calibre4 pv pid10" id="p10">
                    级联选择是网页应用中常见的表单类控件，主要用于省市区、公司级别、事务分类等关联数据集合的选择。iView的级联选择组件如图12-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid11" id="p11" style="margin: 0px;"><img alt="250"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/473118a536020ef6.jpg"
                                                                                                         href="./image/00042.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-2　iView级联选择组件</p></div>
                <p class="calibre4 pv pid11" id="p11">
                    Cascader接收一个prop：data作为选择面板的数据源，使用v-model可以双向绑定当前选择的项。比如图12-2的示例代码如下：</p>
                <pre class="calibre7 pv pid12" id="p12">&lt;template&gt;
    &lt;Cascader :data="data" v-model="value"&gt;&lt;/Cascader&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                value: ['jiangsu', 'suzhou', 'zhuozhengyuan'],
                data: [{
                    value: 'beijing',
                    label: '北京',
                    children: [
                        {
                            value: 'gugong',
                            label: '故宫'
                        },
                        {
                            value: 'tiantan',
                            label: '天坛'
                        },
                        {
                            value: 'wangfujing',
                            label: '王府井'
                        }
                    ]
                }, {
                    value: 'jiangsu',
                    label: '江苏',
                    children: [
                        {
                            value: 'nanjing',
                            label: '南京',
                            children: [
                                {
                                    value: 'fuzimiao',
                                    label: '夫子庙'
                                }
                            ]
                        },
                        {
                            value: 'suzhou',
                            label: '苏州',
                            children: [
                                {
                                    value: 'zhuozhengyuan',
                                    label: '拙政园'
                                },
                                {
                                    value: 'shizilin',
                                    label: '狮子林'
                                }
                            ]
                        }
                    ]
                }]
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid13" id="p13">
                    data中的label是面板显示的内容，value是它对应的值，children是它的子集，可递归。v-model绑定一个数组，每一项对应 data里的value。</p>
                <p class="calibre4 pv pid14" id="p14">
                    Cascader对应的文档地址为https://www.iviewui.com/components/cascader，源代码地址为https://github.com/iview/iview/tree/2.0/src/components/cascader。</p>
                <p class="kindle-cn-para-left pv pid15" id="p15">提示</p>
                <p class="kindle-cn-para-no-indent pv pid16" id="p16" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">iView的每个组件往往依赖其他的组件，比如Cascader依赖Input、Drop、Icon组件，所以在剖析Cascader时，不会再对它依赖的组件进行详细介绍，可以到GitHub或文档查看依赖组件的相关内容。</span>
                </p>
                <p class="kindle-cn-para-no-indent pv pid16" id="p16" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本章是基于iView的2.0.0-rc.10版本，未来有可能会更新此组件，可到文档查阅更新日志：https://www.iviewui.com/docs/guide/update。</span>
                </p>
                <p class="kindle-cn-para-no-indent pv pid16" id="p16" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">本章的示例代码并不是完整的，只是剖析核心的功能，分析设计思路，完整的代码请前往GitHub查看。</span></p>
                <p class="calibre4 pv pid16" id="p16">
                    开发一个通用组件最重要的是定义API，Vue组件的API来自3部分：prop、slot和event。API决定了一个组件的所有功能，而且作为对外提供的组件，一旦API确定好后，如果再迭代更新，用户的代价就会很高，因为他们已经在业务中使用你的组件，改动太多意味着所有用到的地方都需要改动，所以组件库更新分兼容更新和不兼容更新，不是迫不得已，最好后续的更新都是兼容性的，这对使用者会很友好。</p>
                <p class="calibre4 pv pid17" id="p17">从功能上考虑，先来定义Cascader的prop。</p>
                <ul class="kindle-cn-ul-disc pv pid18" id="p18" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">data：决定了级联面板的内容。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">value：当前选择项，可使用v-model。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">disabled：是否禁用。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">clearable：是否可清空。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">placeholder：占位提示。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">size：尺寸（iView 多数表单类组件都有尺寸）。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">trigger：触发方式（点击或鼠标滑入）。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">changeOnSelect：选择即改变。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">renderFormat：自定义显示内容。</span></li>
                </ul>
                <p class="calibre4 pv pid18" id="p18">对应的代码如下：</p>
                <pre class="calibre7 pv pid19" id="p19">// cascader.vue
&lt;script&gt;
    export default {
        props: {
            data: {
                type: Array,
                default () {
                    return [];
                }
            },
            value: {
                type: Array,
                default () {
                    return [];
                }
            },
            disabled: {
                type: Boolean,
                default: false
            },
            clearable: {
                type: Boolean,
                default: true
            },
            placeholder: {
                type: String,
                default: '请选择'
            },
            size: {
                validator (value) {
                    return oneOf(value, ['small', 'large']);
                }
            },
            trigger: {
                validator (value) {
                    return oneOf(value, ['click', 'hover']);
                },
                default: 'click'
            },
            changeOnSelect: {
                type: Boolean,
                default: false
            },
            renderFormat: {
                type: Function,
                default (label) {
                    return label.join(' / ');
                }
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid20" id="p20">
                    Cascader的核心是用到了组件递归，在本书7.5.1小节有介绍相关用法。使用组件递归必不可少的两个条件是有name选项和在适当的时候结束递归。图12-2中所示的级联选择面板每一列都是一个组件Caspanel（caspanel.vue），data中的children
                    决定了每项的子集，也就是需要递归显示 Caspanel的数量。</p>
                <p class="calibre4 pv pid21" id="p21">看一下Caspanel的相关代码：</p>
                <pre class="calibre7 pv pid22" id="p22">// caspanel.vue
&lt;template&gt;
    &lt;span&gt;
        &lt;ul v-if="data &amp;&amp; data.length" :class="[prefixCls + '-menu']"&gt;
            &lt;Casitem
                v-for="item in data"
                :key="item"
                :prefix-cls="prefixCls"
                :data="item"
                :tmp-item="tmpItem"
                @click.native.stop="handleClickItem(item)"
                @mouseenter.native.stop="handleHoverItem(item)"&gt;&lt;/Casitem&gt;
        &lt;/ul&gt;&lt;Caspanel v-if="sublist &amp;&amp; sublist.length"
:prefix-cls="prefixCls" :data="sublist" :disabled="disabled"
:trigger="trigger" :change-on-select="changeOnSelect"&gt;&lt;/Caspanel&gt;
    &lt;/span&gt;
&lt;/template&gt;
&lt;script&gt;
    import Casitem from './casitem.vue';

    export default {
        name: 'Caspanel',
        components: { Casitem },
        props: {
            data: {
                type: Array,
                default () {
                    return [];
                }
            },
            disabled: Boolean,
            changeOnSelect: Boolean,
            trigger: String,
            prefixCls: String
        },
        data () {
            return {
                tmpItem: {},
                result: [],
                sublist: []
            };
        },
        watch: {
            data () {
                this.sublist = [];
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid23" id="p23">
                    当点击某一列的某一项时，会把它对应data的children数据赋给sublist，sublist会作为下一个递归的Caspanel的data使用，以此类推。若该项没有children，说明它是级联选择的最后一项，则点击直接结束选择，同时约束了Caspanel的递归。</p>
                <p class="calibre4 pv pid24" id="p24">最里层的组件是Casitem，就是每列的每项，它的作用就是把data或children的每个label显示出来。</p>
                <p class="calibre4 pv pid25" id="p25">
                    Cascader的基本构成就是上述的3部分：cascader.vue、caspanel.vue和casitem.vue。cascader.vue
                    又分成两部分：只读输入框（Input）和下拉菜单（Drop），在下拉菜单中使用第一个Caspanel，开始递归每一列。cascader.vue的template代码为：</p>
                <pre class="calibre7 pv pid26" id="p26">// cascader.vue
&lt;template&gt;
    &lt;div :class="classes" v-clickoutside="handleClose"&gt;
        &lt;div :class="[prefixCls + '-rel']" @click="toggleOpen"&gt;
            &lt;slot&gt;
                &lt;i-input
                    readonly
                    :disabled="disabled"
                    v-model="displayRender"
                    :size="size"
                    :placeholder="placeholder"&gt;&lt;/i-input&gt;
                &lt;Icon
                    type="ios-close" :class="[prefixCls + '-arrow']"
                    v-show="showCloseIcon"
                    @click.native.stop="clearSelect"&gt;&lt;/Icon&gt;
                &lt;Icon type="arrow-down-b" :class="[prefixCls + '-arrow']"&gt; &lt;/Icon&gt;
            &lt;/slot&gt;
        &lt;/div&gt;
        &lt;transition name="slide-up"&gt;
            &lt;Drop v-show="visible"&gt;
                &lt;div&gt;
                    &lt;Caspanel
                        ref="caspanel"
                        :prefix-cls="prefixCls"
                        :data="data"
                        :disabled="disabled"
                        :change-on-select="changeOnSelect"
                        :trigger="trigger"&gt;&lt;/Caspanel&gt;
                &lt;/div&gt;
            &lt;/Drop&gt;
        &lt;/transition&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import iInput from '../input/input.vue';
    import Drop from '../select/dropdown.vue';
    import Icon from '../icon/icon.vue';
    import Caspanel from './caspanel.vue';
    import clickoutside from '../../directives/clickoutside';

    // CSS命名空间
    const prefixCls = 'ivu-cascader';

    export default {
        name: 'Cascader',
        components: { iInput, Drop, Icon, Caspanel },
        // 点击外部关闭的自定义指令，详见 8.2.1
        directives: { clickoutside },
        props: {
            // 省略
        },
        data () {
            return {
                prefixCls: prefixCls,
                visible: false,
                selected: [],
                tmpSelected: [],
                updatingValue: false,
                // 用于实现 v-model
                currentValue: this.value
            };
        },
        computed: {
            classes () {
                return [
                    `${prefixCls}`,
                    {
                        [`${prefixCls}-show-clear`]: this.showCloseIcon,
                        [`${prefixCls}-visible`]: this.visible,
                        [`${prefixCls}-disabled`]: this.disabled
                    }
                ];
            },
            showCloseIcon () {
                return this.currentValue &amp;&amp; this.currentValue.length &amp;&amp; this.clearable &amp;&amp; !this.disabled;
            },
            // 自定义显示内容
            displayRender () {
                let label = [];
                for (let i = 0; i &lt; this.selected.length; i++) {
                    label.push(this.selected[i].label);
                }

                return this.renderFormat(label, this.selected);
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid27" id="p27">
                    Input（i-input）组件在默认的slot内，这意味着你可以自定义触发器部分，不局限于使用输入框，这让Cascader使用更灵活。使用slot时，需要自己渲染显示的内容，所以提供了事件on-change，在选择完成时触发，返回value和selectedData，分别为已选值和已选项的具体数据。示例代码如下：</p>
                <pre class="calibre7 pv pid28" id="p28">&lt;template&gt;
    {{ text }}
    &lt;Cascader :data="data" @on-change="handleChange"&gt;
        &lt;a href="javascript:void(0)"&gt;选择&lt;/a&gt;
    &lt;/Cascader&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                text: '未选择',
                data: [
                    // 省略
                ]
            }
        },
        methods: {
            handleChange (value, selectedData) {
                this.text = selectedData.map(o =&gt; o.label).join(', ');
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid29" id="p29">Cascader各个组件之间的通信关系如图12-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid30" id="p30" style="margin: 0px;"><img alt="258"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/16554e9f6f8df545.jpg"
                                                                                                         href="./image/00043.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-3　Cascader组件的通信关系</p></div>
                <p class="calibre4 pv pid30" id="p30">我们已经多次介绍过，在Vue
                    2里，组件间通信可以通过$emit、bus、vuex来实现。但是iView作为独立组件，无法使用bus和vuex，为了实现跨组件通信，iView模拟了Vue
                    1的dispatch和broadcast方法。代码如下：</p>
                <pre class="calibre7 pv pid31" id="p31">// src/mixins/emitter.js
function broadcast(componentName, eventName, params) {
    this.$children.forEach(child =&gt; {
        const name = child.$options.name;

        if (name === componentName) {
            child.$emit.apply(child, [eventName].concat(params));
        } else {
            broadcast.apply(child, [componentName, eventName].concat([params]));
        }
    });
}
export default {
    methods: {
        dispatch(componentName, eventName, params) {
            let parent = this.$parent || this.$root;
            let name = parent.$options.name;

            while (parent &amp;&amp; (!name || name !== componentName)) {
                parent = parent.$parent;

                if (parent) {
                    name = parent.$options.name;
                }
            }
            if (parent) {
                parent.$emit.apply(parent, [eventName].concat(params));
            }
        },
        broadcast(componentName, eventName, params) {
            broadcast.call(this, componentName, eventName, params);
        }
    }
};</pre>
                <p class="calibre4 pv pid32" id="p32">
                    emitter.js使用递归向上或向下的方式查找指定的组件名称（name），找到后触发$emit。有了emitter.js就可以自由的跨组件通信了。图12-3中，在初始化时（mounted），Cascader需要判断是否已经设置了选中值，若设置了，则所有的Caspanel和Casitem更新选中状态。这个过程是在Cascader使用broadcast通知Caspanel，然后递归通知附属的Caspanel。同理，当从父组件修改value时，也执行检查（即updateSelected方法）。在点击Casitem时，使用dispatch通知Cascader来更新在输入框中的选中值，这样基本就形成了一个闭环。下面来看一下与通信相关的代码：</p>
                <pre class="calibre7 pv pid33" id="p33">// cascader.vue
&lt;script&gt;
    import Emitter from '../../mixins/emitter';
    export default {
        mixins: [ Emitter ],
        methods: {
            updateSelected (init = false) {
                if (!this.changeOnSelect || init) {
                    // 通知Caspanel 更新当前选中值
                    this.broadcast('Caspanel', 'on-find-selected', {
                        value: this.currentValue
                    });
                }
            },
            emitValue (val, oldVal) {
                if (JSON.stringify(val) !== oldVal) {
                    // 暴露接口
                    this.$emit('on-change', this.currentValue, JSON.parse(JSON.stringify (this.selected)));
                }
            }
        },
        mounted () {
            // 初始化时更新选中数据
            this.updateSelected(true);
            // 当点击 casitem时，会派发事件到这里
            this.$on('on-result-change', (params) =&gt; {
                const lastValue = params.lastValue;
                const changeOnSelect = params.changeOnSelect;
                const fromInit = params.fromInit;

                if (lastValue || changeOnSelect) {
                    const oldVal = JSON.stringify(this.currentValue);
                    this.selected = this.tmpSelected;

                    let newVal = [];
                    this.selected.forEach((item) =&gt; {
                        newVal.push(item.value);
                    });

                    if (!fromInit) {
                        this.updatingValue = true;
                        this.currentValue = newVal;
                        this.emitValue(this.currentValue, oldVal);
                    }
                }
                if (lastValue &amp;&amp; !fromInit) {
                    this.handleClose();
                }
            });
        },
        watch: {
            // 每次展开下拉面板时都更新一次选中的数据
            visible (val) {
                if (val) {
                    if (this.currentValue.length) {
                        this.updateSelected();
                    }
                }
                this.$emit('on-visible-change', val);
            },
            // v-model的基本实现方法
            value (val) {
                this.currentValue = val;
                if (!val.length) this.selected = [];
            },
            currentValue () {
                this.$emit('input', this.currentValue);
                if (this.updatingValue) {
                    this.updatingValue = false;
                    return;
                }
                this.updateSelected(true);
            },
            // 如果数据源变了，也更新选中的数据
            data () {
                this.$nextTick(() =&gt; this.updateSelected());
            }
        }
    };
&lt;/script&gt;

// caspanel.vue
&lt;script&gt;
    import Emitter from '../../mixins/emitter';
    export default {
        mixins: [ Emitter ],
        methods: {
            // 点击选中
            handleClickItem (item) {
                if (this.trigger !== 'click' &amp;&amp; item.children) return;
                this.handleTriggerItem(item);
            },
            // 鼠标滑过选中
            handleHoverItem (item) {
                if (this.trigger !== 'hover' || !item.children) return;
                this.handleTriggerItem(item);
            },
            handleTriggerItem (item, fromInit = false) {
                if (item.disabled) return;

                // 向上递归，设置临时选中值（并非真实选中）
                const backItem = this.getBaseItem(item);
                this.tmpItem = backItem;
                this.emitUpdate([backItem]);

                // 通知Cascader更新选中值
                if (item.children &amp;&amp; item.children.length){
                    this.sublist = item.children;
                    this.dispatch('Cascader', 'on-result-change', {
                        lastValue: false,
                        changeOnSelect: this.changeOnSelect,
                        fromInit: fromInit
                    });
                } else {
                    this.sublist = [];
                    this.dispatch('Cascader', 'on-result-change', {
                        lastValue: true,
                        changeOnSelect: this.changeOnSelect,
                        fromInit: fromInit
                    });
                }
            },
            updateResult (item) {
                this.result = [this.tmpItem].concat(item);
                this.emitUpdate(this.result);
            },
            getBaseItem (item) {
                let backItem = Object.assign({}, item);
                if (backItem.children) {
                    delete backItem.children;
                }

                return backItem;
            },
            emitUpdate (result) {
                if (this.$parent.$options.name === 'Caspanel') {
                    this.$parent.updateResult(result);
                } else {
                    this.$parent.$parent.updateResult(result);
                }
            }
        },
        mounted () {
            // 接收来自Cascader和Caspanel的更新选中值事件
            this.$on('on-find-selected', (params) =&gt; {
                const val = params.value;
                let value = [...val];
                for (let i = 0; i &lt; value.length; i++) {
                    for (let j = 0; j &lt; this.data.length; j++) {
                        if (value[i] === this.data[j].value) {
                            this.handleTriggerItem(this.data[j], true);
                            value.splice(0, 1);
                            this.$nextTick(() =&gt; {
                                // 继续向下递归更新选中状态
                                this.broadcast('Caspanel', 'on-find-selected', {
                                    value: value
                                });
                            });
                            return false;
                        }
                    }
                }
            });
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid34" id="p34">
                    独立组件与业务组件最大的不同是，业务组件往往针对数据的获取、整理、可视化，逻辑清晰简单，可以使用vuex；而独立组件的复杂度更多集中在细节、交互、性能优化、API设计上，对原生JavaScript有一定考验。在使用过程中，可能会有新功能的不断添加，也会发现隐藏的bug，所以独立组件一开始逻辑和代码量并不复杂，多次迭代后会越来越冗长，当然功能也更丰富，使用更稳定。万事开头难，组件API的设计和可扩展性决定了组件迭代的复杂性。一开始不可能考虑到所有的细节，但是整体架构要清晰可扩展，否则很有可能重构。</p>
                <p class="calibre4 pv pid35" id="p35">
                    iView还有与Cascader类似思路的组件——树形控件（Tree），同样有着巧妙的设计，值得研究，源代码地址：https://github.com/iview/iview/tree/2.0/src/components/tree。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_103 pv pid36" id="p36" name="sigil_toc_id_103">
                    12.2　折叠面板组件Collapse</h3>
                <p class="calibre4 pv pid37" id="p37">折叠面板也是网站常用控件，可将一组内容区域展开或折叠，使页面干净整洁。iView的折叠面板组件如图12-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid38" id="p38" style="margin: 0px;"><img alt="264"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/a95cf5a4407c7f74.jpg"
                                                                                                         href="./image/00044.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-4　iView折叠面板Collapse</p></div>
                <p class="calibre4 pv pid38" id="p38">
                    相比上一节的Cascader，Collapse组件无论从UI还是交互上都要简单得多，基于已有的知识，你完全可以自行开发出一个折叠面板组件来。通过本节的学习后，可以进一步了解组件开发中的一些细节和设计。在学习本节内容前，不妨先独立开发一个Collapse，然后与iView的Collapse进行对比。</p>
                <p class="calibre4 pv pid39" id="p39">
                    Collapse对应的文档地址为https://www.iviewui.com/components/collapse，源代码地址为https://github.com/iview/iview/tree/2.0/src/components/collapse。</p>
                <p class="calibre4 pv pid40" id="p40">
                    Collapse组件分为两部分：collapse.vue和panel.vue，collapse作为组件容器，接收一个整体的slot，而slot就由panel组成，并且可以进行折叠面板的嵌套。collapse支持v-model来双向绑定当前激活的面板，判断激活的依据是panel的prop：name，所以Collapse组件的基本结构和props如下：</p>
                <pre class="calibre7 pv pid41" id="p41">// collapse.vue
&lt;template&gt;
    &lt;div :class="classes"&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    // CSS的命名空间
    const prefixCls = 'ivu-collapse';

    export default {
        name: 'Collapse',
        props: {
            //是否为手风琴模式，该模式下同时只能展开一个面板
            accordion: {
                type: Boolean,
                default: false
            },
            //对应panel.vue展开的name，手风琴模式下为数组
            value: {
                type: [Array, String]
            }
        },
        data () {
            return {
                // 设置内部使用状态，用于实现v-model
                currentValue: this.value
            };
        },
        computed: {
            classes () {
                return `${prefixCls}`;
            }
        },
        watch: {
            value (val) {
                // 从外部改变value时，更新内部的数据
                this.currentValue = val;
            }
        }
    };
&lt;/script&gt;

// panel.vue
&lt;template&gt;
    &lt;div :class="itemClasses"&gt;
        &lt;div :class="headerClasses"&gt;
            &lt;Icon type="arrow-right-b"&gt;&lt;/Icon&gt;
            &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div :class="contentClasses"&gt;
            &lt;div :class="boxClasses"&gt;
                &lt;slot name="content"&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    // 依赖 iView的图标组件，这里使用小箭头
    import Icon from '../icon/icon.vue';
    // CSS的命名空间
    const prefixCls = 'ivu-collapse';

    export default {
        name: 'Panel',
        components: { Icon },
        props: {
            name: {
                // 用于唯一识别当前面板
                type: String
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid42" id="p42">Panel有两个slot，默认为面板头部的内容，也就是标题，名为content的slot为主体内容。</p>
                <p class="calibre4 pv pid43" id="p43">
                    如果没有指定name（有些场景不关心是哪个面板，只是需要折叠面板这个功能），Collapse就会在初始化时遍历Panel组件，动态地设置一个index。Collapse会优先识别name，在没有定义时才使用自动设置的index。slot：content只在当前面板激活时显示，所以还需要增加一个数据isActive来控制显示与否，并通过点击默认的slot来切换。这部分代码如下：</p>
                <pre class="calibre7 pv pid44" id="p44">// panel.vue，部分代码省略
&lt;template&gt;
    &lt;div :class="itemClasses"&gt;
        &lt;div :class="headerClasses" @click="toggle"&gt;
            &lt;Icon type="arrow-right-b"&gt;&lt;/Icon&gt;
            &lt;slot&gt;&lt;/slot&gt;
        &lt;/div&gt;
        &lt;div :class="contentClasses" v-show="isActive"&gt;
            &lt;div :class="boxClasses"&gt;
                &lt;slot name="content"&gt;&lt;/slot&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                index: 0,
                isActive: false
            };
        },
        methods: {
            toggle () {
                // 访问父链（即collapse.vue）执行方法，稍后介绍
                this.$parent.toggle({
                    // 优先使用name，未定义时使用index
                    // index和isActive都在collapse.vue中设置，稍后介绍
                    name: this.name || this.index,
                    isActive: this.isActive
                });
            }
        },
        // 动态设置相关CSS类名
        computed: {
            itemClasses () {
                return [
                    `${prefixCls}-item`,
                    {
                        [`${prefixCls}-item-active`]: this.isActive
                    }
                ];
            },
            headerClasses () {
                return `${prefixCls}-header`;
            },
            contentClasses () {
                return `${prefixCls}-content`;
            },
            boxClasses () {
                return `${prefixCls}-content-box`;
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid45" id="p45">
                    以上是所有Panel组件的代码。接下来在collapse.vue初始化时，通过访问子链（即遍历所有的panel.vue）来给panel动态设置index和isActive。Collapse中有两个方法：getActiveKey和setActive，前者用于将当前激活面板的受控数据currentValue根据是否为手风琴状态做处理，使两种模式下的数据格式统一。setActive是遍历
                    Panel，并设置其index和isActive。相关代码如下：</p>
                <pre class="calibre7 pv pid46" id="p46">// collapse.vue，部分代码省略
export default {
    methods: {
        getActiveKey () {
            let activeKey = this.currentValue || [];
            const accordion = this.accordion;
            /*
            * value的类型可以是字符串或数组，
            *为保证数据格式统一，将activeKey强行设置为数组因为不能保证用户设置的都是数组
            */
            if (!Array.isArray(activeKey)) {
                activeKey = [activeKey];
            }
            // 手风琴模式下，如果多设置了数组，也只取其第一项
            if (accordion &amp;&amp; activeKey.length &gt; 1) {
                activeKey = [activeKey[0]];
            }
            //将activeKey转为字符串，因为用户设置的有可能是字符串数字，比较时类型会不一致
            for (let i = 0; i &lt; activeKey.length; i++) {
                activeKey[i] = activeKey[i].toString();
            }

            return activeKey;
        },
        setActive () {
            const activeKey = this.getActiveKey();
            this.$children.forEach((child, index) =&gt; {
                const name = child.name || index.toString();
                let isActive = false;
                //在两种模式下，判断当前 Panel是否需要激活
                if (self.accordion) {
                    isActive = activeKey === name;
                } else {
                    isActive = activeKey.indexOf(name) &gt; -1;
                }
                //给当前 Panel 设置 isActive和index，index为它在slot中的序列
                child.isActive = isActive;
                child.index = index;
            });
        }
    },
    mounted () {
        // 初始化时，设置 isActive和index
        this.setActive();
    },
    watch: {
        value (val) {
            this.currentValue = val;
        },
        //修改currentValue时，重新设置一遍状态
        currentValue () {
            this.setActive();
        }
    }
};</pre>
                <p class="calibre4 pv pid47" id="p47">
                    最后还剩余在Panel中遗留的一个toggle方法，当切换面板的激活与隐藏状态时，需要更新currentValue，并发出自定义事件input和on-change，其中input是为了实现v-model语法糖，代码如下：</p>
                <pre class="calibre7 pv pid48" id="p48">// collapse.vue，部分代码省略
export default {
    methods: {
        /*
        * data由Panel传递，有两项：
        * name，当前 Panel的name或index的值
        * isActive，当前是否激活
        */
        toggle (data) {
            const name = data.name.toString();
            // 声明一个临时激活项列表
            let newActiveKey = [];
            if (this.accordion) {
                /*
                * 手风琴模式下，同时只能激活一个面板
                * 如果当前未激活，就将它的name写入临时列表
                * 如果已激活，意味着关闭所有的面板，所以不用任何设置
                */
                if (!data.isActive) {
                    newActiveKey.push(name);
                }
            } else {
                let activeKey = this.getActiveKey();
                const nameIndex = activeKey.indexOf(name);
                // 点击后切换为关闭
                if (data.isActive) {
                    if (nameIndex &gt; -1) {
                        activeKey.splice(nameIndex, 1);
                    }
                // 点击后切换为展开
                } else {
                    if (nameIndex &lt; 0) {
                        activeKey.push(name);
                    }
                }
                newActiveKey = activeKey;
            }
            // 更新currentValue会触发watch，从而调用setActive方法
            this.currentValue = newActiveKey;
            this.$emit('input', newActiveKey);
            this.$emit('on-change', newActiveKey);
        }
    }
}</pre>
                <p class="calibre4 pv pid49" id="p49">以上就是Collapse组件所有的代码，下面为图12-4对应的代码：</p>
                <pre class="calibre7 pv pid50" id="p50">&lt;template&gt;
    &lt;Collapse v-model="value"&gt;
        &lt;Panel name="1"&gt;
            史蒂夫·乔布斯
            &lt;p slot="content"&gt;史蒂夫·乔布斯（Steve Jobs）……&lt;/p&gt;
        &lt;/Panel&gt;
        &lt;Panel name="2"&gt;
            斯蒂夫·盖瑞·沃兹尼亚克
            &lt;p slot="content"&gt;斯蒂夫·盖瑞·沃兹尼亚克（Stephen Gary Wozniak）……&lt;/p&gt;
        &lt;/Panel&gt;
        &lt;Panel name="3"&gt;
            乔纳森·伊夫
            &lt;p slot="content"&gt;乔纳森·伊夫……&lt;/p&gt;
        &lt;/Panel&gt;
    &lt;/Collapse&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                value: '1'
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid51" id="p51">在Panel中还可以嵌套Collapse，如图12-5所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid52" id="p52" style="margin: 0px;"><img alt="271"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/089c60c0c19c916b.jpg"
                                                                                                         href="./image/00045.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-5　Collapse的嵌套用法</p></div>
                <p class="calibre4 pv pid52" id="p52">
                    iView的40多个组件都是独立的UI组件，它无法像业务组件那样使用Vuex、bus等技术进行跨组件通信，因此会经常访问和操作父（子）链来修改状态及调用方法。但是在业务开发中，要尽量避免这样的操作，因为很难知道是谁修改了组件的状态，正确的做法应该是使用Vuex或bus来统一维护。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_104 pv pid53" id="p53" name="sigil_toc_id_104">
                    12.3　iView内置工具函数</h3>
                <p class="calibre4 pv pid54" id="p54">
                    iView项目中还有很多实用的工具函数，在https://github.com/iview/iview/blob/2.0/src/utils/
                    assist.js文件中。比如findComponentUpward、findComponentDownward和findComponentsDownward方法，它们用来向上或向下寻找指定name的组件，有些场景下会比上一节介绍的broadcast和dispatch方法好用，因为这3个方法直接返回的是组件实例，而不是传递数据。</p>
                <p class="calibre4 pv pid55" id="p55">
                    findComponentUpward方法以当前实例为参照点，向上寻找出指定name或几个name中的一个组件实例，找到后立即返回该实例。函数代码如下：</p>
                <pre class="calibre7 pv pid56" id="p56">function findComponentUpward (context, componentName, componentNames) {
    if (typeof componentName === 'string') {
        componentNames = [componentName];
    } else {
        componentNames = componentName;
    }

    let parent = context.$parent;
    let name = parent.$options.name;
    while (parent &amp;&amp; (!name || componentNames.indexOf(name) &lt; 0)) {
        parent = parent.$parent;
        if (parent) name = parent.$options.name;
    }
    return parent;
}</pre>
                <p class="calibre4 pv pid57" id="p57">
                    第一个参数context是上下文，即以哪个组件开始向上寻找，一般都传递this，也就是当前的实例。componentName和componentNames只需要传递一个即可，前者是字符串，后者是数组，函数开始会判断传递的类型，如果是字符串，就把它转为一个数组来使用，保证格式统一。</p>
                <p class="calibre4 pv pid58" id="p58">
                    使用while语句一层层向上级循环，直到找出指定的组件为止，寻找的依据是组件的name字段，所以在写组件时必须设置name，iView所有的组件也都有name字段。</p>
                <p class="calibre4 pv pid59" id="p59">
                    findComponentDownward和findComponentsDownward方法与findComponentUpward类似，不同的是向下寻找指定的组件，但findComponentsDownward会找到所有匹配的子组件，而findComponentDownward只会找到第一个匹配的。以下是两个函数的代码：</p>
                <pre class="calibre7 pv pid60" id="p60">// Find component downward
function findComponentDownward (context, componentName) {
    const childrens = context.$children;
    let children = null;
    if (childrens.length) {
        childrens.forEach(child =&gt; {
            const name = child.$options.name;
            if (name === componentName) {
                children = child;
            }
        });
        for (let i = 0; i &lt; childrens.length; i++) {
            const child = childrens[i];
            const name = child.$options.name;
            if (name === componentName) {
                children = child;
                break;
            } else {
                children = findComponentDownward(child, componentName);
                if (children) break;
            }
        }
    }
    return children;
}

// Find components downward
function findComponentsDownward (context, componentName, components = []) {
    const childrens = context.$children;
    if (childrens.length) {
        childrens.forEach(child =&gt; {
            const name = child.$options.name;
            const childs = child.$children;
            if (name === componentName) components.push(child);
            if (childs.length) {
                const findChilds = findComponentsDownward(child, componentName, components);
                if (findChilds) components.concat(findChilds);
            }
        });
    }
    return components;
}</pre>
                <p class="calibre4 pv pid61" id="p61">
                    iView在Radio、Checkbox、Menu等很多组件中都使用了这3个方法。如果你已经使用了iView项目，那么assist.js里所有的方法都可以使用。以这3个方法为例，在业务中可以这样导入：</p>
                <pre class="calibre7 pv pid62" id="p62">import {
    findComponentUpward,
    findComponentDownward,
    findComponentsDownward
} from 'iview/src/utils/assist';</pre>
                <p class="calibre4 pv pid63" id="p63">
                    除了工具函数外，iView内置的自定义指令、混合也可以直接使用。自定义指令所在地址为https://github.com/iview/iview/tree/2.0/src/directives，其中clickoutside.js已经在第8章中有所介绍，是用来点击外部关闭弹窗用的。transfer-dom.js用于将当前dom插入body内，iView的Modal组件中使用过，模态框（Modal）弹出时，会覆盖整个屏幕，如图12-6所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid64" id="p64" style="margin: 0px;"><img alt="273"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/d1e20ec5887ed7ec.jpg"
                                                                                                         href="./image/00046.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图12-6　iView的Modal组件</p></div>
                <p class="calibre4 pv pid64" id="p64">如果&lt;Modal&gt;&lt;/Modal&gt;所在的DOM使用了CSS定位，那么Modal的fixed定位参照会不准确，因为它相对的是当前实例所在的DOM，使用transfer-dom指令后，Modal会被移动到body内，也就是相对整个body使用fixed定位，这样避免了遮罩不完全的情况。</p>
                <p class="calibre4 pv pid65" id="p65">
                    iView同时也是一整套的前端解决方案，包含工程构建、主题定制、多语言等功能，极大地提升了开发效率。如果你的项目是面向中后台业务的，不妨试试这套UI框架，相信至少会提高一倍的开发效率。</p>
            </div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="125" data-chapter-url="24047102" alt="64157379">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第13章　实战：知乎日报项目开发</h2>
                <p class="calibre4 pv pid3" id="p3">
                    知乎日报是由知乎开发的一款资讯类阅读App，每日提供来自知乎社区精选的问答或专栏文章。本章将使用Vue和webpack等相关技术，利用知乎日报的接口开发一个Web App。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_105 pv pid4" id="p4" name="sigil_toc_id_105">13.1　分析与准备</h3>
                <p class="calibre4 pv pid5" id="p5">
                    本章将以第10章的webpack配置为基础进行开发，可以先到GitHub下载工程配置文件：https://github.com/icarusion/vue-book/tree/master/demo，将项目保存到新建的daily目录，然后完成依赖安装。本章所有的代码也上传至GitHub，访问链接可以查看并直接使用：https://github.com/icarusion/vue-book/tree/master/daily
                    。</p>
                <p class="calibre4 pv pid6" id="p6">日报是一个单页的应用，由3部分组成，如图13-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid7" id="p7" style="margin: 0px;"><img alt="276"
                                                                                                       class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                       src="./index_files/490e32755ad25001.jpg"
                                                                                                       href="./image/00047.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图13-1　日报应用效果图</p></div>
                <p class="calibre4 pv pid7" id="p7">
                    左侧是菜单，分为“每日推荐”和“主题日报”两个类型，中间是文章列表，右侧是文章正文和评论。其中每日推荐按日期排列，比如图中显示为5月2日的推荐文章，中间栏滚动至底部时，自动加载前一天的推荐内容。</p>
                <p class="calibre4 pv pid8" id="p8">
                    主题日报有“日常心理学”等10多个子分类，分类列表默认是收起的，点击“主题日报”菜单时切换展开和收起的状态。点击某个子分类后，中间栏切换为该类目下的文章列表，不再按时间排列。点击文章列表中的某一项，在右侧渲染对应文章的内容和评论。</p>
                <p class="calibre4 pv pid9" id="p9">
                    知乎日报的接口地址前缀为http://news-at.zhihu.com/api/4/，图片地址前缀为https://pic1.zhimg.com，由于两者都开启了跨域限制，无法在前端直接调用，因此要开发一个代理。</p>
                <p class="kindle-cn-para-left pv pid10" id="p10">提示</p>
                <p class="kindle-cn-para-no-indent pv pid11" id="p11" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">跨域限制是服务端的一个行为，当开启对某些域名的访问限制后，只有同域或指定域下的页面可以调用，这样相对来说更安全，图片也可以防盗链。跨域限制一般只在浏览器端存在，对于服务端或iOS、Android等客户端是不存在的。使用代理是开发过程中常见的一种解决方案。</span>
                </p>
                <p class="calibre4 pv pid11" id="p11">我们使用基于Node.js的request库来做代理，通过NPM安装request：</p>
                <pre class="calibre7 pv pid12" id="p12">npm install request --save-dev</pre>
                <p class="calibre4 pv pid13" id="p13">在daily目录下新建一个proxy.js的文件，写入以下内容（如果你不太了解Node.js，可以先直接使用）：</p>
                <pre class="calibre7 pv pid14" id="p14">const http = require('http');
const request = require('request');

const hostname = '127.0.0.1';
const port = 8010;
const imgPort = 8011;

// 创建一个API 代理服务
const apiServer = http.createServer((req, res) =&gt; {
    const url = 'http://news-at.zhihu.com/api/4' + req.url;
    const options = {
        url: url
    };

    function callback (error, response, body) {
        if (!error &amp;&amp; response.statusCode === 200) {
            // 设置编码类型，否则中文会显示为乱码
            res.setHeader('Content-Type', 'text/plain;charset=UTF-8');
            // 设置所有域允许跨域
            res.setHeader('Access-Control-Allow-Origin', '*');
            //返回代理后的内容
            res.end(body);
        }
    }
    request.get(options, callback);
});
// 监听 8010 端口
apiServer.listen(port, hostname, () =&gt; {
    console.log(`接口代理运行在http://${hostname}:${port}/`);
});
// 创建一个图片代理服务
const imgServer = http.createServer((req, res) =&gt; {
    const url = req.url.split('/img/')[1];
    const options = {
        url: url,
        encoding: null
    };

    function callback (error, response, body) {
        if (!error &amp;&amp; response.statusCode === 200) {
            const contentType = response.headers['content-type'];
            res.setHeader('Content-Type', contentType);
            res.setHeader('Access-Control-Allow-Origin', '*');
            res.end(body);
        }
    }
    request.get(options, callback);
});
// 监听8011端口
imgServer.listen(imgPort, hostname, () =&gt; {
    console.log(`图片代理运行在http://${hostname}:${imgPort}/`);
});</pre>
                <p class="calibre4 pv pid15" id="p15">
                    监听了两个端口：8010和8011。8010用于接口代理，8011用于图片代理。比如请求的真实接口为http://news-at.zhihu.com/api/4/news/3892357，开发时改写为http://127.0.0.1:8010/news/3892357；图片的真实地址为https://pic4.zhimg.com/v2-b44636ccd2affac97ccc0759a0f46f7f.jpg，开发时改写为http://127.0.0.1:8011/img/https://pic4.zhimg.com/v2-b44636ccd2affac97ccc0759a0f46f7f.jpg。</p>
                <p class="calibre4 pv pid16" id="p16">代理的核心是在返回的头部（response
                    header）中添加一项Access-Control-Allow-Origin为“*”，也就是允许所有的域访问。</p>
                <p class="calibre4 pv pid17" id="p17">最后在终端使用Node启动代理服务：</p>
                <pre class="calibre7 pv pid18" id="p18">node proxy.js</pre>
                <p class="calibre4 pv pid19" id="p19">如果成功，就会在终端显示两行日志：</p>
                <p class="calibre4 pv pid20" id="p20">接口代理运行在http://127.0.0.1:8010/</p>
                <p class="calibre4 pv pid21" id="p21">图片代理运行在http://127.0.0.1:8011/</p>
                <p class="calibre4 pv pid22" id="p22">
                    对于接口的Ajax请求，前端有很多实现方案，比如jQuery的$.ajax，但是只为使用Ajax而引入一个jQuery显然不太友好。如果你完成了11.3章节的练习题，可以用做好的Vue插件通过this.$ajax直接请求。Vue官方也提供了vue-resource插件，但是不再维护，而是推荐使用axios，所以本章示例也基于axios来做异步请求。</p>
                <p class="calibre4 pv pid23" id="p23">axios是基于Promise的HTTP库，同时支持前端和Node.js。首先用NPM安装axios：</p>
                <pre class="calibre7 pv pid24" id="p24">npm install axios --save</pre>
                <p class="calibre4 pv pid25" id="p25">
                    在daily目录下新建目录libs，并在libs下新建util.js文件，项目中使用的工具函数可以在这里封装。比如对axios封装，写入请求地址的前缀，在业务中只用写相对路径，这样可以灵活控制。另外，可以全局拦截axios返回的内容，简单处理，只需返回我们需要的数据。其代码如下：</p>
                <pre class="calibre7 pv pid26" id="p26">// util.js
import axios from 'axios';
// 基本配置
const Util = {
    imgPath: 'http://127.0.0.1:8011/img/',
    apiPath: 'http://127.0.0.1:8010/'
};
// Ajax 通用配置
Util.ajax = axios.create({
    baseURL: Util.apiPath
});
//添加响应拦截器
Util.ajax.interceptors.response.use(res =&gt; {
    return res.data;
});

export default Util;</pre>
                <p class="calibre4 pv pid27" id="p27">更多关于axios的使用可以查阅官方文档：https://github.com/mzabriskie/axios。</p>
                <p class="calibre4 pv pid28" id="p28">做好这些准备后，就可以开始日报应用的开发了。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_106 pv pid29" id="p29" name="sigil_toc_id_106">
                    13.2　推荐列表与分类</h3><h4 class="kindle-cn-heading3 sigil_toc_id_107 pv pid30" id="p30"
                                         name="sigil_toc_id_107">13.2.1　搭建基本结构</h4>
                <p class="calibre4 pv pid31" id="p31">项目中使用的CSS样式不多，所以直接写在daily/style.css，并在main.js中导入：</p>
                <pre class="calibre7 pv pid32" id="p32">// main.js
import Vue from 'vue';
import App from './app.vue';
import './style.css';

new Vue({
    el: '#app',
    render: h =&gt; {
        return h(App)
    }
});</pre>
                <p class="calibre4 pv pid33" id="p33">日报是单页应用，没有路由，只有一个入口组件app.vue。应用结构如图13-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid34" id="p34" style="margin: 0px;"><img alt="279"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/b56d507b3504bce1.jpg"
                                                                                                         href="./image/00048.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图13-2　日报应用结构</p></div>
                <p class="calibre4 pv pid34" id="p34">应用分左、中、右3栏，3栏都可以滚动。对左栏和中栏使用fixed固定，并使用overflow:
                    auto滚动，而右栏高度自适应，使用浏览器默认的body区域滚动即可。基本的HTML和CSS结构如下：</p>
                <pre class="calibre7 pv pid35" id="p35">// app.vue
&lt;template&gt;
    &lt;div class="daily"&gt;
        &lt;div class="daily-menu"&gt;
            &lt;div class="daily-menu-item"&gt;每日推荐&lt;/div&gt;
            &lt;div class="daily-menu-item"&gt;主题日报&lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="daily-list"&gt;
            &lt;Item&gt;&lt;/Item&gt;
        &lt;/div&gt;
        &lt;daily-article&gt;&lt;/daily-article&gt;
    &lt;/div&gt;
&lt;/template&gt;

// style.css
html, body{
    margin: 0;
    padding: 0;
    height: 100%;
    color: #657180;
    font-size: 16px;
}
.daily-menu{
    width: 150px;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    overflow: auto;
    background: #f5f7f9;
}
.daily-menu-item{
    font-size: 18px;
    text-align: center;
    margin: 5px 0;
    padding: 10px 0;
    cursor: pointer;
    border-right: 2px solid transparent;
    transition: all .3s ease-in-out;
}
.daily-menu-item:hover{
    background: #e3e8ee;
}
.daily-menu-item.on{
    border-right: 2px solid #3399ff;
}

.daily-list{
    width: 300px;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 150px;
    overflow: auto;
    border-right: 1px solid #d7dde4;
}
.daily-item{
    display: block;
    color: inherit;
    text-decoration: none;
    padding: 16px;
    overflow: hidden;
    cursor: pointer;
    transition: all .3s ease-in-out;
}
.daily-item:hover{
    background: #e3e8ee;
}

.daily-article{
    margin-left: 450px;
    padding: 20px;
}</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_108 pv pid36" id="p36" name="sigil_toc_id_108">
                    13.2.2　主题日报</h4>
                <p class="calibre4 pv pid37" id="p37">
                    “主题日报”下有子类列表，默认是收起的，点击主题日报可以切换展开和收起的状态，使用数据showThemes来控制，并用themes来循环渲染子类目：</p>
                <pre class="calibre7 pv pid38" id="p38">// app.vue，部分代码省略
&lt;template&gt;
    &lt;div class="daily-menu"&gt;
        &lt;div class="daily-menu-item"
             :class="{ on: type === 'recommend' }"&gt;每日推荐&lt;/div&gt;
        &lt;div class="daily-menu-item"
             :class="{ on: type === 'daily' }"
             @click="showThemes = !showThemes"&gt;主题日报&lt;/div&gt;
        &lt;ul v-show="showThemes"&gt;
            &lt;li v-for="item in themes"&gt;
                &lt;a :class="{ on: item.id === themeId &amp;&amp; type === 'daily' }"&gt;{{ item.name }}&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                themes: [],
                showThemes: false,
                type: 'recommend',
                themeId: 0
            }
        },
    }
&lt;/script&gt;
// style.css
.daily-menu ul{
    list-style: none;
}
.daily-menu ul li a{
    display: block;
    color: inherit;
    text-decoration: none;
    padding: 5px 0;
    margin: 5px 0;
    cursor: pointer;
}
.daily-menu ul li a:hover, .daily-menu ul li a.on{
    color: #3399ff;
}</pre>
                <p class="calibre4 pv pid39" id="p39">themeId会在点击子类时设置，稍后会介绍。</p>
                <p class="calibre4 pv pid40" id="p40">应用初始化时，获取主题日报的分类列表：</p>
                <pre class="calibre7 pv pid41" id="p41">// app.vue，部分代码省略
&lt;script&gt;
    import $ from './libs/util';
    export default {
        data () {
            return {
                themes: []
            }
        },
        methods: {
            getThemes () {
                // axios 发起get请求
                $.ajax.get('themes').then(res =&gt; {
                    this.themes = res.others;
                })
            }
        },
        mounted () {
            // 初始化时调用
            this.getThemes();
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid42" id="p42">主题日报类目列表为数组，每一项的结构示例如下：</p>
                <pre class="calibre7 pv pid43" id="p43">"others": [
    {
        "name": "日常心理学",
        "id": 13,
        "thumbnail": "http://pic3.zhimg.com/xxx.jpg",
        "color": 15007,
        "description": "了解自己和别人，了解彼此的欲望和局限。"
    }
]</pre>
                <p class="calibre4 pv pid44" id="p44">点击子类目时，将菜单type切换为“主题日报”高亮点击的子类，然后加载该类目下的文章列表：</p>
                <pre class="calibre7 pv pid45" id="p45">// app.vue，部分代码省略
&lt;template&gt;
    &lt;ul v-show="showThemes"&gt;
        &lt;li v-for="item in themes"&gt;
            &lt;a
                :class="{ on: item.id === themeId &amp;&amp; type === 'daily' }"
                @click="handleToTheme(item.id)"&gt;{{ item.name }}&lt;/a&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/template&gt;
&lt;script&gt;
    import $ from './libs/util';
    export default {
        data () {
            return {
                themes: [],
                showThemes: false,
                type: 'recommend',
                list: [],
                themeId: 0
            }
        },
        methods: {
            handleToTheme (id) {
                // 改变菜单分类
                this.type = 'daily';
                // 设置当前点击子类的主题日报id
                this.themeId = id;
                // 清空中间栏的数据
                this.list = [];
                $.ajax.get('theme/' + id).then(res =&gt; {
                    // 过滤掉类型为1的文章，该类型下的文章为空
                    this.list = res.stories
                        .filter(item =&gt; item.type !== 1);
                })
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid46" id="p46">文章列表list为数组，每一项的结构示例如下：</p>
                <pre class="calibre7 pv pid47" id="p47">"stories": [
    {
        "type": 0,
        "id": 7097426,
        "title": "人们在虚拟生活中投入的精力是否对现实生活的人际关系有积极意义？"
    },
    {
        "type": 0,
        "id": 7101963,
        "title": "写给想成为心理咨询师的学生同仁",
        "images": [
            "http://pic1.zhimg.com/xxx.jpg"
        ]
    }
]</pre>
                <p class="calibre4 pv pid48" id="p48">
                    文章列表中的id字段是文章的id，请求文章内容和评论列表时会用到，title为标题，images为封面图片，没有images字段就不显示封面图片。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_109 pv pid49" id="p49" name="sigil_toc_id_109">
                    13.2.3　每日推荐</h4>
                <p class="calibre4 pv pid50" id="p50">
                    应用初始化和点击“每日推荐”菜单时请求推荐的文章列表。推荐列表的API相对地址为news/before/20170503，before后面是查询的日期，这个日期比要查询的真实日期多一天，比如要查2017年5月2日推荐的内容，就要请求20170503。每日推荐可以无限次地向前一天查询，为方便操作日期，在libs/util.js内定义两个时间方法：</p>
                <pre class="calibre7 pv pid51" id="p51">// libs/util.js，部分代码省略
import axios from 'axios';
const Util = {

};

// 获取今天的时间戳
Util.getTodayTime = function () {
    const date = new Date();
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    return date.getTime();
};
// 获取前一天的日期
Util.prevDay = function (timestamp = (new Date()).getTime()) {
    const date = new Date(timestamp);
    const year = date.getFullYear();
    const month = date.getMonth() + 1 &lt; 10
        ? '0' + (date.getMonth() + 1)
        : date.getMonth() + 1;
    const day = date.getDate() &lt; 10
        ? '0' + date.getDate()
        : date.getDate();
    return year + '' + month + '' + day;
};
export default Util;</pre>
                <p class="calibre4 pv pid52" id="p52">
                    Util.prevDay的参数为前一天的时间戳，计算前一天的时间戳只需以今天0点的时间戳为基础，也就是通过Util.getTodayTime获取的时间戳减去86400000（24*60*60*1000）。这种方法要比直接判断前一天的日期简单得多，因为每个月的日期是不固定的，另外还需特殊处理润年。</p>
                <p class="calibre4 pv pid53" id="p53">推荐文章的列表获取的相关代码如下：</p>
                <pre class="calibre7 pv pid54" id="p54">// app.vue，部分代码省略
&lt;template&gt;
    &lt;div class="daily-menu-item"
         @click="handleToRecommend"
         :class="{ on: type === 'recommend' }"&gt;每日推荐&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import $ from './libs/util';
    export default {
        data () {
            return {
                type: 'recommend',
                recommendList: [],
                dailyTime: $.getTodayTime(),
                isLoading: false
            }
        },
        methods: {
            handleToRecommend () {
                this.type = 'recommend';
                this.recommendList = [];
                this.dailyTime = $.getTodayTime();
                this.getRecommendList();
            },
            getRecommendList () {
                this.isLoading = true;
                const prevDay = $.prevDay(this.dailyTime + 86400000);
                $.ajax.get('news/before/' + prevDay).then(res =&gt; {
                    this.recommendList.push(res);
                    this.isLoading = false;
                })
            }
        },
        mounted () {
            this.getRecommendList();
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid55" id="p55">
                    recommendList为推荐文章列表的数据，在初始化和每次点击“每日推荐”菜单时都会请求数据。dailyTime默认获取今天0点的时间戳，请求时需要多加一天。因为推荐列表可能通过“主题日报”的子类切换而来，需要重新获取一遍数据，所以handleToRecommend方法每次都需要清空列表并重新设置
                    dailyTime。</p>
                <p class="calibre4 pv pid56" id="p56">推荐列表的数据结构和主题日报基本一致，不同的是多了一个date字段来表示请求列表的日期，比如：</p>
                <pre class="calibre7 pv pid57" id="p57">{
    "date": "20170502",
    "stories": [
        {
            "id": 9394848,
            "title": "在庞大的体系中像齿轮一样工作，如何避免“去能力化”？",
            "images": [
                "https://pic4.zhimg.com/xxx.jpg"
            ],
            "ga_prefix": "050220",
            "type": 0
        }
    ]
}</pre>
                <p class="calibre4 pv pid58" id="p58">
                    两个文章列表（list、recommendList）的每项都用一个组件item.vue来展示，在daily/components目录下新建item.vue文件，并写入以下内容：</p>
                <pre class="calibre7 pv pid59" id="p59">// components/item.vue
&lt;template&gt;
    &lt;a class="daily-item"&gt;
        &lt;div class="daily-img" v-if="data.images"&gt;
            &lt;img :src="imgPath + data.images[0]"&gt;
        &lt;/div&gt;
        &lt;div
            class="daily-title"
            :class="{ noImg: !data.images}"&gt;{{ data.title }}&lt;/div&gt;
    &lt;/a&gt;
&lt;/template&gt;
&lt;script&gt;
    import $ from '../libs/util';
    export default {
        props: {
            data: {
                type: Object
            }
        },
        data () {
            return {
                imgPath: $.imgPath
            }
        }
    }
&lt;/script&gt;
// style.css
.daily-item{
    display: block;
    color: inherit;
    text-decoration: none;
    padding: 16px;
    overflow: hidden;
    cursor: pointer;
    transition: all .3s ease-in-out;
}
.daily-item:hover{
    background: #e3e8ee;
}
.daily-img{
    width: 80px;
    height: 80px;
    float: left;
}
.daily-img img{
    width: 100%;
    height: 100%;
    border-radius: 3px;
}
.daily-title{
    padding: 10px 5px 10px 90px;
}
.daily-title.noImg{
    padding-left: 5px;
}</pre>
                <p class="calibre4 pv pid60" id="p60">prop：data里可能没有images 字段，所以列表会显示两种模式，即含封面图和不含封面图。</p>
                <p class="calibre4 pv pid61" id="p61">
                    Item组件会用到文章列表里，type为recommend和daily两种类型下，渲染会稍有不同。recommend会显示每天的日期，daily则没有，两者效果如图13-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid62" id="p62" style="margin: 0px;"><img alt="289"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/dba34d556945245f.jpg"
                                                                                                         href="./image/00049.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图13-3　两种类型的文章列表对比</p></div>
                <p class="calibre4 pv pid62" id="p62">对应的代码如下：</p>
                <pre class="calibre7 pv pid63" id="p63">// app.vue，部分代码省略
&lt;template&gt;
    &lt;div class="daily-list"&gt;
        &lt;template v-if="type === 'recommend'"&gt;
            &lt;div v-for="list in recommendList"&gt;
                &lt;div class="daily-date"&gt;{{ formatDay(list.date) }}&lt;/div&gt;
                &lt;Item
                    v-for="item in list.stories"
                    :data="item"
                    :key="item.id"&gt;&lt;/Item&gt;
            &lt;/div&gt;
        &lt;/template&gt;
        &lt;template v-if="type === 'daily'"&gt;
            &lt;Item
                v-for="item in list"
                :data="item"
                :key="item.id"&gt;&lt;/Item&gt;
        &lt;/template&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Item from './components/item.vue';
    export default {
        components: { Item },
        data () {
            return {
                type: 'recommend',
                recommendList: [],
                list: []
            }
        },
        methods: {
            // 转换为带汉字的月日
            formatDay (date) {
                let month = date.substr(4, 2);
                let day = date.substr(6, 2);
                if (month.substr(0, 1) === '0') month = month.substr(1, 1);
                if (day.substr(0, 1) === '0') day = day.substr(1, 1);
                return `${month} 月 ${day} 日`;
            }
        }
    }
&lt;/script&gt;
// style.css
.daily-list{
    width: 300px;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 150px;
    overflow: auto;
    border-right: 1px solid #d7dde4;
}
.daily-date{
    text-align: center;
    margin: 10px 0;
}</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_110 pv pid64" id="p64" name="sigil_toc_id_110">
                    13.2.4　自动加载更多推荐列表</h4>
                <p class="calibre4 pv pid65" id="p65">
                    在“每日推荐”类型下，中栏的文章列表滚动到底部会自动加载前一天的推荐列表，所以要监听中栏（.daily-list）的滚动事件，并在合适的时机触发加载请求：</p>
                <pre class="calibre7 pv pid66" id="p66">// app.vue，部分代码省略
&lt;template&gt;
    &lt;div class="daily-list" ref="list"&gt;

    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                isLoading: false
            }
        },
        methods: {
            getRecommendList () {
                // 加载时设置为true，加载完成后置为false
                this.isLoading = true;
                const prevDay = $.prevDay(this.dailyTime + 86400000);
                $.ajax.get('news/before/' + prevDay).then(res =&gt; {
                    this.recommendList.push(res);
                    this.isLoading = false;
                })
            }
        },
        mounted () {
            this.getRecommendList();
            // 获取到DOM
            const $list = this.$refs.list;
            // 监听中栏的滚动事件
            $list.addEventListener('scroll', () =&gt; {
                //在“主题日报”或正在加载推荐列表时停止操作
                if (this.type === 'daily' || this.isLoading) return;
                // 已经滚动的距离加页面的高度等于整个内容区域高度时，视为接触底部
                if
                (
                    $list.scrollTop
                    + document.body.clientHeight
                    &gt;= $list.scrollHeight
                )
                {
                    //时间相对减少一天
                    this.dailyTime -= 86400000;
                    this.getRecommendList();
                }
            });
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid67" id="p67">$list（.daily-list）的CSS 使用了overflow:
                    auto，所以它具备滚动的能力，进而可以监听滚动事件。直接操作DOM在Vue中很少见，但示例的场景和一些对window、document对象监听事件的场景还是有的，使用监听时要注意在beforeDestroy
                    生命周期使用removeEventListener 移除，本例是单页应用，所以不需此操作。$list的scroll是标准 DOM事件，所以也可以用Vue的v-on指令，比如上例也可以改写为：</p>
                <pre class="calibre7 pv pid68" id="p68">&lt;template&gt;
    &lt;div
        class="daily-list"
        ref="list"
        @scroll="handleScroll"&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            handleScroll () {
                const $list = this.$refs.list;
                if (this.type === 'daily' || this.isLoading) return;
                if
                (
                    $list.scrollTop
                    + document.body.clientHeight
                    &gt;= $list.scrollHeight
                )
                {
                    this.dailyTime -= 86400000;
                    this.getRecommendList();
                }
            }
        }
    }
&lt;/script&gt;</pre>
                <h3 class="kindle-cn-heading2 sigil_toc_id_111 pv pid69" id="p69" name="sigil_toc_id_111">
                    13.3　文章详情页</h3><h4 class="kindle-cn-heading3 sigil_toc_id_112 pv pid70" id="p70"
                                       name="sigil_toc_id_112">13.3.1　加载内容</h4>
                <p class="calibre4 pv pid71" id="p71">
                    右侧的文章内容区域封装成了一个组件。在components目录下新建daily-article.vue组件，它接收唯一的一个prop：id，也就是文章的id，如果
                    id变化了，就说明切换了文章，需要请求新的文章内容。</p>
                <p class="calibre4 pv pid72" id="p72">在app.vue中导入daily-article.vue组件，并在文章列表的Item组件上绑定查看文章事件：</p>
                <pre class="calibre7 pv pid73" id="p73">// app.vue，部分代码省略和简写
&lt;template&gt;
    &lt;div class="daily"&gt;
        &lt;Item @click.native="handleClick(item.id)"&gt;&lt;/Item&gt;
        &lt;daily-article :id="articleId"&gt;&lt;/daily-article&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Item from './components/item.vue';
    import dailyArticle from './components/daily-article.vue';

    export default {
        components: { Item, dailyArticle },
        data () {
            return {
                articleId: 0
            }
        },
        methods: {
            handleClick (id) {
                this.articleId = id;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid74" id="p74">Item是组件，绑定原生事件时要带事件修饰符.native，否则会认为监听的是来自Item组件的自定义事件click。</p>
                <p class="calibre4 pv pid75" id="p75">dailyArticle组件在监听到id 改变时请求文章内容：</p>
                <pre class="calibre7 pv pid76" id="p76">// components/daily-article.vue
&lt;template&gt;
    &lt;div class="daily-article"&gt;
        &lt;div class="daily-article-title"&gt;{{ data.title }}&lt;/div&gt;
        &lt;div class="daily-article-content" v-html="data.body"&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import $ from '../libs/util';
    export default {
        props: {
            id: {
                type: Number,
                default: 0
            }
        },
        data () {
            return {
                data: {}
            }
        },
        methods: {
            getArticle () {
                $.ajax.get('news/' + this.id).then(res =&gt; {
                    //将文章的中的图片地址替换为代理的地址
                    res.body = res.body
                        .replace(/src="http/g, 'src="' + $.imgPath + 'http');
                    res.body = res.body
                        .replace(/src="https/g, 'src="' + $.imgPath + 'https');
                    this.data = res;
                    //返回文章顶端
                    window.scrollTo(0, 0);
                })
            }
        },
        watch: {
            id (val) {
                if (val) this.getArticle();
            }
        }
    };
&lt;/script&gt;
// style.css
.daily-article{
    margin-left: 450px;
    padding: 20px;
}
.daily-article-title{
    font-size: 28px;
    font-weight: bold;
    color: #222;
    padding: 10px 0;
}
.view-more a{
    display: block;
    cursor: pointer;
    background: #f5f7f9;
    text-align: center;
    color: inherit;
    text-decoration: none;
    padding: 4px 0;
    border-radius: 3px;
}</pre>
                <p class="calibre4 pv pid77" id="p77">数据的data结构为：</p>
                <pre class="calibre7 pv pid78" id="p78">{
    "title": "这茶，明显是用了梅雨期的雨水，我还是喜欢用腊月的雪水",
    "body": "文章内容，格式为html",
    "id": 9395306,
    "type": 0,
    "image": "https://pic3.zhimg.com/v2-dbf5d6e5eeeccaacc67af4d625e0699a.jpg",
    "image_source": "T.Tseng / CC BY",
    "images": [
        "https://pic4.zhimg.com/v2-5cb4fcbd56bb6717969e9967829929b7.jpg"
    ],
    "share_url": "http://daily.zhihu.com/story/9395306",
    "ga_prefix": "050311",
    "js": [],
    "css": [
        "http://news-at.zhihu.com/css/news_qa.auto.css?v=4b3e3"
    ]
}</pre>
                <p class="calibre4 pv pid79" id="p79">
                    这里只用到了title和body，其中body的格式为html，需要用v-html指令直接显示。用户可能会在某篇文章阅读到一定位置时切换了别的文章，这时文章的滚动条仍停留在上次浏览的位置，使用window.scrollTo(0,
                    0)可以返回页面的顶端。需要注意的是，.daily-article并没有使用overflow:
                    auto滚动，而是自然高度，所以这里是让页面返回顶端，而不能设置.daily-article的scrollTop为0。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_113 pv pid80" id="p80" name="sigil_toc_id_113">
                    13.3.2　加载评论</h4>
                <p class="calibre4 pv pid81" id="p81">每篇文章底部要加载评论，效果如图13-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid82" id="p82" style="margin: 0px;"><img alt="296"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/cab4c1d8693bc7d2.jpg"
                                                                                                         href="./image/00050.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图13-4　评论列表</p></div>
                <p class="calibre4 pv pid82" id="p82">评论的数据结构为：</p>
                <pre class="calibre7 pv pid83" id="p83">"comments": [
    {
        "author": "滕正云",
        "content": "善泳者溺于水 佩服于极限运动者的勇气 但我想这应该是小圈子内的英雄",
        "avatar": "http://pic1.zhimg.com/xxx.jpg",
        "time": 1493788345,
        "id": 28885287,
        "likes": 0
    }
]</pre>
                <p class="calibre4 pv pid84" id="p84">
                    每条评论要显示发表时间，源数据格式为时间戳，需要前端转为相对时间。在第8章自定义指令的8.2.2小节实现了一个v-time的自定义指令，用于时间戳转换，可以直接使用，但是要修改为ES6
                    Module语法导出模块。在daily目录下创建directives目录，并创建time.js文件，写入以下内容：</p>
                <pre class="calibre7 pv pid85" id="p85">// directives/time.js
var Time = {
    // 获取当前时间戳
    getUnix: function () {
        var date = new Date();
        return date.getTime();
    },
    // 获取今天0点0分0秒的时间戳
    getTodayUnix: function () {
        var date = new Date();
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date.getTime();
    },
    // 获取今年1月1日0点0分0秒的时间戳
    getYearUnix: function () {
        var date = new Date();
        date.setMonth(0);
        date.setDate(1);
        date.setHours(0);
        date.setMinutes(0);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date.getTime();
    },
    // 获取标准年月日
    getLastDate: function(time) {
        var date = new Date(time);
        var month = date.getMonth() + 1 &lt; 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1;
        var day = date.getDate() &lt; 10 ? '0' + date.getDate() : date.getDate();
        return date.getFullYear() + '-' + month + "-" + day;
    },
    // 转换时间
    getFormatTime: function(timestamp) {
        var now = this.getUnix();    //当前时间戳
        var today = this.getTodayUnix(); //今天0点时间戳
        var year = this.getYearUnix();   //今年0点时间戳
        var timer = (now - timestamp) / 1000;   // 转换为秒级时间戳
        var tip = '';

        if (timer &lt;= 0) {
            tip = '刚刚';
        } else if (Math.floor(timer/60) &lt;= 0) {
            tip = '刚刚';
        } else if (timer &lt; 3600) {
            tip = Math.floor(timer/60) + '分钟前';
        } else if (timer &gt;= 3600 &amp;&amp; (timestamp - today &gt;= 0) ) {
            tip = Math.floor(timer/3600) + '小时前';
        } else if (timer/86400 &lt;= 31) {
            tip = Math.ceil(timer/86400) + '天前';
        } else {
            tip = this.getLastDate(timestamp);
        }
        return tip;
    }
};

export default {
    bind: function (el, binding) {
        el.innerHTML = Time.getFormatTime(binding.value * 1000);
        el.__timeout__ = setInterval(function() {
            el.innerHTML = Time.getFormatTime(binding.value * 1000);
        }, 60000);
    },
    unbind: function (el) {
        clearInterval(el.__timeout__);
        delete el.__timeout__;
    }
}</pre>
                <p class="calibre4 pv pid86" id="p86">关于自定义指令和v-time的详细介绍，可以回顾8.2.2小节的内容。</p>
                <p class="calibre4 pv pid87" id="p87">评论列表在获取完文章内容后再获取，代码如下：</p>
                <pre class="calibre7 pv pid88" id="p88">// components/daily-article.vue，部分代码省略
&lt;template&gt;
    &lt;div class="daily-article"&gt;
        &lt;div class="daily-article-title"&gt;{{ data.title }}&lt;/div&gt;
        &lt;div class="daily-article-content" v-html="data.body"&gt;&lt;/div&gt;

        &lt;div class="daily-comments" v-show="comments.length"&gt;
            &lt;span&gt;评论（{{ comments.length }}）&lt;/span&gt;
            &lt;div class="daily-comment" v-for="comment in comments"&gt;
                &lt;div class="daily-comment-avatar"&gt;
                    &lt;img :src="comment.avatar"&gt;
                &lt;/div&gt;
                &lt;div class="daily-comment-content"&gt;
                    &lt;div class="daily-comment-name"&gt;{{ comment.author }}&lt;/div&gt;
                    &lt;div class="daily-comment-time" v-time="comment.time"&gt;&lt;/div&gt;
                    &lt;div class="daily-comment-text"&gt;{{ comment.content }}&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Time from '../directives/time';
    import $ from '../libs/util';
    export default {
        directives: { Time },
        props: {
            id: {
                type: Number,
                default: 0
            }
        },
        data () {
            return {
                data: {},
                comments: []
            }
        },
        methods: {
            getArticle () {
                $.ajax.get('news/' + this.id).then(res =&gt; {
                    // ...
                    this.getComments();
                })
            },
            getComments () {
                this.comments = [];
                $.ajax.get('story/' + this.id + '/short-comments').then(res =&gt; {
                    this.comments = res.comments.map(comment =&gt; {
                        //将头像的图片地址转为代理地址
                        comment.avatar = $.imgPath + comment.avatar;
                        return comment;
                    });
                })
            }
        }
    };
&lt;/script&gt;

// style.css
.daily-comments{
    margin: 10px 0;
}
.daily-comments span{
    display: block;
    margin: 10px 0;
    font-size: 20px;
}
.daily-comment{
    overflow: hidden;
    margin-bottom: 20px;
    padding-bottom: 20px;
    border-bottom: 1px dashed #e3e8ee;
}
.daily-comment-avatar{
    width: 50px;
    height: 50px;
    float: left;
}
.daily-comment-avatar img{
    width: 100%;
    height: 100%;
    border-radius: 3px;
}
.daily-comment-content{
    margin-left: 65px;
}
.daily-comment-name{

}
.daily-comment-time{
    color: #9ea7b4;
    font-size: 14px;
    margin-top: 5px;
}
.daily-comment-text{
    margin-top: 10px;
}</pre>
                <p class="calibre4 pv pid89" id="p89">以上就是日报项目的所有细节分析和代码。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_114 pv pid90" id="p90" name="sigil_toc_id_114">13.4　总结</h3>
                <p class="calibre4 pv pid91" id="p91">本章所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid92" id="p92">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid93" id="p93">vue-book下的daily目录就是本章的代码，在该目录下执行npm install命令会自动安装所有的依赖，然后执行npm
                    run dev启动webpack服务，执行node proxy.js启动代理服务。</p>
                <p class="calibre4 pv pid94" id="p94">日报项目以单页面的形式呈现，基本覆盖了Vue和webpack的核心功能，它们包括：</p>
                <ul class="kindle-cn-ul-disc pv pid95" id="p95" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">Vue的单文件组件用法。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">Vue的基本指令、自定义指令。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">数据的获取、整理、可视化。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">prop、事件、子组件索引。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">ES6模块。</span></li>
                </ul>
                <p class="calibre4 pv pid95" id="p95">
                    日报项目是一个较独立的单页小应用，没有使用路由和大规模状态管理插件Vuex，在工程上并不算复杂，比较适合刚入手Vue的练习项目。虽然看似简单，但它覆盖了业务中很多场景，对代码进行了组织和模块化，很接近真实的生产项目。项目对代码维护和扩展性也有考虑，比如对Ajax的封装、通用工具函数的提取、组件的解耦等，这些细节都是在实际项目中要考虑的。</p>
                <p class="calibre4 pv pid96" id="p96" style="margin: 0px;"><span class="kindle-cn-bold">练习：</span>参考知乎日报移动App的UI设计，基于本章内容开发移动Web版。
                </p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="136" data-chapter-url="24047103" alt="64157390">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第14章　实战：电商网站项目开发</h2>
                <p class="calibre4 pv pid3" id="p3">
                    本章将结合本书所有的知识点（包括webpack、Vuex、vue-router等）来开发一个具有代表性的电商网站项目。所涉及的内容涵盖了许多典型场景，如商品列表按照价格、销量排序；商品列表按照品牌、价格过滤；动态的购物车；使用优惠码等。</p>
                <p class="calibre4 pv pid4" id="p4">
                    本章仍然会使用前面章节的基本webpack配置，所有的代码也上传至GitHub，访问链接可以查看并直接使用：https://github.com/icarusion/vue-book/tree/master/shopping。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_115 pv pid5" id="p5" name="sigil_toc_id_115">14.1　项目工程搭建</h3>
                <p class="calibre4 pv pid6" id="p6">
                    新建目录shopping，复制第10.2节的webpack开发环境和生产环境的两个配置文件（webpack.config.js、webpack.prod.config.js）及package.json等核心文件，并通过NPM完成安装。项目的主要配置在于main.js文件。</p>
                <p class="calibre4 pv pid7" id="p7">本章会使用到Vue.js的路由插件vue-router和状态管理插件Vuex，首先在main.js中导入并做初始化配置：</p>
                <pre class="calibre7 pv pid8" id="p8">// main.js
import Vue from 'vue';
import VueRouter from 'vue-router';
import Routers from './router.js';
import Vuex from 'vuex';
import App from './app.vue';
import './style.css';

Vue.use(VueRouter);
Vue.use(Vuex);

// 路由配置
const RouterConfig = {
    // 使用HTML 5的History 路由模式
    mode: 'history',
    routes: Routers
};
const router = new VueRouter(RouterConfig);

router.beforeEach((to, from, next) =&gt; {
    window.document.title = to.meta.title;
    next();
});

router.afterEach((to, from, next) =&gt; {
    window.scrollTo(0, 0);
});

const store = new Vuex.Store({
    state: {

    },
    getters: {

    },
    mutations: {

    },
    actions: {

    }
});

new Vue({
    el: '#app',
    router: router,
    store: store,
    render: h =&gt; {
        return h(App)
    }
});</pre>
                <p class="calibre4 pv pid9" id="p9">
                    其中，路由的页面配置放在了router.js文件内单独维护；Vuex默认设置了state、getters、mutations、actions，之后随项目需求持续添加。</p>
                <p class="calibre4 pv pid10" id="p10">
                    项目中全局使用的一些CSS样式写在了style.css文件内，在main.js中直接导入，webpack打包时，会将此CSS文件与.vue单文件中的CSS（包括scoped）一同提取，输出到main.css文件。</p>
                <p class="calibre4 pv pid11" id="p11">
                    在shopping目录下新建views目录，用于放置每个路由页面的.vue文件；新建components目录用来存放公共组件；新建images目录用来存放项目中用到的图片。配置完这些后，通过NPM运行npm
                    run dev命令，启动webpack服务，这样就完成了基础工程的搭建。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_116 pv pid12" id="p12" name="sigil_toc_id_116">
                    14.2　商品列表页</h3><h4 class="kindle-cn-heading3 sigil_toc_id_117 pv pid13" id="p13"
                                       name="sigil_toc_id_117">14.2.1　需求分析与模块拆分</h4>
                <p class="calibre4 pv pid14" id="p14">
                    商品列表页面用于展示相关的所有商品，一般具有筛选和排序两种过滤方法。比如可以按照品牌筛选（如Apple、Beats、Bose）或颜色筛选（如白色、金色），筛选条件可以叠加（比如白色的Beats品牌）。可以按照价格、销量等在筛选的基础上再进行排序，最终过滤出符合要求的商品。</p>
                <p class="calibre4 pv pid15" id="p15">最终完成的效果如图14-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid16" id="p16" style="margin: 0px;"><img alt="304"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/eeb6364653569090.jpg"
                                                                                                         href="./image/00051.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图14-1　商品列表页效果图</p></div>
                <p class="calibre4 pv pid16" id="p16">排序为单选，初始按“默认”进行排序，其中价格可分为升序（价格从低到高）和降序（价格从高到低）两种排序，销量则只有降序。</p>
                <p class="calibre4 pv pid17" id="p17">品牌和颜色都是单选，单次点击选中，再次点击取消选中。</p>
                <p class="calibre4 pv pid18" id="p18">
                    初次打开商品列表页会请求一次远程数据（示例用setTimeout模拟异步，真实场景应该通过Ajax获取），获取到全量的商品数据，然后筛选和排序都是在本地完成（真实场景也有在服务端进行筛选和排序的做法，因为商品很有可能会分页，前端一次性拿到所有数据不现实）。</p>
                <p class="calibre4 pv pid19" id="p19">
                    商品列表页主要有两个模块，一个是路由组件（views/list.vue），负责数据的请求、过滤相关的逻辑；另一个是商品简介组件（components/product.vue，即每个商品卡片），鼠标经过时，显示出加入购物车的按钮，如图14-2所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid20" id="p20" style="margin: 0px;"><img alt="305"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/1dc5ad0752df88b1.jpg"
                                                                                                         href="./image/00052.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图14-2　商品简介组件示意图</p></div>
                <p class="calibre4 pv pid20" id="p20">两个模块的样式都直接写在各自的.vue文件的&lt;style scoped&gt; 部分。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_118 pv pid21" id="p21" name="sigil_toc_id_118">
                    14.2.2　商品简介组件</h4>
                <p class="calibre4 pv pid22" id="p22">
                    上一节中，图14-2已经展示了商品简介组件的效果，本节将完成该组件的开发。在components目录下新建product.vue文件。每个商品的选项比较多，比如标题、价格、颜色等，为方便父子组件之间传递，直接在product.vue中设置一个property：info来接收一个对象格式的数据，这样扩展性较高，父级也可直接将获取到的数据传递过来，省去了拆分的工作。</p>
                <p class="calibre4 pv pid23" id="p23">info数据结构如下：</p>
                <pre class="calibre7 pv pid24" id="p24">// info
{
    id: 1,
    name: 'AirPods',
    brand: 'Apple',
    image: 'http://ordfm6aah.bkt.clouddn.com/shop/1.jpeg',
    sales: 10000,
    cost: 1288,
    color: '白色'
}</pre>
                <p class="calibre4 pv pid25" id="p25">
                    其中，id是商品的id，点击卡片会进入该商品的详情页面，后面章节会陆续介绍。name是商品名称，brand为品牌，image是图片，sales是销量，cost为单价，color为颜色。颜色较特殊，因为直接返回的中文无法对应到具体的色值，所以在product.vue的data选项中定义一个map，用于映射颜色和色值。相关代码如下：</p>
                <pre class="calibre7 pv pid26" id="p26">// product.vue，部分代码省略
&lt;script&gt;
    export default {
        props: {
            info: Object
        },
        data () {
            return {
                colors: {
                    '白色': '#ffffff',
                    '金色': '#dac272',
                    '蓝色': '#233472',
                    '红色': '#f2352e'
                }
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid27" id="p27">鼠标悬停在卡片上时会显示“加入购物车”按钮，本节先定义好内容，具体实现将在14.4节完成。</p>
                <p class="calibre4 pv pid28" id="p28">product组件的模板代码如下：</p>
                <pre class="calibre7 pv pid29" id="p29">// product.vue，部分代码省略
&lt;template&gt;
    &lt;div class="product"&gt;
        &lt;router-link
            :to="'/product/' + info.id"
            class="product-main"&gt;
            &lt;img :src="info.image"&gt;
            &lt;h4&gt;{{ info.name }}&lt;/h4&gt;
            &lt;div
                class="product-color"
                :style="{ background: colors[info.color]}"&gt;&lt;/div&gt;
            &lt;div class="product-cost"&gt;¥ {{ info.cost }}&lt;/div&gt;
            &lt;div
                class="product-add-cart"
                @click.prevent="handleCart"&gt;加入购物车&lt;/div&gt;
        &lt;/router-link&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            handleCart () {
                this.$store.commit('addCart', this.info.id);
            }
        }
    };
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid30" id="p30">&lt;router-link&gt;最终会渲染为一个&lt;a&gt;标签，链接到:to定义的url，也就是商品详情页，id会作为参数通过vue-router传递。</p>
                <p class="calibre4 pv pid31" id="p31">“加入购物车”按钮对@click事件使用了prevent修饰符来阻止冒泡，否则在点击按钮的同时，也会点击到&lt;a&gt;
                    标签进入详情页。</p>
                <p class="calibre4 pv pid32" id="p32">
                    “加入购物车”按钮先设置了一个handleCart方法，通过Vuex触发mutation保存到购物车，参数为商品的id，具体逻辑将在后面介绍。</p>
                <p class="calibre4 pv pid33" id="p33">product组件的样式代码如下：</p>
                <pre class="calibre7 pv pid34" id="p34">//product.vue，部分代码省略
&lt;style scoped&gt;
    .product{
        width: 25%;
        float: left;
    }
    .product-main{
        display: block;
        margin: 16px;
        padding: 16px;
        border: 1px solid #dddee1;
        border-radius: 6px;
        overflow: hidden;
        background: #fff;
        text-align: center;
        position: relative;
    }
    .product-main img{
        width: 100%;
    }
    h4{
        color: #222;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .product-main:hover h4{
        color: #0070c9;
    }
    .product-color{
        display: block;
        width: 16px;
        height: 16px;
        border: 1px solid #dddee1;
        border-radius: 50%;
        margin: 6px auto;
    }
    .product-cost{
        color: #de4037;
        margin-top: 6px;
    }
    .product-add-cart{
        display: none;
        padding: 4px 8px;
        background: #2d8cf0;
        color: #fff;
        font-size: 12px;
        border-radius: 3px;
        cursor: pointer;
        position: absolute;
        top: 5px;
        right: 5px;
    }
    .product-main:hover .product-add-cart{
        display: inline-block;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid35" id="p35">这里给&lt;style&gt;加了scoped属性，所以样式只针对product.vue组件生效，不会影响其他组件。在class的命名上，有很多种规范，这里推荐以模块为首，依次用“-”分割作用域，比如.product、.product-main、.product-main-img。如果你使用Less或其他
                    CSS 预处理做开发，写起来会很舒服，比如上面的样式可以改写为：</p>
                <pre class="calibre7 pv pid36" id="p36">// product.vue，改写后的样式，以Less为例
&lt;style scoped lang="less"&gt;
    @prefix-cls: "product";
    .@{prefix-cls}{
        width: 25%;
        float: left;
        &amp;-main{
            display: block;
            margin: 16px;
            padding: 16px;
            border: 1px solid #dddee1;
            border-radius: 6px;
            overflow: hidden;
            background: #fff;
            text-align: center;
            position: relative;
            &amp; img{
                width: 100%;
            }
        }
        &amp; h4{
            color: #222;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        &amp;:hover h4{
            color: #0070c9;
        }
        &amp;-color{
            display: block;
            width: 16px;
            height: 16px;
            border: 1px solid #dddee1;
            border-radius: 50%;
            margin: 6px auto;
        }
        &amp;-cost{
            color: #de4037;
            margin-top: 6px;
        }
        &amp;-add-cart{
            display: none;
            padding: 4px 8px;
            background: #2d8cf0;
            color: #fff;
            font-size: 12px;
            border-radius: 3px;
            cursor: pointer;
            position: absolute;
            top: 5px;
            right: 5px;
        }
        &amp;:hover .@{prefix-cls}{
            display: inline-block;
        }
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid37" id="p37">使用CSS预编译的好处有很多，比如支持变量，封装相同样式为函数、循环等。但是webpack默认是不支持的，需要配置
                    less-loader。</p>
                <p class="calibre4 pv pid38" id="p38" style="margin: 0px;"><span class="kindle-cn-bold">配置less的方法</span>
                </p>
                <p class="calibre4 pv pid38" id="p38">首先通过NPM安装 less和less-loader：</p>
                <pre class="calibre7 pv pid39" id="p39">npm install less --save-dev
npm install less-loader --save-dev</pre>
                <p class="calibre4 pv pid40" id="p40">然后在webpack中配置 less-loader，部分代码省略：</p>
                <pre class="calibre7 pv pid41" id="p41">module: {
    rules: [
        {
            test: /\.vue$/,
            loader: 'vue-loader',
            options: {
                loaders: {
                    less: ExtractTextPlugin.extract({
                        use: ['css-loader', 'less-loader'],
                        fallback: 'vue-style-loader'
                    }),
                    css: ExtractTextPlugin.extract({
                        use: ['css-loader', 'less-loader'],
                        fallback: 'vue-style-loader'
                    })
                }
            }
        },
        {
            test: /\.less/,
            use: ExtractTextPlugin.extract({
                use: ['less-loader'],
                fallback: 'style-loader'
            })
        }
    ]
}</pre>
                <h4 class="kindle-cn-heading3 sigil_toc_id_119 pv pid42" id="p42" name="sigil_toc_id_119">
                    14.2.3　列表按照价格、销量排序</h4>
                <p class="calibre4 pv pid43" id="p43">在views目录下新建list.vue文件，并在router.js中添加商品列表的路由配置：</p>
                <pre class="calibre7 pv pid44" id="p44">// router.js
const routers = [
    {
        path: '/list',
        meta: {
            title: '商品列表'
        },
        component: (resolve) =&gt; require(['./views/list.vue'], resolve)
    },
    {
        path: '*',
        redirect: '/list'
    }
];
export default routers;</pre>
                <p class="calibre4 pv pid45" id="p45">我们先把数据搞定，再来看list.vue。列表相关的数据都通过Vuex来维护，可以回顾第11章11.2节的内容。</p>
                <p class="calibre4 pv pid46" id="p46">
                    首先需要获取商品列表的数据，获取是异步的，所以要写在Vuex的actions里。在真实场景中，数据应当是通过Ajax从服务端获取的，本实例用setTimeout来模拟异步，并用本地数据来mock。</p>
                <p class="calibre4 pv pid47" id="p47">在根目录shopping下新建文件product.js，并写入以下数据：</p>
                <pre class="calibre7 pv pid48" id="p48">// product.js
export default [
    {
        id: 1,
        name: 'AirPods',
        brand: 'Apple',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/1.jpeg',
        sales: 10000,
        cost: 1288,
        color: '白色'
    },
    {
        id: 2,
        name: 'BeatsX 入耳式耳机',
        brand: 'Beats',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/2.jpeg',
        sales: 11000,
        cost: 1188,
        color: '白色'
    },
    {
        id: 3,
        name: 'Beats Solo3 Wireless 头戴式式耳机',
        brand: 'Beats',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/3.jpeg',
        sales: 5000,
        cost: 2288,
        color: '金色'
    },
    {
        id: 4,
        name: 'Beats Pill+ 便携式扬声器',
        brand: 'Beats',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/4.jpeg',
        sales: 3000,
        cost: 1888,
        color: '红色'
    },
    {
        id: 5,
        name: 'Sonos PLAY:1 无线扬声器',
        brand: 'Sonos',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/5.jpeg',
        sales: 8000,
        cost: 1578,
        color: '白色'
    },
    {
        id: 6,
        name: 'Powerbeats3 by Dr. Dre Wireless 入耳式耳机',
        brand: 'Beats',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/6.jpeg',
        sales: 12000,
        cost: 1488,
        color: '金色'
    },
    {
        id: 7,
        name: 'Beats EP 头戴式耳机',
        brand: 'Beats',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/7.jpeg',
        sales: 25000,
        cost: 788,
        color: '蓝色'
    },
    {
        id: 8,
        name: 'B&amp;O PLAY BeoPlay A1 便携式蓝牙扬声器',
        brand: 'B&amp;O',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/8.jpeg',
        sales: 15000,
        cost: 1898,
        color: '金色'
    },
    {
        id: 9,
        name: 'Bose® QuietComfort® 35 无线耳机',
        brand: 'Bose',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/9.jpeg',
        sales: 14000,
        cost: 2878,
        color: '蓝色'
    },
    {
        id: 10,
        name: 'B&amp;O PLAY Beoplay H4 无线头戴式耳机',
        brand: 'B&amp;O',
        image: 'http://ordfm6aah.bkt.clouddn.com/shop/10.jpeg',
        sales: 9000,
        cost: 2298,
        color: '金色'
    }
]</pre>
                <p class="calibre4 pv pid49" id="p49">在main.js中导入数据，并在Vuex中声明数据列表相关的state、mutations、actions：</p>
                <pre class="calibre7 pv pid50" id="p50">// main.js，部分代码省略
// 导入数据
import product_data from './product.js';

const store = new Vuex.Store({
    state: {
        // 商品列表数据
        productList: [],
        //购物车数据
        cartList: []
    },
    mutations: {
        //添加商品列表
        setProductList (state, data) {
            state.productList = data;
        }
    },
    actions: {
        //请求商品列表
        getProductList (context) {
            // 真实环境通过Ajax获取，这里用异步模拟
            setTimeout(() =&gt; {
                context.commit('setProductList', product_data);
            }, 500);
        }
    }
});</pre>
                <p class="calibre4 pv pid51" id="p51">
                    首先通过action的getProductList方法获取数据，然后由mutation的setProduction方法将数据设置到productList。</p>
                <p class="calibre4 pv pid52" id="p52">准备好了数据，再来看视图部分。先在根实例app.vue中挂载路由并设置导航条：</p>
                <pre class="calibre7 pv pid53" id="p53">// app.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;div class="header"&gt;
            &lt;router-link
                to="/list"
                class="header-title"&gt;电商网站示例&lt;/router-link&gt;
            &lt;div class="header-menu"&gt;
                &lt;router-link to="/cart" class="header-menu-cart"&gt;
                   购物车
                    &lt;span v-if="cartList.length"&gt;{{ cartList.length }}&lt;/span&gt;
                &lt;/router-link&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            cartList () {
                return this.$store.state.cartList;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid54" id="p54">数据cartList是购物车中添加的商品，后面会介绍。路由视图&lt;router-view&gt; 挂载了所有的路由组件。</p>
                <p class="calibre4 pv pid55" id="p55">app.vue的样式在style.css中全局定义：</p>
                <pre class="calibre7 pv pid56" id="p56">// style.css
*{
    margin: 0;
    padding: 0;
}
a{
    text-decoration: none;
}
body{
    background: #f8f8f9;
}
.header{
    height: 48px;
    line-height: 48px;
    background: rgba(0,0,0,.8);
    color: #fff;
}
.header-title{
    padding: 0 32px;
    float: left;
    color: #fff;
}
.header-menu{
    float: right;
    margin-right: 32px;
}
.header-menu-cart{
    color: #fff;
}
.header-menu-cart span{
    display: inline-block;
    width: 16px;
    height: 16px;
    line-height: 16px;
    text-align: center;
    border-radius: 50%;
    background: #ff5500;
    color: #fff;
    font-size: 12px;
}</pre>
                <p class="calibre4 pv pid57" id="p57">
                    商品列表页list.vue在初始化时调用Vuex的action触发请求数据操作，并设置计算属性从Vuex中读取数据productList。相关代码如下：</p>
                <pre class="calibre7 pv pid58" id="p58">// list.vue，部分代码省略
&lt;template&gt;
    &lt;div v-show="list.length"&gt;
        &lt;Product v-for="item in list" :info="item" :key="item.id"&gt;&lt;/Product&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    // 导入商品简介组件
    import Product from '../components/product.vue';
    export default {
        components: { Product },
        computed: {
            list () {
                // 从Vuex获取商品列表数据
                return this.$store.state.productList;
            }
        },
        mounted () {
            // 初始化时，通过Vuex的action请求数据
            this.$store.dispatch('getProductList');
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid59" id="p59">打开浏览器，此时已经可以渲染出商品列表了。</p>
                <p class="calibre4 pv pid60" id="p60">
                    实现按照价格、销量排序，就不能直接使用数据list，也不能直接重置list（因为过滤不是一次性的，所以不能破坏原数据，否则无法复原），所以用计算属性来动态返回过滤后的数据。相关代码如下：</p>
                <pre class="calibre7 pv pid61" id="p61">// list.vue，部分代码省略
&lt;template&gt;
    &lt;div v-show="list.length"&gt;
        &lt;Product
            v-for="item in filteredAndOrderedList"
            :info="item"
            :key="item.id"&gt;&lt;/Product&gt;
        &lt;div
            class="product-not-found"
            v-show="!filteredAndOrderedList.length"&gt;暂无相关商品&lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Product from '../components/product.vue';
    export default {
        components: { Product },
        data () {
            return {
                // 排序依据，可选值为：
                // sales（销量）
                // cost-desc（价格降序）
                // cost-asc（价格升序）
                order: ''
            }
        },
        computed: {
            list () {
                return this.$store.state.productList;
            },
            filteredAndOrderedList () {
                // 复制原始数据
                let list = [...this.list];
                // todo按品牌过滤
                // todo按颜色过滤
                // 排序
                if (this.order !== '') {
                    if (this.order === 'sales') {
                        list = list.sort((a, b) =&gt; b.sales - a.sales);
                    } else if (this.order === 'cost-desc') {
                        list = list.sort((a, b) =&gt; b.cost - a.cost);
                    } else if (this.order === 'cost-asc') {
                        list = list.sort((a, b) =&gt; a.cost - b.cost);
                    }
                }
                return list;
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .product-not-found{
        text-align: center;
        padding: 32px;
    }
&lt;/style&gt;</pre>
                <p class="kindle-cn-para-left pv pid62" id="p62">提示</p>
                <p class="kindle-cn-para-no-indent pv pid63" id="p63" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid63" id="p63" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">展开运算符，let list = [...list] 相当于克隆了一份数据。</span></p>
                <p class="calibre4 pv pid63" id="p63">
                    计算属性filteredAndOrderedList将list进一步过滤，返回筛选、排序后的数据，排序依据于data：order，默认为空，即默认的排序为sales、cost-desc、cost-asc时则分别按照销量、价格降序、价格升序来排序。排序直接使用JavaScript数组的sort方法对前后两个值比较大小。</p>
                <p class="calibre4 pv pid64" id="p64">把&lt;Product&gt;循环的数据由list改为filteredAndOrderedList后，显示的就是过滤后的数据。剩余工作只要在视图中通过操作改变order即可。</p>
                <p class="calibre4 pv pid65" id="p65">在模板里加入排序按钮，并绑定相关事件：</p>
                <pre class="calibre7 pv pid66" id="p66">// list.vue，部分代码省略
&lt;template&gt;
    &lt;div v-show="list.length"&gt;
        &lt;div class="list-control"&gt;
            &lt;div class="list-control-order"&gt;
                &lt;span&gt;排序：&lt;/span&gt;
                &lt;span
                    class="list-control-order-item"
                    :class="{on: order === ''}"
                    @click="handleOrderDefault"&gt;默认&lt;/span&gt;
                &lt;span
                    class="list-control-order-item"
                    :class="{on: order === 'sales'}"
                    @click="handleOrderSales"&gt;
                    销量
                    &lt;template v-if="order === 'sales'"&gt;↓&lt;/template&gt;
                &lt;/span&gt;
                &lt;span
                    class="list-control-order-item"
                    :class="{on: order.indexOf('cost') &gt; -1}"
                    @click="handleOrderCost"&gt;
                    价格
                    &lt;template v-if="order === 'cost-asc'"&gt;↑&lt;/template&gt;
                    &lt;template v-if="order === 'cost-desc'"&gt;↓&lt;/template&gt;
                &lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                order: ''
            }
        },
        methods: {
            handleOrderDefault () {
                this.order = '';
            },
            handleOrderSales () {
                this.order = 'sales';
            },
            handleOrderCost () {
                if (this.order === 'cost-desc') {
                    this.order = 'cost-asc';
                } else {
                    this.order = 'cost-desc';
                }
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .list-control{
        background: #fff;
        border-radius: 6px;
        margin: 16px;
        padding: 16px;
        box-shadow: 0 1px 1px rgba(0,0,0,.2);
    }
    .list-control-filter{
        margin-bottom: 16px;
    }
    .list-control-filter-item,
    .list-control-order-item {
        cursor: pointer;
        display: inline-block;
        border: 1px solid #e9eaec;
        border-radius: 4px;
        margin-right: 6px;
        padding: 2px 6px;
    }
    .list-control-filter-item.on,
    .list-control-order-item.on{
        background: #f2352e;
        border: 1px solid #f2352e;
        color: #fff;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid67" id="p67">“默认”和“销量”只能单次点击，“价格”按钮可以点击切换为升序和降序两种状态。</p>
                <p class="calibre4 pv pid68" id="p68">通过判断order的状态，给3个按钮动态绑定了class（.on）来高亮显示当前排序的按钮。</p>
                <p class="calibre4 pv pid69" id="p69">刷新页面，点击切换排序状态，商品列表已经可以动态更新了。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_120 pv pid70" id="p70" name="sigil_toc_id_120">
                    14.2.4　列表按照品牌、颜色筛选</h4>
                <p class="calibre4 pv pid71" id="p71">首先准备数据。</p>
                <p class="calibre4 pv pid72" id="p72">品牌和颜色的数据可以作为getters从Vuex的productList里遍历获取，示例代码如下：</p>
                <pre class="calibre7 pv pid73" id="p73">// main.js，部分代码省略
//数组排重
function getFilterArray (array) {
    const res = [];
    const json = {};
    for (let i = 0; i &lt; array.length; i++){
        const _self = array[i];
        if(!json[_self]){
            res.push(_self);
            json[_self] = 1;
        }
    }
    return res;
}

const store = new Vuex.Store({
    state: {
        productList: []
    },
    getters: {
        brands: state =&gt; {
            const brands = state.productList.map(item =&gt; item.brand);
            return getFilterArray(brands);
        },
        colors: state =&gt; {
            const colors = state.productList.map(item =&gt; item.color);
            return getFilterArray(colors);
        }
    }
});</pre>
                <p class="calibre4 pv pid74" id="p74">
                    使用map方法把productList里的brand或color数据过滤出来，然后用getFilterArray方法对数组去重。</p>
                <p class="calibre4 pv pid75" id="p75">
                    getters里的brands和colors依赖数据productList，与计算属性原理类似，所以只要维护好productList、brands和colors就可以自动更新。</p>
                <p class="calibre4 pv pid76" id="p76">然后在list.vue中把Vuex里的品牌和颜色数据引入，并完成列表的过滤：</p>
                <pre class="calibre7 pv pid77" id="p77">// list.vue，部分代码省略
&lt;script&gt;
    export default {
        computed: {
            list () {
                return this.$store.state.productList;
            },
            brands () {
                return this.$store.getters.brands;
            },
            colors () {
                return this.$store.getters.colors;
            },
            filteredAndOrderedList () {
                let list = [...this.list];
                //按品牌过滤
                if (this.filterBrand !== '') {
                    list = list.filter(item =&gt; item.brand === this.filterBrand);
                }
                //按颜色过滤
                if (this.filterColor !== '') {
                    list = list.filter(item =&gt; item.color === this.filterColor);
                }
                // 排序...
                return list;
            }
        },
        data () {
            return {
                filterBrand: '',
                filterColor: ''
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid78" id="p78">
                    品牌和颜色都是单选，但是可以协同过滤。最后只需要根据操作设置正确的filterBrand和filterColor，商品列表就可以自动完成对品牌、颜色的筛选以及价格、销量的排序。相关代码如下：</p>
                <pre class="calibre7 pv pid79" id="p79">// list.vue，部分代码如下
&lt;template&gt;
    &lt;div v-show="list.length"&gt;
        &lt;div class="list-control"&gt;
            &lt;div class="list-control-filter"&gt;
                &lt;span&gt;品牌：&lt;/span&gt;
                &lt;span
                    class="list-control-filter-item"
                    :class="{on: item === filterBrand}"
                    v-for="item in brands"
                    @click="handleFilterBrand(item)"&gt;{{ item }}&lt;/span&gt;
            &lt;/div&gt;
            &lt;div class="list-control-filter"&gt;
                &lt;span&gt;颜色：&lt;/span&gt;
                &lt;span
                    class="list-control-filter-item"
                    :class="{on: item === filterColor}"
                    v-for="item in colors"
                    @click="handleFilterColor(item)"&gt;{{ item }}&lt;/span&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            // 筛选品牌
            handleFilterBrand (brand) {
                //单次点击选中，再次点击取消选中
                if (this.filterBrand === brand) {
                    this.filterBrand = '';
                } else {
                    this.filterBrand = brand;
                }
            },
            // 筛选颜色
            handleFilterColor (color) {
                if (this.filterColor === color) {
                    this.filterColor = '';
                } else {
                    this.filterColor = color;
                }
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid80" id="p80" style="margin: 0px;"><span class="kindle-cn-bold">思考：</span>Vuex的getters和组件内的computed很相似，其实把示例中的brands和colors写在list.vue的computed中也是可以的，那么到底什么时候把数据存在Vuex恰当，而什么时候在组件内维护好呢？如果在业务中比较纠结，可以结合以下几点综合考虑：
                </p>
                <ul class="kindle-cn-ul-disc pv pid80" id="p80" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">如果数据还有其他组件复用，建议放在Vuex。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">如果需要跨多级组件传递数据，建议放在Vuex。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">需要持久化的数据（如登录后用户的信息），建议放在Vuex。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">跟当前业务组件强相关的数据（如示例中的filterBrand、filterColor，它们只在当前组件有用），可以放在组件内。</span>
                    </li>
                </ul>
                <h3 class="kindle-cn-heading2 sigil_toc_id_121 pv pid80" id="p80" name="sigil_toc_id_121">
                    14.3　商品详情页</h3>
                <p class="calibre4 pv pid81" id="p81">在views目录下新建product.vue文件，并在router.js中添加商品详情的路由配置：</p>
                <pre class="calibre7 pv pid82" id="p82">// router.js，部分代码省略
const routers = [
    {
        path: '/product/:id',
        meta: {
            title: '商品详情'
        },
        component: (resolve) =&gt; require(['./views/product.vue'], resolve)
    }
];</pre>
                <p class="calibre4 pv pid83" id="p83">
                    商品详情的路由接收一个参数id，即商品的id。常见的业务场景中，会以id作为接口的索引，查询出所有相关的数据。为了使业务更好地解耦，从商品列表页跳转至详情页时，只传递一个商品的id，不需要其他任何数据（虽然像商品名称、价格等数据在详情页已拿到，但不传递，重新获取）。</p>
                <p class="calibre4 pv pid84" id="p84">
                    通过$route可以获取当前路由的参数，并在页面初始化时请求该商品的数据，示例使用setTimeout来模拟异步，真实场景下应该通过Ajax来请求数据。我们从数据源（product.js）里通过数组的find()方法拿到指定
                    id的数据，完成数据mock。</p>
                <pre class="calibre7 pv pid85" id="p85">// views/product.vue，部分代码省略
&lt;script&gt;
    // 导入本地数据做匹配用，真实场景并不需要
    import product_data from '../product.js';
    export default {
        data () {
            return {
                // 获取路由中的参数
                id: parseInt(this.$route.params.id),
                product: null
            }
        },
        methods: {
            getProduct () {
                // 真实环境通过Ajax获取，这里用异步模拟
                setTimeout(() =&gt; {
                    this.product = product_data
                        .find(item =&gt; item.id === this.id);
                }, 500);
            }
        },
        mounted () {
            // 初始化时，请求数据
            this.getProduct();
        }
    }
&lt;/script&gt;</pre>
                <p class="kindle-cn-para-left pv pid86" id="p86">提示</p>
                <p class="kindle-cn-para-no-indent pv pid87" id="p87" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid87" id="p87" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">数组的find()方法返回数组中满足提供的测试函数的第一个元素的值，示例是将其与箭头函数连用。</span></p>
                <p class="calibre4 pv pid87" id="p87">
                    然后将数据写入模板即可。需要注意的是，电商网站的详情页一般为自定义的文本和图片，商家通过富文本编辑器以可视化的形式编辑好商品内容，接口返回的是html片段，可以直接用v-html指令渲染html内容，但在服务端要对提交的html做处理，避免发生XSS攻击。本实例将10张产品的图片依次展示作为商品的内容。其代码如下：</p>
                <pre class="calibre7 pv pid88" id="p88">// views/product.vue，部分代码省略
&lt;template&gt;
    &lt;div v-if="product"&gt;
        &lt;div class="product"&gt;
            &lt;div class="product-image"&gt;
                &lt;img :src="product.image"&gt;
            &lt;/div&gt;
            &lt;div class="product-info"&gt;
                &lt;h1 class="product-name"&gt;{{ product.name }}&lt;/h1&gt;
                &lt;div class="product-cost"&gt;¥ {{ product.cost }}&lt;/div&gt;
                &lt;div class="product-add-cart"
                     @click="handleAddToCart"&gt;加入购物车&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="product-desc"&gt;
            &lt;h2&gt;产品介绍&lt;/h2&gt;
            &lt;img v-for="n in 10"
                 :src="'http://ordfm6aah.bkt.clouddn.com/shop/' + n + '.jpeg'"&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            // 加入购物车
            handleAddToCart () {
                this.$store.commit('addCart', this.id);
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .product{
        margin: 32px;
        padding: 32px;
        background: #fff;
        border: 1px solid #dddee1;
        border-radius: 10px;
        overflow: hidden;
    }
    .product-image{
        width: 50%;
        height: 550px;
        float: left;
        text-align: center;
    }
    .product-image img{
        height: 100%;
    }
    .product-info{
        width: 50%;
        padding: 150px 0 250px;
        height: 150px;
        float: left;
        text-align: center;
    }
    .product-cost{
        color: #f2352e;
        margin: 8px 0;
    }
    .product-add-cart{
        display: inline-block;
        padding: 8px 64px;
        margin: 8px 0;
        background: #2d8cf0;
        color: #fff;
        border-radius: 4px;
        cursor: pointer;
    }
    .product-desc{
        background: #fff;
        margin: 32px;
        padding: 32px;
        border: 1px solid #dddee1;
        border-radius: 10px;
        text-align: center;
    }
    .product-desc img{
        display: block;
        width: 50%;
        margin: 32px auto;
        padding: 32px;
        border-bottom: 1px solid #dddee1;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid89" id="p89">加入购物车的功能与列表页相同，将在下一节重点介绍。最后渲染的效果如图14-3所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid90" id="p90" style="margin: 0px;"><img alt="327"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/a7a1319b1700d40b.jpg"
                                                                                                         href="./image/00053.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图14-3　商品详情页部分效果</p></div>
                <h3 class="kindle-cn-heading2 sigil_toc_id_122 pv pid90" id="p90" name="sigil_toc_id_122">14.4　购物车</h3>
                <p class="calibre4 pv pid91" id="p91">最后也是购物最重要的一个环节，就是在购物车完成结算，购物车的效果如图14-4所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid92" id="p92" style="margin: 0px;"><img alt="327-2"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/85c55f61dd34024d.jpg"
                                                                                                         href="./image/00054.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图14-4　购物车</p></div>
                <p class="calibre4 pv pid92" id="p92">
                    在购物车中，每件商品最少要选1件，不过可以删除，每件商品会有价格小计（单价乘以数量）。可以使用优惠码，使用后在总价的基础上减少500元，总价会根据购买商品的数量动态计算。右上角的购物车入口也会显示当前购物车商品的数量。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_123 pv pid93" id="p93" name="sigil_toc_id_123">
                    14.4.1　准备数据</h4>
                <p class="calibre4 pv pid94" id="p94">
                    之前已经提到过，将商品加入购物车是通过Vuex来完成的。在main.js中，先来定义Vuex中的state和mutations：</p>
                <pre class="calibre7 pv pid95" id="p95">// main.js，部分代码省略
const store = new Vuex.Store({
    state: {
        productList: [],
        cartList: []
    },
    mutations: {
        //添加到购物车
        addCart (state, id) {
            // 先判断购物车是否已有，如果有，数量+1
            const isAdded = state.cartList.find(item =&gt; item.id === id);
            if (isAdded) {
                isAdded.count ++;
            } else {
                state.cartList.push({
                    id: id,
                    count: 1
                })
            }
        }
    }
});</pre>
                <p class="calibre4 pv pid96" id="p96">
                    数据cartList中保存购物车记录，数据格式为数组，每项是对象，包含商品id和购买数量两个数据（遵循解耦，其余信息通过id间接获取）。addCart方法接收参数为商品id，添加前先判断cartList中是否已存在商品，存在则数量加1，不存在则写入。</p>
                <p class="calibre4 pv pid97" id="p97">有了购物车数据，剩余工作就是把数据显示出来，并动态修改数据。在app.vue中定义购物车入口和已添加数量：</p>
                <pre class="calibre7 pv pid98" id="p98">// app.vue
&lt;template&gt;
    &lt;div&gt;
        &lt;div class="header"&gt;
            &lt;router-link
                to="/list"
                class="header-title"&gt;电商网站示例&lt;/router-link&gt;
            &lt;div class="header-menu"&gt;
                &lt;router-link to="/cart" class="header-menu-cart"&gt;
                   购物车
                    &lt;span v-if="cartList.length"&gt;{{ cartList.length }}&lt;/span&gt;
                &lt;/router-link&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;router-view&gt;&lt;/router-view&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        computed: {
            cartList () {
                return this.$store.state.cartList;
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid99" id="p99">在views目录中新建cart.vue文件，并添加购物车路由：</p>
                <pre class="calibre7 pv pid100" id="p100">// router.js，部分代码省略
const routers = [
    {
        path: '/cart',
        meta: {
            title: '购物车'
        },
        component: (resolve) =&gt; require(['./views/cart.vue'], resolve)
    }
];</pre>
                <p class="calibre4 pv pid101" id="p101">cart.vue中，可以先准备好以下动态数据：</p>
                <ul class="kindle-cn-ul-disc pv pid102" id="p102" style="margin: 0px;">
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">Vuex中的购物车数据cartList。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">product.js中所有的商品数据（mock用）。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">将product.js中的数组转换为字典productDictList，方便快速选取。</span>
                    </li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">商品总数countAll。</span></li>
                    <li class="calibre6"><span class="kindle-cn-specialtext-kaiti">总费用（不含优惠码）costAll。</span></li>
                </ul>
                <pre class="calibre7 pv pid102" id="p102">// cart.vue，部分代码省略
&lt;script&gt;
    import product_data from '../product.js';
    export default {
        computed: {
            cartList () {
                return this.$store.state.cartList;
            },
            productDictList () {
                const dict = {};
                this.productList.forEach(item =&gt; {
                    dict[item.id] = item;
                });
                return dict;
            },
            countAll () {
                let count = 0;
                this.cartList.forEach(item =&gt; {
                    count += item.count;
                });
                return count;
            },
            costAll () {
                let cost = 0;
                this.cartList.forEach(item =&gt; {
                    cost += this.productDictList[item.id].cost * item.count;
                });
                return cost;
            }
        },
        data () {
            return {
                productList: product_data
            }
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid103" id="p103">这些数据都使用了计算属性，因为彼此互相依赖。</p>
                <p class="calibre4 pv pid104" id="p104">
                    productDictList是对象，key是商品id，value是商品信息，数据即为product.js中每项的内容，通过id可以快速便捷地获取对应商品信息。</p><h4
                        class="kindle-cn-heading3 sigil_toc_id_124 pv pid105" id="p105" name="sigil_toc_id_124">
                    14.4.2　显示和操作数据</h4>
                <p class="calibre4 pv pid106" id="p106">在下单前，可以对每个商品的数量进行加减，或者删除商品。先将购物车数据cartList循环渲染，并完成表格的样式。</p>
                <pre class="calibre7 pv pid107" id="p107">// cart.vue，部分代码省略
&lt;template&gt;
    &lt;div class="cart"&gt;
        &lt;div class="cart-header"&gt;
            &lt;div class="cart-header-title"&gt;购物清单&lt;/div&gt;
            &lt;div class="cart-header-main"&gt;
                &lt;div class="cart-info"&gt;商品信息&lt;/div&gt;
                &lt;div class="cart-price"&gt;单价&lt;/div&gt;
                &lt;div class="cart-count"&gt;数量&lt;/div&gt;
                &lt;div class="cart-cost"&gt;小计&lt;/div&gt;
                &lt;div class="cart-delete"&gt;删除&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class="cart-content"&gt;
            &lt;div class="cart-content-main" v-for="(item, index) in cartList"&gt;
                &lt;div class="cart-info"&gt;
                    &lt;img :src="productDictList[item.id].image"&gt;
                    &lt;span&gt;{{ productDictList[item.id].name }}&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="cart-price"&gt;
                    ¥ {{ productDictList[item.id].cost }}
                &lt;/div&gt;
                &lt;div class="cart-count"&gt;
                    &lt;span
                        class="cart-control-minus"
                        @click="handleCount(index, -1)"&gt;-&lt;/span&gt;
                    {{ item.count }}
                    &lt;span
                        class="cart-control-add"
                        @click="handleCount(index, 1)"&gt;+&lt;/span&gt;
                &lt;/div&gt;
                &lt;div class="cart-cost"&gt;
                    ¥ {{ productDictList[item.id].cost * item.count }}
                &lt;/div&gt;
                &lt;div class="cart-delete"&gt;
                    &lt;span
                        class="cart-control-delete"
                        @click="handleDelete(index)"&gt;删除&lt;/span&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="cart-empty" v-if="!cartList.length"&gt;购物车为空&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        methods: {
            handleCount (index, count) {
                if (count &lt; 0 &amp;&amp; this.cartList[index].count === 1) return;
                this.$store.commit('editCartCount', {
                    id: this.cartList[index].id,
                    count: count
                });
            },
            handleDelete (index) {
                this.$store.commit('deleteCart', this.cartList[index].id);
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .cart{
        margin: 32px;
        background: #fff;
        border: 1px solid #dddee1;
        border-radius: 10px;
    }
    .cart-header-title{
        padding: 16px 32px;
        border-bottom: 1px solid #dddee1;
        border-radius: 10px 10px 0 0;
        background: #f8f8f9;
    }
    .cart-header-main{
        padding: 8px 32px;
        overflow: hidden;
        border-bottom: 1px solid #dddee1;
        background: #eee;
        overflow: hidden;
    }
    .cart-empty{
        text-align: center;
        padding: 32px;
    }
    .cart-header-main div{
        text-align: center;
        float: left;
        font-size: 14px;
    }
    div.cart-info{
        width: 60%;
        text-align: left;
    }
    .cart-price{
        width: 10%;
    }
    .cart-count{
        width: 10%;
    }
    .cart-cost{
        width: 10%;
    }
    .cart-delete {
        width: 10%;
    }
    .cart-content-main{
        padding: 0 32px;
        height: 60px;
        line-height: 60px;
        text-align: center;
        border-bottom: 1px dashed #e9eaec;
        overflow: hidden;
    }
    .cart-content-main div{
        float: left;
    }
    .cart-content-main img{
        width: 40px;
        height: 40px;
        position: relative;
        top: 10px;
    }
    .cart-control-minus,
    .cart-control-add{
        display: inline-block;
        margin: 0 4px;
        width: 24px;
        height: 24px;
        line-height: 22px;
        text-align: center;
        background: #f8f8f9;
        border-radius: 50%;
        box-shadow: 0 1px 1px rgba(0,0,0,.2);
        cursor: pointer;
    }
    .cart-control-delete{
        cursor: pointer;
        color: #2d8cf0;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid108" id="p108">
                    handleCount方法用于修改购物车商品数量，最小为1；handleDelete方法用于删除商品。两者都根据接收的参数index（循环cartList中的索引），并从数据cartList中获取具体商品信息。只传入index，而不是具体数据（比如id）的好处是更灵活、便于扩展，如果需求有所改变，就需要修改handleCount里的逻辑，不需要维护模板部分。</p>
                <p class="calibre4 pv pid109" id="p109">这两个方法都交给了Vuex中的mutations来操作数据：</p>
                <pre class="calibre7 pv pid110" id="p110">// main.js，部分代码省略
const store = new Vuex.Store({
    state: {
        cartList: []
    },
    mutations: {
        //修改商品数量
        editCartCount (state, payload) {
            const product = state.cartList.find(item =&gt; item.id === payload.id);
            product.count += payload.count;
        },
        // 删除商品
        deleteCart (state, id) {
            const index = state.cartList.findIndex(item =&gt; item.id === id);
            state.cartList.splice(index, 1);
        }
    }
});</pre>
                <p class="kindle-cn-para-left pv pid111" id="p111">提示</p>
                <p class="kindle-cn-para-no-indent pv pid112" id="p112" style="margin: 0px;"><span
                        class="hei">ES 6语法提示：</span></p>
                <p class="kindle-cn-para-no-indent pv pid112" id="p112" style="margin: 0px;"><span
                        class="kindle-cn-specialtext-kaiti">数组的findIndex()方法返回数组中满足提供的测试函数的第一个元素的索引，示例是将其与箭头函数连用。</span>
                </p>
                <p class="calibre4 pv pid112" id="p112" style="margin: 0px;"><span class="kindle-cn-bold">思考：</span>修改购物车数量时，判断是否只有1件的逻辑是写在handleCount方法内的，而不是在Vuex的editCarCount中。但事实上，写在Vuex里也是可以的，但不建议这样写，因为Vuex主要以操作数据为主，不应该关心具体的业务逻辑，业务逻辑应该在业务组件中维护。
                </p><h4 class="kindle-cn-heading3 sigil_toc_id_125 pv pid112" id="p112" name="sigil_toc_id_125">
                    14.4.3　使用优惠码</h4>
                <p class="calibre4 pv pid113" id="p113">使用优惠码可以在总价的基础上减少指定的费用。验证优惠码的过程在真实场景也是通过Ajax完成的，这里仍然在本地模拟。</p>
                <p class="calibre4 pv pid114" id="p114">
                    优惠码功能使用到两个数据：promotionCode和promotion，前者用于双向绑定输入框数据，后者是优惠金额。其代码如下：</p>
                <pre class="calibre7 pv pid115" id="p115">// cart.vue，部分代码省略
&lt;template&gt;
    &lt;div class="cart"&gt;
        &lt;div class="cart-promotion" v-show="cartList.length"&gt;
            &lt;span&gt;使用优惠码：&lt;/span&gt;
            &lt;input type="text" v-model="promotionCode"&gt;
            &lt;span
                class="cart-control-promotion"
                @click="handleCheckCode"&gt;验证&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class="cart-footer" v-show="cartList.length"&gt;
            &lt;div class="cart-footer-desc"&gt;
                共计 &lt;span&gt;{{ countAll }}&lt;/span&gt;件商品
            &lt;/div&gt;
            &lt;div class="cart-footer-desc"&gt;
               应付总额 &lt;span&gt;¥ {{ costAll - promotion }}&lt;/span&gt;
                &lt;br&gt;
                &lt;template v-if="promotion"&gt;
                    （优惠 &lt;span&gt;¥ {{ promotion }}&lt;/span&gt;）
                &lt;/template&gt;
            &lt;/div&gt;
            &lt;div class="cart-footer-desc"&gt;
                &lt;div
                    class="cart-control-order"
                    @click="handleOrder"&gt;现在结算&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    export default {
        data () {
            return {
                promotionCode: '',
                promotion: 0
            }
        },
        methods: {
            // 验证优惠码，我们用Vue.js 代表正确的优惠码
            handleCheckCode () {
                if (this.promotionCode === '') {
                    window.alert('请输入优惠码');
                    return;
                }
                if (this.promotionCode !== 'Vue.js') {
                    window.alert('优惠码验证失败');
                } else {
                    this.promotion = 500;
                }
            },
            // 通知Vuex，完成下单
            handleOrder () {
                this.$store.dispatch('buy').then(() =&gt; {
                    window.alert('购买成功');
                })
            }
        }
    }
&lt;/script&gt;
&lt;style scoped&gt;
    .cart-promotion{
        padding: 16px 32px;
    }
    .cart-control-promotion,
    .cart-control-order{
        display: inline-block;
        padding: 8px 32px;
        border-radius: 6px;
        background: #2d8cf0;
        color: #fff;
        cursor: pointer;
    }
    .cart-control-promotion{
        padding: 2px 6px;
        font-size: 12px;
        border-radius: 3px;
    }
    .cart-footer{
        padding: 32px;
        text-align: right;
    }
    .cart-footer-desc{
        display: inline-block;
        padding: 0 16px;
    }
    .cart-footer-desc span{
        color: #f2352e;
        font-size: 20px;
    }
&lt;/style&gt;</pre>
                <p class="calibre4 pv pid116" id="p116">应付总额是实际的商品总价减去优惠的价格，因为优惠价promotion默认是0，可以不再判断是否使用了优惠码。</p>
                <p class="calibre4 pv pid117" id="p117">
                    下单的操作通过Vuex的action完成，下单成功后，清空购物车数据。因为下单要通知服务端，所以需要在action内操作。</p>
                <pre class="calibre7 pv pid118" id="p118">// main.js，部分代码省略
const store = new Vuex.Store({
    state: {
        cartList: []
    },
    mutations: {
        // 清空购物车
        emptyCart (state) {
            state.cartList = [];
        }
    },
    actions: {
        //购买
        buy (context) {
            // 真实环境应通过Ajax提交购买请求后再清空购物列表
            return new Promise(resolve=&gt; {
                setTimeout(() =&gt; {
                    context.commit('emptyCart');
                    resolve();
                }, 500)
            });
        }
    }
});</pre>
                <p class="calibre4 pv pid119" id="p119">
                    在action中，使用setTimeout模拟异步，并通过返回一个Promise对象来通知cart.vue的handleOrder购物完成。关于在action中Promise的用法，可以回顾11.2.3小节Vuex的高级用法内容。</p>
                <p class="calibre4 pv pid120" id="p120">至此，本实战项目的所有功能已介绍完毕。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_126 pv pid121" id="p121" name="sigil_toc_id_126">14.5　总结</h3>
                <p class="calibre4 pv pid122" id="p122">本章所有的代码已上传至GitHub，访问下面的链接可以查看到并直接使用：</p>
                <p class="calibre4 pv pid123" id="p123">https://github.com/icarusion/vue-book</p>
                <p class="calibre4 pv pid124" id="p124">vue-book下的shopping目录就是本章的代码，在该目录下执行npm
                    install命令会自动安装所有的依赖，然后执行npm run dev启动webpack服务。</p>
                <p class="calibre4 pv pid125" id="p125">
                    在大中型项目中，尤其是多人协同开发时，最重要的是模块解耦。对于公共组件，要定义好API（props、events、slots），公用数据要在Vuex或bus中统一维护。在业务中，要尽可能避免直接操作父链和子链来修改组件的状态，对于跨级通信最好通过Vuex或bus完成。</p>
                <p class="calibre4 pv pid126" id="p126">
                    在协同开发时，可以将路由组件的内容拆分为多个组件，由不同的人维护，这样可以避免冲突，使模块更清晰，寻找bug也更有针对性。公共配置还可以使用混合（mixins）。</p>
                <p class="calibre4 pv pid127" id="p127">
                    当项目中页面较多，在使用Vuex时可以将store分发到不同的文件或文件夹内，并参照11.2.3小节Vuex的高级用法，使用modules把store分割到不同的模板，这样对于复杂的应用更具维护性。</p>
                <p class="calibre4 pv pid128" id="p128" style="margin: 0px;"><span class="kindle-cn-bold">练习1：</span>将品牌和颜色的筛选扩展为支持多选，比如支持同时选择白色和红色。
                </p>
                <p class="calibre4 pv pid128" id="p128" style="margin: 0px;"><span class="kindle-cn-bold">练习2：</span>购物车数据支持持久化（本地保存，重新打开页面仍然有记录）。
                </p></div>
        </div>
        <div class="JD_page"
             style="overflow: auto; font-size: 16px; opacity: 1; width: 1518px; background-color: rgb(234, 234, 234);"
             id="page0" page="0" data-chapter-index="149" data-chapter-url="24047104" alt="64157403">
            <div class="page_container" style="overflow:hidden;margin: 10px auto; width:1366px"><h2
                    class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第15章　相关开源项目介绍</h2>
                <p class="calibre4 pv pid3" id="p3">
                    本章将介绍一些实际开发中经常使用的与Vue.js相关的开源项目，它们包括服务端渲染框架Nuxt.js、HTTP库axios以及多语言插件vue-i18n。使用好的开源项目可以让你的团队事半功倍。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_127 pv pid4" id="p4" name="sigil_toc_id_127">
                    15.1　服务端渲染与Nuxt.js</h3><h4 class="kindle-cn-heading3 sigil_toc_id_128 pv pid5" id="p5"
                                               name="sigil_toc_id_128">15.1.1　是否需要服务端渲染</h4>
                <p class="calibre4 pv pid6" id="p6">Vue.js 2是支持服务端渲染的，不过在使用前有必要先了解你的业务场景和服务端渲染的特点，然后权衡是否真的需要服务端渲染。</p>
                <p class="calibre4 pv pid7" id="p7">
                    服务端渲染（SSR）并不是什么新鲜技术，从互联网开始至今，大部分网站的内容仍然是由服务端渲染的，然后返回到客户端。如何查看一个网站是否是SSR呢？很简单，比如打开一个含有文章内容的网站，查看它的源代码，看这些文字是不是都在源代码里面，如果是，那它就是SSR；或者通过Chrome调试工具，在network面板查看有没有相关的异步请求来调取内容。</p>
                <p class="calibre4 pv pid8" id="p8">
                    很多网站之所以使用SSR，主要目的是做搜索引擎优化（SEO）。由于所处的国家和利益不同，谷歌很早就支持对使用Ajax技术异步渲染内容的网站进行爬取，它们洞见了这种技术将会被广泛利用，不过谷歌在服务端的开销也要增加很多，因为这依赖于一个模拟的浏览器环境。百度至今仍不支持爬取动态渲染内容为主的网站，可能是国内目前需营销的网站大多还是静态内容站吧。因此，是否需要SSR，最主要的因素就是是否需要SEO，换句话说，你的产品是面向大众用户的，还是面向企业的。如果是面向企业，那可能只有首页、信息页和一些营销页面需要SEO，与主产品分离。</p>
                <p class="calibre4 pv pid9" id="p9">
                    使用SSR的第二原因是，客户端的网络可能是不稳定的，有的地方很快，有的地方会很慢。这种情况下，通过SSR减少请求量和客户端渲染可以相对快速地看到内容。</p>
                <p class="calibre4 pv pid10" id="p10">
                    SSR听起来很不错，使用它也是有前提的，那就是你的团队需要懂Node.js的小伙伴。Vue.js的后端渲染不同于PHP的模板或JSP等网站，你的产品可能还是由PHP、Java等后端来提供数据接口，Node.js在这里只负责渲染，也就是中间层（大前端）。如果你的团队具备了这些技术能力，产品也有SSR的场景，那就可以尽情地使用Vue.js的SSR。</p>
                <h4 class="kindle-cn-heading3 sigil_toc_id_129 pv pid11" id="p11" name="sigil_toc_id_129">
                    15.1.2　Nuxt.js</h4>
                <p class="calibre4 pv pid12" id="p12" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/nuxt/nuxt.js。
                </p>
                <p class="calibre4 pv pid12" id="p12">
                    Nuxt.js是一个基于Vue.js的通用应用框架，为Node.js做Vue的服务端渲染提供了各种配置。使用Nuxt.js，你可以轻松、快速地搭建一套SSR框架，省去了大量配置的工作。</p>
                <p class="calibre4 pv pid13" id="p13">
                    为了快速体验Nuxt.js，可以下载安装starter模板（https://github.com/nuxt/starter/archive/source.zip）。下载后，通过npm
                    install安装依赖，再通过npm run dev启动项目，在浏览器访问127.0.0.1:3000即可预览，如图15-1所示。</p>
                <div class="kindle-cn-bodycontent-div-alone pv pid14" id="p14" style="margin: 0px;"><img alt="340"
                                                                                                         class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                                         src="./index_files/504c8a2c3e61e6c5.jpg"
                                                                                                         href="./image/00055.jpeg">
                    <p class="kindle-cn-picture-txt-withfewcharactors">图15-1　Nuxt.js项目</p></div>
                <p class="calibre4 pv pid14" id="p14">与普通Vue.js项目不同的是，Nuxt.js构建的代码，UI是在服务端渲染的，而非在客户端。通过webpack
                    创建的SPA项目，查看其源代码，&lt;body&gt;内一般只有一个&lt;div&gt;元素作为根实例挂载节点，其他都由JavaScript来渲染。而查看Nuxt.js构建后的源代码，所有模板内容直接渲染在其中。</p>
                <p class="calibre4 pv pid15" id="p15">使用Nuxt.js基本与写.vue单文件一致，可到项目下的pages内查看首页文件index.vue。更多
                    Nuxt.js详细的用法和Vue.js的SSR可以阅读官方文档。</p>
                <p class="calibre4 pv pid16" id="p16">Vue.js服务端渲染（SSR）文档：https://ssr.vuejs.org/</p>
                <p class="calibre4 pv pid17" id="p17">Nuxt.js文档：https://nuxtjs.org/</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_130 pv pid18" id="p18" name="sigil_toc_id_130">
                    15.2　HTTP库axios</h3>
                <p class="calibre4 pv pid19" id="p19" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/mzabriskie/axios。
                </p>
                <p class="calibre4 pv pid19" id="p19">axios是一个基于Promise，同时支持浏览器端和Node.js的HTTP库，常用于Ajax请求。</p>
                <p class="calibre4 pv pid20" id="p20">
                    Vue.js不像jQuery或AngularJS，本身并没有携带Ajax方法，因此需要借助插件或第三方HTTP库，而axios就是一个很不错的选择。</p>
                <p class="calibre4 pv pid21" id="p21">可以通过NPM或CDN的形式来使用axios，以NPM为例，先进行安装：</p>
                <pre class="calibre7 pv pid22" id="p22">npm install axios --save</pre>
                <p class="calibre4 pv pid23" id="p23">axios 提供了多种请求方式，比如直接发起GET或POST请求：</p>
                <pre class="calibre7 pv pid24" id="p24">axios.get('/user?ID=12345')
    .then(function (response) {
        console.log(response);
    })
    .catch(function (error) {
        console.log(error);
    });

axios.post('/user', {
        firstName: 'Fred',
        lastName: 'Flintstone'
    })
    .then(function (response) {
        console.log(response);
    })
    .catch(function (error) {
        console.log(error);
    });</pre>
                <p class="calibre4 pv pid25" id="p25">基于Promise，可以执行多个并发请求：</p>
                <pre class="calibre7 pv pid26" id="p26">function getUserAccount() {
    return axios.get('/user/12345');
}

function getUserPermissions() {
    return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
      //请求都完成时...
    }));</pre>
                <p class="calibre4 pv pid27" id="p27">也可以通过写入配置的形式发起请求：</p>
                <pre class="calibre7 pv pid28" id="p28">axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
    .then(function (res) {
        console.log(res);
    });</pre>
                <p class="calibre4 pv pid29" id="p29">在业务中，经常将其封装为实例的形式调用，便于做通用配置，例如：</p>
                <pre class="calibre7 pv pid30" id="p30">// util.js
const instance = axios.create({
    baseURL: 'https://some-domain.com/api',
    timeout: 1000,
    headers: {'Content-Type': 'application/x-www-form-urlencoded;'}
});

export default instance;

// index.vue
&lt;template&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Ajax from './util.js';
    export default {
        mounted () {
            Ajax({
                method: 'post',
                url: '/user',
                data: {
                    firstName: 'Fred',
                    lastName: 'Flintstone'
                }
            }).then(res =&gt; {
                console.log(res);
            });
        }
    }
&lt;/script&gt;</pre>
                <p class="calibre4 pv pid31" id="p31">更多关于axios的配置，可到GitHub项目主页阅读其文档。</p>
                <h3 class="kindle-cn-heading2 sigil_toc_id_131 pv pid32" id="p32" name="sigil_toc_id_131">
                    15.3　多语言插件vue-i18n</h3>
                <p class="calibre4 pv pid33" id="p33" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/kazupon/vue-i18n。
                </p>
                <p class="calibre4 pv pid33" id="p33">vue-i18n是一个Vue.js插件，提供了多语言解决方案。如果你的项目有多国语言的需求，可以使用它很快速地实现。</p>
                <p class="calibre4 pv pid34" id="p34">通过NPM来安装：</p>
                <pre class="calibre7 pv pid35" id="p35">npm install vue-i18n --save</pre>
                <p class="calibre4 pv pid36" id="p36">然后在webpack 入口文件中使用插件：</p>
                <pre class="calibre7 pv pid37" id="p37">// main.js
import Vue from 'vue';
import VueI18n from 'vue-i18n';

Vue.use(VueI18n);</pre>
                <p class="calibre4 pv pid38" id="p38">使用vue-i18n插件需要在入口文件中进行多语言包的配置，其实是一个对象，每种语言对应于一个key：</p>
                <pre class="calibre7 pv pid39" id="p39">// main.js接上面代码
// …
const messages = {
    en: {
        message: {
            hello: 'hello world'
        }
    },
    cn: {
        message: {
            hello: '你好，世界'
        }
    }
}

const i18n = new VueI18n({
    locale: 'en',               // 设置当前语言
    messages,                   // 设置语言包
})

new Vue({
    el: '#app',
    router: router,
    i18n:i18n,
    render: h =&gt; h(App)
});</pre>
                <p class="calibre4 pv pid40" id="p40">配置好多语言后，在业务组件中就可以直接使用了，例如：</p>
                <pre class="calibre7 pv pid41" id="p41">// index.vue
&lt;template&gt;
    &lt;div class="index"&gt;
        &lt;p&gt;{{ $t("message.hello") }}&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;</pre>
                <p class="calibre4 pv pid42" id="p42">&lt;p&gt;元素的内容会根据当前传入的语言自动替换语言包对应message.hello的内容。</p>
                <p class="calibre4 pv pid43" id="p43">
                    更多关于vue-i18n的配置和说明可以查阅其文档，vue-i18n分6.x和5.x两个版本，使用会稍有不同，上面介绍的是6.x版本。</p>
                <p class="calibre4 pv pid44" id="p44">6.x文档：http://kazupon.github.io/vue-i18n/en/started.html。</p>
                <p class="calibre4 pv pid45" id="p45">5.x文档：https://kazupon.github.io/vue-i18n/old/。</p></div>
        </div>
    </div>
    <div class="load_more" style="opacity: 1;">已经是最后一章了</div>
</section>
<section class="JD_footer" style="display: none;">
    <section><a class="modify_more"> <i style="color:#272726">
        <svg class="icon" viewBox="0 0 1554 1024" xmlns="http://www.w3.org/2000/svg" width="303.516" height="200">
            <path d="M1376.083 558.44H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zm0-435.662H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zM202.708 994.1h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 010 100.55zm0-435.66h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zm0-435.662h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zM370.314 893.55h1005.769a50.292 50.292 0 010 100.55H370.314a50.292 50.292 0 010-100.55z"></path>
            <path d="M1376.083 558.44H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zm0-435.662H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zM202.708 994.1h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 010 100.55zm0-435.66h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zm0-435.662h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zM370.314 893.55h1005.769a50.292 50.292 0 010 100.55H370.314a50.292 50.292 0 010-100.55z"></path>
            <path d="M1376.083 558.44H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zm0-435.662H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zM202.708 994.1h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 010 100.55zm0-435.66h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zm0-435.662h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zM370.314 893.55h1005.769a50.292 50.292 0 010 100.55H370.314a50.292 50.292 0 010-100.55z"></path>
            <path d="M1376.083 558.44H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zm0-435.662H370.314a50.292 50.292 0 010-100.55h1005.769a50.292 50.292 0 110 100.55zM202.708 994.1h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 010 100.55zm0-435.66h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zm0-435.662h-67.022a50.292 50.292 0 110-100.55h67.022a50.292 50.292 0 110 100.55zM370.314 893.55h1005.769a50.292 50.292 0 010 100.55H370.314a50.292 50.292 0 010-100.55z"></path>
        </svg>
    </i> <span>目录</span> </a> <a class="JD_font"> <i style="color:#272726">
        <svg class="icon" viewBox="0 0 1638 1024" xmlns="http://www.w3.org/2000/svg" width="319.922" height="200">
            <path d="M1497.39 927.851c-15.387 23.844-37 37.616-76.495 10.66l-.617-.44V830.917c-21.025 29.276-59.464 59.904-101.514 84.365-49.304 28.425-104.304 39.349-164.09 39.349-61.491 0-111.206-15.358-149.204-46.162-37.969-31.596-56.968-73.823-56.968-126.738 0-78.17 32.713-135.02 98.167-170.552 52.563-29.188 122.54-43.812 209.841-43.812l160.098-1.204v-22.493c0-97.785-93.704-138.25-173.077-141.656-55.734-2.408-97.08 5.784-140.98 27.661-25.43 11.012-49.774 43.05-56.41 83.044 0 0-48.805 25.136-84.6 0 9.72-68.684 45.515-122.216 94.877-156.192 45.251-31.567 111.117-37.557 187.113-37.557 88.153 0 147.999 13.508 190.05 60.08 37.205 40.289 63.81 91.883 63.81 161.33 0 0 .264 310.857 0 387.47zM1413.143 651l-169.612.088c-147.558.705-225.61 54.237-225.61 138.397 0 23.756 12.45 33.74 37.293 53.326 24.08 19.528 57.232 29.307 99.4 29.307 60.962 0 106.8-14.33 134.403-30.98 50.42-31.45 124.126-98.46 124.126-124.948V651zM843.14 938.07L738.984 685.797H336.686L232.939 935.69s-75.937 10.073-86.978 3.818a3.26 3.26 0 01-1.468-4.111L490.234 92.45a59.434 59.434 0 0187.331 0l345.83 843.095c.588 1.439 0 3.083-1.41 3.876-11.422 6.46-66.04 6.519-78.844-1.35zm-307.01-747.218h-3.347L365.992 603.986h335.787L536.132 190.852z"></path>
        </svg>
    </i> <span style="color: rgb(39, 39, 38);">设置</span> </a></section>
</section>

<script src="./index_files/unify.min.js.下载"></script>
<script src="./index_files/v1"></script>
<div style="position:absolute;height:100%; width:1366px;z-index:1000;top:-9000px;height:674px; overflow:auto;"
     id="JD_contentcf"><title id="p0" class="pv pid0">未知</title></div>
<div style="display:none;font-size: 16px!important;" id="JD_loadyjz"><title id="p0" class="pv pid0">未知</title>
    <h2 class="kindle-cn-heading1 calibre_pb_0 pv pid2" id="p2" name="calibre_pb_0">第15章　相关开源项目介绍</h2>
    <p class="calibre4 pv pid3" id="p3">
        本章将介绍一些实际开发中经常使用的与Vue.js相关的开源项目，它们包括服务端渲染框架Nuxt.js、HTTP库axios以及多语言插件vue-i18n。使用好的开源项目可以让你的团队事半功倍。</p>
    <h3 class="kindle-cn-heading2 sigil_toc_id_127 pv pid4" id="p4" name="sigil_toc_id_127">15.1　服务端渲染与Nuxt.js</h3><h4
            class="kindle-cn-heading3 sigil_toc_id_128 pv pid5" id="p5" name="sigil_toc_id_128">15.1.1　是否需要服务端渲染</h4>
    <p class="calibre4 pv pid6" id="p6">Vue.js 2是支持服务端渲染的，不过在使用前有必要先了解你的业务场景和服务端渲染的特点，然后权衡是否真的需要服务端渲染。</p>
    <p class="calibre4 pv pid7" id="p7">
        服务端渲染（SSR）并不是什么新鲜技术，从互联网开始至今，大部分网站的内容仍然是由服务端渲染的，然后返回到客户端。如何查看一个网站是否是SSR呢？很简单，比如打开一个含有文章内容的网站，查看它的源代码，看这些文字是不是都在源代码里面，如果是，那它就是SSR；或者通过Chrome调试工具，在network面板查看有没有相关的异步请求来调取内容。</p>
    <p class="calibre4 pv pid8" id="p8">
        很多网站之所以使用SSR，主要目的是做搜索引擎优化（SEO）。由于所处的国家和利益不同，谷歌很早就支持对使用Ajax技术异步渲染内容的网站进行爬取，它们洞见了这种技术将会被广泛利用，不过谷歌在服务端的开销也要增加很多，因为这依赖于一个模拟的浏览器环境。百度至今仍不支持爬取动态渲染内容为主的网站，可能是国内目前需营销的网站大多还是静态内容站吧。因此，是否需要SSR，最主要的因素就是是否需要SEO，换句话说，你的产品是面向大众用户的，还是面向企业的。如果是面向企业，那可能只有首页、信息页和一些营销页面需要SEO，与主产品分离。</p>
    <p class="calibre4 pv pid9" id="p9">使用SSR的第二原因是，客户端的网络可能是不稳定的，有的地方很快，有的地方会很慢。这种情况下，通过SSR减少请求量和客户端渲染可以相对快速地看到内容。</p>
    <p class="calibre4 pv pid10" id="p10">
        SSR听起来很不错，使用它也是有前提的，那就是你的团队需要懂Node.js的小伙伴。Vue.js的后端渲染不同于PHP的模板或JSP等网站，你的产品可能还是由PHP、Java等后端来提供数据接口，Node.js在这里只负责渲染，也就是中间层（大前端）。如果你的团队具备了这些技术能力，产品也有SSR的场景，那就可以尽情地使用Vue.js的SSR。</p>
    <h4 class="kindle-cn-heading3 sigil_toc_id_129 pv pid11" id="p11" name="sigil_toc_id_129">15.1.2　Nuxt.js</h4>
    <p class="calibre4 pv pid12" id="p12" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/nuxt/nuxt.js。
    </p>
    <p class="calibre4 pv pid12" id="p12">
        Nuxt.js是一个基于Vue.js的通用应用框架，为Node.js做Vue的服务端渲染提供了各种配置。使用Nuxt.js，你可以轻松、快速地搭建一套SSR框架，省去了大量配置的工作。</p>
    <p class="calibre4 pv pid13" id="p13">
        为了快速体验Nuxt.js，可以下载安装starter模板（https://github.com/nuxt/starter/archive/source.zip）。下载后，通过npm install安装依赖，再通过npm
        run dev启动项目，在浏览器访问127.0.0.1:3000即可预览，如图15-1所示。</p>
    <div class="kindle-cn-bodycontent-div-alone pv pid14" id="p14" style="margin: 0px;"><img alt="340"
                                                                                             class="kindle-cn-bodycontent-image-alone80-withnote"
                                                                                             src="./index_files/504c8a2c3e61e6c5.jpg"
                                                                                             href="./image/00055.jpeg">
        <p class="kindle-cn-picture-txt-withfewcharactors">图15-1　Nuxt.js项目</p></div>
    <p class="calibre4 pv pid14" id="p14">与普通Vue.js项目不同的是，Nuxt.js构建的代码，UI是在服务端渲染的，而非在客户端。通过webpack 创建的SPA项目，查看其源代码，&lt;body&gt;内一般只有一个&lt;div&gt;元素作为根实例挂载节点，其他都由JavaScript来渲染。而查看Nuxt.js构建后的源代码，所有模板内容直接渲染在其中。</p>
    <p class="calibre4 pv pid15" id="p15">使用Nuxt.js基本与写.vue单文件一致，可到项目下的pages内查看首页文件index.vue。更多
        Nuxt.js详细的用法和Vue.js的SSR可以阅读官方文档。</p>
    <p class="calibre4 pv pid16" id="p16">Vue.js服务端渲染（SSR）文档：https://ssr.vuejs.org/</p>
    <p class="calibre4 pv pid17" id="p17">Nuxt.js文档：https://nuxtjs.org/</p>
    <h3 class="kindle-cn-heading2 sigil_toc_id_130 pv pid18" id="p18" name="sigil_toc_id_130">15.2　HTTP库axios</h3>
    <p class="calibre4 pv pid19" id="p19" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/mzabriskie/axios。
    </p>
    <p class="calibre4 pv pid19" id="p19">axios是一个基于Promise，同时支持浏览器端和Node.js的HTTP库，常用于Ajax请求。</p>
    <p class="calibre4 pv pid20" id="p20">Vue.js不像jQuery或AngularJS，本身并没有携带Ajax方法，因此需要借助插件或第三方HTTP库，而axios就是一个很不错的选择。</p>
    <p class="calibre4 pv pid21" id="p21">可以通过NPM或CDN的形式来使用axios，以NPM为例，先进行安装：</p>
    <pre class="calibre7 pv pid22" id="p22">npm install axios --save</pre>
    <p class="calibre4 pv pid23" id="p23">axios 提供了多种请求方式，比如直接发起GET或POST请求：</p>
    <pre class="calibre7 pv pid24" id="p24">axios.get('/user?ID=12345')
    .then(function (response) {
        console.log(response);
    })
    .catch(function (error) {
        console.log(error);
    });

axios.post('/user', {
        firstName: 'Fred',
        lastName: 'Flintstone'
    })
    .then(function (response) {
        console.log(response);
    })
    .catch(function (error) {
        console.log(error);
    });</pre>
    <p class="calibre4 pv pid25" id="p25">基于Promise，可以执行多个并发请求：</p>
    <pre class="calibre7 pv pid26" id="p26">function getUserAccount() {
    return axios.get('/user/12345');
}

function getUserPermissions() {
    return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
    .then(axios.spread(function (acct, perms) {
      //请求都完成时...
    }));</pre>
    <p class="calibre4 pv pid27" id="p27">也可以通过写入配置的形式发起请求：</p>
    <pre class="calibre7 pv pid28" id="p28">axios({
    method: 'post',
    url: '/user/12345',
    data: {
        firstName: 'Fred',
        lastName: 'Flintstone'
    }
})
    .then(function (res) {
        console.log(res);
    });</pre>
    <p class="calibre4 pv pid29" id="p29">在业务中，经常将其封装为实例的形式调用，便于做通用配置，例如：</p>
    <pre class="calibre7 pv pid30" id="p30">// util.js
const instance = axios.create({
    baseURL: 'https://some-domain.com/api',
    timeout: 1000,
    headers: {'Content-Type': 'application/x-www-form-urlencoded;'}
});

export default instance;

// index.vue
&lt;template&gt;
    &lt;div&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
    import Ajax from './util.js';
    export default {
        mounted () {
            Ajax({
                method: 'post',
                url: '/user',
                data: {
                    firstName: 'Fred',
                    lastName: 'Flintstone'
                }
            }).then(res =&gt; {
                console.log(res);
            });
        }
    }
&lt;/script&gt;</pre>
    <p class="calibre4 pv pid31" id="p31">更多关于axios的配置，可到GitHub项目主页阅读其文档。</p>
    <h3 class="kindle-cn-heading2 sigil_toc_id_131 pv pid32" id="p32" name="sigil_toc_id_131">15.3　多语言插件vue-i18n</h3>
    <p class="calibre4 pv pid33" id="p33" style="margin: 0px;"><span class="kindle-cn-bold">项目地址：</span>https://github.com/kazupon/vue-i18n。
    </p>
    <p class="calibre4 pv pid33" id="p33">vue-i18n是一个Vue.js插件，提供了多语言解决方案。如果你的项目有多国语言的需求，可以使用它很快速地实现。</p>
    <p class="calibre4 pv pid34" id="p34">通过NPM来安装：</p>
    <pre class="calibre7 pv pid35" id="p35">npm install vue-i18n --save</pre>
    <p class="calibre4 pv pid36" id="p36">然后在webpack 入口文件中使用插件：</p>
    <pre class="calibre7 pv pid37" id="p37">// main.js
import Vue from 'vue';
import VueI18n from 'vue-i18n';

Vue.use(VueI18n);</pre>
    <p class="calibre4 pv pid38" id="p38">使用vue-i18n插件需要在入口文件中进行多语言包的配置，其实是一个对象，每种语言对应于一个key：</p>
    <pre class="calibre7 pv pid39" id="p39">// main.js接上面代码
// …
const messages = {
    en: {
        message: {
            hello: 'hello world'
        }
    },
    cn: {
        message: {
            hello: '你好，世界'
        }
    }
}

const i18n = new VueI18n({
    locale: 'en',               // 设置当前语言
    messages,                   // 设置语言包
})

new Vue({
    el: '#app',
    router: router,
    i18n:i18n,
    render: h =&gt; h(App)
});</pre>
    <p class="calibre4 pv pid40" id="p40">配置好多语言后，在业务组件中就可以直接使用了，例如：</p>
    <pre class="calibre7 pv pid41" id="p41">// index.vue
&lt;template&gt;
    &lt;div class="index"&gt;
        &lt;p&gt;{{ $t("message.hello") }}&lt;/p&gt;
    &lt;/div&gt;
&lt;/template&gt;</pre>
    <p class="calibre4 pv pid42" id="p42">&lt;p&gt;元素的内容会根据当前传入的语言自动替换语言包对应message.hello的内容。</p>
    <p class="calibre4 pv pid43" id="p43">更多关于vue-i18n的配置和说明可以查阅其文档，vue-i18n分6.x和5.x两个版本，使用会稍有不同，上面介绍的是6.x版本。</p>
    <p class="calibre4 pv pid44" id="p44">6.x文档：http://kazupon.github.io/vue-i18n/en/started.html。</p>
    <p class="calibre4 pv pid45" id="p45">5.x文档：https://kazupon.github.io/vue-i18n/old/。</p></div>
</body>
</html>